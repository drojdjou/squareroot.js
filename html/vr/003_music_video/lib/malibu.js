/* --- --- [Version] --- --- */

/**
 *	@const Framework
 *	@description autogenerated with build script, holds current verison info
 *	@property {string} version - the version 
 *	@property {string} build - the  build number
 *	@property {string} date - the date of the build
 */
// DO NOT EDIT. Updated from version.json
var Framework = {"version":"4","build":57,"date":"2015-09-01T19:00:26.757Z"}

/* --- --- [Simplrz] --- --- */

/**
 *	@namespace Simplrz
 *
 *	@description Feature detection utility.
 *
 *	<p><h2>Using Simplrz</h2>
 *
 *	<p>Simplr is initialized at startup and all test are done immediately. 
 *	The results of the tests are stored in boolean variables listed below. 
 *	Overtime new features are added and some old ones can be discarded, 
 *	so be sure to check the docs from time to time.
 *
 *	<blockquote>
 *	<h5>Note on detecting some CSS features</h5>
 *
 *	<p>After reading this (https://github.com/zamiang/detect-css3-3d-transform)
 *	I realized detecting css3d transforms is unreliable. But also - we don't really need it
 *	because typically the only browser we need to support that doesn't do css 3d transforms
 *	is IE9 and IE8 so why not do some good old browser sniffing?
 *
 *	<p>As a reminder: IE9 - only 2d transforms, no transitions, no animations, IE8 - not even 2d.
 *	</blockquote>
 *
 *	<p>Using Simplrz is very simple in JS, please refer to the first example below. 
 *	Simplrz also sets the names of the properties as classes to the <html> element of the document.
 *	Each class follows the same naming pattern:
 *
 *	<p><code>webgl</code> - if feature is supported the class name is simply the name of the feature.
 *	<p><code>no-webgl</code> - if feature is not supported the class name is  the name of the feature with a <code>no-</code> prefix.
 *
 *	<p>CSS stylesheets can use those classes to use conditiojnal logic. 
 *	Especially handy for example to define hover effects for non-touch only (see example below).
 *
 *	<p>Example that runs the cod in your browser and prints out all the results <a href='http://work.bartekdrozdz.com/malibu/test/simplrz.html'>is here</a>.
 *
 *	@example
if(Simplrz.touch) {
	document.addEventListener('touchstart', onDown);
} else {
	document.addEventListener('mousedown', onDown);
}
 *
 *	@example
// Assuming we use LESS

// This will only work on non-touch screens
.no-touch a:hover {
  text-decoration: underline;
}

#app {
  .webgl-warning {
    display: none;
  }

  // If webgl is not supported, show the warning
  .no-webgl & .webgl-warning {
    display: block;
  } 
}
 */
var Simplrz = (function() {

	var s = {}, classes = ['js']; // Add 'js' class by default (bc if this code runs, JS is enabled, right?)

	var check = function(feature, test) {
		var result = test();
		s[feature] = (result) ? true : false;
		classes.push( (result) ? feature : "no-" + feature );

		document.documentElement.setAttribute("class", classes.join(" "));
	}

	/**
	 *	@member pixelRatio
	 *	@memberof Simplrz
	 *	@description Same vallue as <code>window.devicePixelRatio</code>
	 */
	s.pixelRatio = window.devicePixelRatio || 1;

	var prefix = (function () {

		var styles = "", pre = "", dom = "";

		if(window.getComputedStyle) {
			styles = window.getComputedStyle(document.documentElement, '');
			pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o']))[1];
			dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];
		}

		return {
			dom: dom,
			lowercase: pre,
			css: '-' + pre + '-',
			js: (pre == "") ? "" : pre[0].toUpperCase() + pre.substr(1)
		};
	})();

	/**
	 *	@member prefix
	 *	@memberof Simplrz
	 *	@description whar is the browser vendor prefix (-ms, -webkit, -moz...)
	 *
	 *	@returns {Object} contins several versions of the prefix, see example below.
	 *
	 *	@example
{
	dom: "Webkit",
	lowercase: "webkit,
	css: "-webkit-",
	js: "Webkit"
}
	 */
	s["prefix"] = prefix;
	classes.push(prefix.lowercase);

	s.prefixedProp = function(prop) {
		switch(prefix.lowercase) {
			case "webkit": return "webkit" + prop.charAt(0).toUpperCase() + prop.slice(1);
			case "ms": return "-ms-" + prop;
			case "moz": return "Moz" + prop.charAt(0).toUpperCase() + prop.slice(1);
			default: return prefix.css + prop;
		}
	} 

	// -- BROWSER HACKS BEGIN -- 
	// These properties are for browser specific hack (yes, they are sometimes necessary)
	var ie = (function(){
	    var v = 3, div = document.createElement('div'), all = div.getElementsByTagName('i');
	    while (
	        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
	        all[0]
	    ) {
	    	// console.log(div.innerHTML);
	    }
	    return v > 4 ? v : null;
	})();

	// IE 10 doesn't use conditional comments anymore
	if(ie == null) {
		var p = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
		var ua = navigator.userAgent;
		var m = ua.match(p);
		ie = (m && m.length > 1) ? parseInt(m[1]) : null;
	}

	/**
	 *	@member {Boolean} ie
	 *	@memberof Simplrz
	 *	@description false if browser is not IE, otherwise the version number (8, 9, 10...)
	 */
	s.ie = ie || false;
	classes.push((ie) ? "ie-" + ie : "no-ie");

	/**
	 *	@member {Boolean} firefox
	 *	@memberof Simplrz
	 *	@description True if the device is an iPad.
	 */
	s.firefox = prefix.lowercase == "moz";
	classes.push(s.firefox ? "firefox" : "no-firefox");

	/**
	 *	@member {Boolean} safariDesktop
	 *	@memberof Simplrz
	 *	@description True if the the browser is a Safari on desktop Mac.
	 */
	s.safariDesktop = navigator.userAgent.match(/Safari/) && !navigator.userAgent.match(/Chrome/) && !('ontouchstart' in document);
	classes.push(s.safariDesktop ? "safari-desktop" : "no-safari-desktop");

	// s.ipad7 = navigator.userAgent.match(/iPad;.*CPU.*OS 7_\d/i) || false;
	// classes.push(s.ipad7 ? "ipad7" : "no-ipad7");

	/**
	 *	@member {Boolean} iOS
	 *	@memberof Simplrz
	 *	@description True if the device runs on iOS.
	 */
	s.iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
	classes.push(s.iOS ? "ios" : "no-ios");

	/**
	 *	@member {Boolean} iPad
	 *	@memberof Simplrz
	 *	@description True if the device is an iPad.
	 */
	s.iPad = (navigator.platform == 'iPad');
	classes.push(s.iPad ? "ipad" : "no-ipad");

	// -- BROWSER HACKS END -- 



	/**
	 *	@member {Boolean} css3d
	 *	@memberof Simplrz
	 *	@description True if CSS 3d transforms are supported.
	 */
	check("css3d", function() {

		if(prefix.lowercase == 'webkit' || prefix.lowercase == 'moz') return true;

		if(prefix.lowercase == 'ms') {
			var div = document.createElement("div");
			div.style[prefix.css + "transform"] = 'translateZ(0px)';
			var cs = getComputedStyle(div);
			var a = cs.getPropertyValue(prefix.css + "transform");
			return a && a != '' && a != 'none';
		}

		return false;
	});

	/**
	 *	@member {Boolean} csstransitions
	 *	@memberof Simplrz
	 *	@description True if CSS Transitions are supported.
	 */
	check("csstransitions", function() { return !ie || ie >= 10; });

	/**
	 *	@member {Boolean} cssanimations
	 *	@memberof Simplrz
	 *	@description True if CSS Animations are supported.
	 */
	check("cssanimations", function() { return !ie || ie >= 10; });

	/**
	 *	@member {Boolean} css2d
	 *	@memberof Simplrz
	 *	@description True if CSS 2d transforms are supported.
	 */
	check("css2d", function() { return !ie || ie >= 9; });

	/**
	 *	@member {Boolean} touch
	 *	@memberof Simplrz
	 *	@description True if touch events are supported.
	 *	<p>Experimental: some laptop PCs runnig Windows have a touch screen. 
	 *	Chrome on such PCs will report true for the 'ontouchstart' event, 
	 *	however the touch events are not supported well in such case. So this test
	 *	will report `false` if we are on Win32 platform, even if touch screen is detected. 
	 */
	check("touch", function() {
		return 'ontouchstart' in document && navigator.platform != 'Win32';
	});

	/**
	 *	@member {Boolean} pointer
	 *	@memberof Simplrz
	 *	@description True if pointer API (sort of like touch but different spec, used mostly by MS) is supported.
	 */
	check("pointer", function() {
		return (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1);
	});

	/**
	 *	@member {Boolean} canvas
	 *	@memberof Simplrz
	 *	@description True if canvas 2d API is supported.
	 */
	check("canvas", function() {
		try { 
			var canvas = document.createElement('canvas'); 
			return canvas.getContext('2d');
		} catch(e) { 
			return false; 
		}
	});

	/**
	 *	@member {Boolean} history
	 *	@memberof Simplrz
	 *	@description True if the history API is supported.
	 */
	check("history", function() {
		return !!(window.history && history.pushState);
	});

	/**
	 *	@member {Boolean} webrtc
	 *	@memberof Simplrz
	 *	@description True if webrtc is supported.
	 */
	check("webrtc", function() {
		return ('getUserMedia' in navigator || 'webkitGetUserMedia' in navigator);
	});

	/**
	 *	@member {Boolean} webgl
	 *	@memberof Simplrz
	 *	@description True if webgl is supported.
	 */
	check("webgl", function() {
		try { 
			var canvas = document.createElement('canvas'); 
			return !!window.WebGLRenderingContext && 
				(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
		} catch(e) { 
			return false; 
		} 
	});

	// Flash is dead anyway!
	// check("flash", function() {
	// 	return !!(
	// 		navigator.mimeTypes["application/x-shockwave-flash"] || 
	// 		window.ActiveXObject && new ActiveXObject('ShockwaveFlash.ShockwaveFlash')
	// 	);
	// });

	/**
	 *	@member {Array} classes
	 *	@memberof Simplrz
	 *	@description An array containing all the classes that have been added to the <html> element.
	 */
	s.classes = classes;

	return s;

})();

/* --- --- [Trigger] --- --- */

/**
 *	@class Trigger
 *
 *	@description Trigger is a simple utility used to create events. 
 *	<p>A Trigger can only send one type of event and it will always notify all of its listeners. 
 * 	<p>In order to build a more robust event system, use multiple 
 *	Trigger objects as properties.
 *
 *	@example
// Simple usage for a single type of event
var menuPress = new Trigger();

var menuPressListener = function(params) {
  console.log("menuPress trigger fired");
  // params = whatever was passed to the trigger method (see below)
  console.log(params);
}

menuPress.on(menuPressListener);

// ... then somewhere in the code:
menuPress.trigger({ id: 5 });

// ... and eventually
menuPress.off(menuPressListener);
 *
 *	@example
// If there are multiple events to handle, 
// simply create multiple triggers
var car = {
  engineStarted: new Trigger(),
  brakeApplied: new Trigger(),
  gearChanged: new Trigger()
}
 */
var Trigger = function() {

	var t = {};

	var listeners = [];
	var lock = false;

	var lateTriggers = [];
	var lateRemovals = [];

	/**
	 *	@method on
	 *	@memberof Trigger.prototype
	 *	@param {Function} callback - the function used as callback for the listener
	 *	@param {Object=} context - the context in which to invoke the function
	 *	@description Adds a listener to this trigger
	 */
	t.on = function (callback, context) {
		callback.context = context;
		listeners.push(callback);
	};

	/**
	 *	@method off
	 *	@memberof Trigger.prototype
	 *	@param {Function} callback - the function used as callback for the listener. 
	 *	Needs to be the same function as passed to the <code>on()</code> when it was being registered.
	 *	@description Removes a listener from this trigger. 
	 *	<p>If the passed callback is not a listener of this trigger, 
	 *	this function will not throw any warnings, it will just return. 
	 *	<p>If this function is called from within a function that is a listener for that trigger, 
	 *	the callback will not be removed until all other listeners are called.
	 */
	t.off = function (callback) {
		var i = listeners.indexOf(callback);

		if(i == -1) return;

		if(lock) {
			lateRemovals.push({ callback: callback });
			return;
		}

		listeners.splice(i, 1);
	};

	/**
	 *	@method trigger
	 *	@memberof Trigger.prototype
	 *	@param {Object=} data - An object specifying the events parameters. All listeners will receive this object as argument.
	 *	@description Fires this trigger passing data as srgument to all listeners.
	 *	<p>If this function is called from within a function that is a listener for that trigger, 
	 *	the trigger will not be fired until all other listeners 
	 *	are called for the previous one.
	 */
	t.trigger = function (data) {

		if(lock) {
			lateTriggers.push({ data: data });
			return;
		}

		lock = true;

		var i = 0, nl = listeners.length;
		while(i < nl) {
			var f = listeners[i];
			f.call(f.context, data);
			i++;
		}
		
		lock = false;

		var d;
		while(d = lateTriggers.shift()) t.trigger(d.data);
		while(d = lateRemovals.shift()) t.off(d.callback);
	};

	return t;

};

/* --- --- [Timer] --- --- */

/**
 *	@class Timer
 *
 *	@description A timer utility used to invoke function once or repeatedly in time.
 *
 *	@param {Boolean} autostart - if true the Timer will start counting time immediately. Otherwise start() needs to be called manually later.
 *	@param {Boolean} autoupdate - if true the Timer will be updating on every frame. Otherwise, update() needs to be called on every frame.
 */
var Timer = function(autostart, autoupdate) {

	var that = this;

	// If frame is longer than 250ms (4 FPS) it will skip it.
	// TODO: what is the logic behind this?
	var MAX_FRAME_TIME = 250;

	var paused = false;

	this.time = 0;
	this.frame = 0;
	this.deltatime = 0;

	var startTime, elapsedTime = 0;

	var tasks = [];

	var trackTask = function(e, i) {
		if(e._time < that.time) {
			if(e._repeat != 0) {
				e.callback(e._time);

				var it = e._interval;
				if(it instanceof Array) e._time += it[0] + Math.random() * (it[1] - it[0]);
				else e._time += it;

				e._repeat--;
			} else {
				setTimeout(that.off, 0, e); // <- is it good enough?
			}
		}
	};

	var run = function() {
		requestAnimationFrame(run);
		that.update();
	}

	/**
	 *	@method pause
	 *	@memberof Timer.prototype
	 *	@description Pauses/resumes the execution of the timer.
	 *	@param {Boolean} p - true to pause, false to resume
	 *	@return {Timer} self, for chaining.
	 */
	this.pause = function(p) {
		paused = p;
		return this;
	}

	/**
	 *	@method paused
	 *	@memberof Timer.prototype
	 *	@description Returns true is timer is paused, false otherwise.
	 */
	this.paused = function() {
		return paused;
	}

	/**
	 *	@method start
	 *	@memberof Timer.prototype
	 *	@description Start the timer manually.
	 *	<p>If autostart was set to false or omitted in the constructor, this function needs to be invoked.	
	 */
	this.start = function() {
		startTime = new Date().getTime(), 
		elapsedTime = 0, 
		that.frame = 0;
		that.time = 0;

		if(autoupdate) run();

		return that;
	}

	/**
	 *	@method update
	 *	@memberof Timer.prototype
	 *	@description Updates the timer.
	 *
	 *	<p>If autoupdate was set to false or omitted in the constructor, 
	 *	this function need to be invoked in a requestAnimationFrame loop or a similar interval.
	 */
	this.update = function() {
		var t = new Date().getTime() - startTime;
		var d = t - elapsedTime;
		elapsedTime = t;

		if(d < MAX_FRAME_TIME && !paused) {
			that.time += d;
			that.frame++;
			that.deltatime = d;
		}

		tasks.forEach(trackTask);
		return that.time;
	}

	/**
	 *	@method onAt
	 *	@memberof Timer.prototype
	 *	@description Executes callback after a delay. All time values in milliseconds.
	 *
	 *	@param {Number} time - when to start (i.e. delay counted from 'now' i.e from when this method is called)
	 *	@param {Function} callback - the callback to be invoked
	 *
	 *	@returns {Object} - an special object that can be used to remove the task later.
	 */
	this.onAt = function(_time, callback) {
		var so = {
			callback: callback,
			_time: that.time + _time,
			_repeat: 1
		};

		tasks.push(so);
		return so;
	}

	/**
	 *	@method onEvery
	 *	@memberof Timer.prototype
	 *	@description Invokes the callback repeatedly overtime. All time values in ms.
	 * 	
	 *	@param {Number} interval - how often to invoked the function. It can be an array of two elements specyfing a min/max range
	 *	@param {Number} time - when to start (i.e. delay, counted from 'now' i.e from when this method is called)
	 *	@param {Number} callback - the callback to be invoked
	 *	@param {Number} repeat - how many times to repeat. If ommited or -1 will repeat infinitely
	 *				0 will never invoke the function (in fact it won't even be added)
	 *
	 *	@returns {Object} an object that can be later used to remove the task.
	 */
	this.onEvery = function(_interval, _time, callback, _repeat) {

		if(_repeat === 0) return;
		
		var so = {
			callback: callback,
			_time: that.time + _time,
			_interval: _interval,
			_repeat: _repeat || -1

		};

		tasks.push(so);
		return so;
	}

	/**
	 *	@method off
	 *	@memberof Timer.prototype
	 *	@description Remove a scheduled task.
	 *
	 *	@param {Object} so - Object referencing the callback. 
	 *	<p>DO NOT PASS the original callback to this function (you'll get a warning if you do).
	 *	Instead you need to pass the object returned from onAt or onEvery. 
	 */
	this.off = function(so) {

		if(so instanceof Function) {
			var m = 'You are probably using the callback directly to remove it.\n';
			m += 'You should use the object returned from onAt or onEvery instead.';
			console.warn(m);
			console.warn(so);
			return;
		}

		if(so == null) {
			return;
		}

		var i = tasks.indexOf(so);
		if(i > -1) {
			tasks.splice(i, 1);
			return true;
		} else {
			return false;
		}
	}

	/**
	 *	@method clearTasks
	 *	@memberof Timer.prototype
	 *	@description Remove all tasks scheduled using onAt or onEvery
	 */
	this.clearTasks = function() {
		tasks.length = 0;
	}

	if(autostart) {
		that.start();
	}
}

/** 
 *	@member global
 *	@memberof Timer
 *	@static
 *
 *	@description A global static instance of a Timer for simple use cases.
 */
Timer.global = new Timer(true, true);


/* --- --- [Value] --- --- */

/**
 *	@class Value
 *
 *	@description <p>Value is an object that hold a property. 
 *
 *	<p>Properties are great to keep track of the state of on object. 
 *	For example "how many times the spaceship has been hit" or 
 *	"what is the current section on a website" or a lot of other things.
 *
 *	<p>A simple property can do the job well, example: "spaceship.numHits" is a number
 *	that increases each time the spacehip has been hit by enemy lasers. 
 *	
 *	<p>Usually there will be several objects in each application that will need 
 *	to do something whenever this value changes. To make this possible each of those
 *	objects would need to implement some sort of loop or timer and check the value of
 *	this property at regular intervals.
 *
 *	<p>This is where the Value object comes in handy. It keeps the value of the property
 *	in it's own property (called 'value') but, using the object observer pattern, 
 *	each time this value changes, it will send out a notification to every
 *	registered listener.
 *
 *	<p>The Value object works best with primitive values, especially Numbers. 
 *	But it can hold any object as value.
 *
 *	@param {Object} v - the initial value to set
 *
 *	@example

// sets the value to 1
var health = new Value(1);

health.on(function(current, last) {
	console.log('The value of health is', current);
	console.log('The previous value was', last);
	console.log('Current value can also be accessed from', health.value);
});

// value changed, the listener will be invoked
health.value = 2;

// value stays the same, the listener won't be invoked
health.value = 2;

 */

/*
 *	Also read this http://www.html5rocks.com/en/tutorials/es7/observe/
 */
var Value = function(_value) {

	var that = this, 
		value = _value, 
		last = null;
	
	var min = null, max = null, wrap = false;

	var observers = [];

	that.observers = function() {
		return observers;
	}

	/**
	 *	@method on
	 *	@memberof Value.prototype
	 *
	 *	@param {Function} callback - the callback to invoke whenever the value changes. 
	 *	The callback function will receive up to 3 arguments. First is the current value, 
	 *	second is the last value (if there was any, null otherwise). Third is a custom param (see below).
	 *
	 *	@param {Function} test - a test function to check if value changed. If the value is a Object, 
	 *	some of it's properties might chnage and this function allows to inject the logic that will
	 *	decide whether the entire value should be considered "chnaged" or not. See example below.
	 *
	 *	@param {Object} param - a parameter to pass to the callback on each change. It will be passed as 3rd parameter.
	 *
	 *	@param {Boolean=} noInitCallback - if this is set explicitely to true, the callback will not be invoked immediately
	 *	on registration. Otherwise the callback is always called immediately, so that any state can be adjusted to the current
	 *	value.
	 *
	 *	@description sets the value property of thie Value to whatever is passed as parameter. 
	 *	Same as saying <code>someValue.value = v;</code> but this method can be useful when chaining. 
	 */
	that.on = function(callback, test, param, noInitCallback) {
		var o = callback;
		o.test = test;
		o.param = param;

		// Fire the callback initially so that all values/flags of the subscriber can be adjusted at startup
		if(!noInitCallback && (!o.test || o.test(value, last))) o(value, last, param);

		observers.push(o);
		return o;
	}

	/**
	 *	@method off
	 *	@memberof Value.prototype
	 *	@param {Function} callback - the callback that was originally passed to <code>on</code>.
	 *	@description Removes the callback from the list of listeners for this value.
	 */
	that.off = function(callback) {
		var i = observers.indexOf(callback);
		if(i > -1) observers.splice(i, 1);
	}

	that.range = function(_min, _max, _wrap) {
		min = _min;
		max = _max;
		wrap = _wrap;
		return that;
	}

	/**
	 *	@method set
	 *	@memberof Value.prototype
	 *	@param {Object} v
	 *	@description sets the value property of thie Value to whatever is passed as parameter. 
	 *	Same as saying <code>someValue.value = v;</code> but this method can be useful when chaining.
	 */
	that.set = function(v) {
		that.value = v;
		return that;
	}

	var changed = function() {
		var o;
		for(var i = 0, n = observers.length; i < n; i++) {
			o = observers[i];
			if(!o.test || o.test(value, last)) {
				o(value, last, o.param);
			}
		}
	}

	Object.defineProperty(this, 'value', {

		get: function() { 
			return value; 
		},

		set: function(n) { 
			if(min != null && max != null) {
				if(n < min) {
					wrap ? n = n % (max+1) : n = min;
					if(wrap) while(n < min) n += (max+1);
				}

				if(n > max) {
					wrap ? n = n % (max+1) : n = max;
					if(wrap) while(n < min) n += (max+1);
				}
			}

			if(n == value) return;

			last = value;
			value = n; 
			changed();
			// setTimeout(changed, 0);
		}

	});

	Object.defineProperty(this, 'last', {
		get: function() { 
			return last; 
		},
	});

}



/* --- --- [Application] --- --- */

/**
 *	@namespace Application
 */
var Application = (function() {

	var app = {};
	var router;

	/**
	 *	@member {Trigger} resize
	 *	@memberof Application
	 *	@static
	 */
	app.resize = new Trigger();

	/**
	 *	@member {Value} route
	 *	@memberof Application
	 *	@static
	 */
	app.route = new Value();
	
	/**
	 *	@function init
	 *	@memberof Application
	 *	@static
	 */
	app.init = function(params) {

		params = params || {};

		router = HistoryRouter(app, params);
		router.init();

		window.addEventListener('resize', function(e) {
			app.resize.trigger(e);
		});

		window.addEventListener('orientationchange', function(e) {
			app.resize.trigger(e);
		});

		console.log('Malibu v' + 
			Framework.version + 
			' b' + Framework.build + 
			' (history:' + !params.disableHistoryAPI + ')');
	}
	
	return app;

})();




/* --- --- [domExtend/DomExtend] --- --- */

/**
 *	@namespace DomExtend
 */
var DomExtend = (function() {

	var that = {};

	/**
	 *	@method create
	 *	@memberof DomExtend
	 *	@static
	 *	@param {string} tag - the name of the tag to create
	 *	@description Created a HTMLElement of type defined by the tag. It first calls <code>document.createElement(tag)</code> 
	 *	and the extends this element with DomExtend functionality.
	 */
	that.create = function(tag) {
		var e = document.createElement(tag);
		that.extend(e);
		return e;
	};

	that.select = function(sel, element) {
		var e = (element || document).querySelector(sel);
		if(e && !e.ext) that.extend(e);
		return e;
	};

	that.selectAll = function(sel, element) {
		var es = (element || document).querySelectorAll(sel);
		var nes = es.length, r = [];
		for(var i = 0; i < nes; i++) {
			var e = es[i]
			if(!e.ext) e = that.extend(e);
			r.push(e);
		}
		return r;
	};

	that.extend = function(element) {

		if(element.ext) return element;

		var ext = {};

		ext.create = function(tag) {
			return that.create(tag);
		};

		ext.select = function(sel) {
			return that.select(sel, element);
		};

		ext.selectAll = function(sel) {
			return that.selectAll(sel, element);
		};

		ext.detach = function() {
			var p = element.parentNode;
			if(!p) return;
			p.removeChild(element);
		};

		ext.attachTo = function(parent) {
			if(element.parentNode == parent) return;
			else parent.appendChild(element);
		}

		// Add State related functions (see State.js for details)
		if(window.ExtState) ExtState(ext, element);

		// Add Transform related functions (see Transform.js for details)
		if(window.ExtTransform) ExtTransform(ext, element);

		// Add Transition related functions (see Transition.js for details)
		if(window.ExtTransition) ExtTransition(ext, element); 

		// Add Animation related functions (see Transition.js for details)
		if(window.ExtAnimation) ExtAnimation(ext, element, that); 

		ext.element = element;
		element.ext = ext;
		return element;
	};

	that.extend(document);
	window.EXT = that;

	return that;

})();

/* --- --- [domExtend/State] --- --- */

var ExtState = function(ext, element) {

	var cc = function(p) {
		return p.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
	}

	ext.data = {};

	/**
	 *	@method show
	 *	@memberof DomExtend.prototype
	 *	@param {string} [display=block] the CSS property value to use.
	 *	@description Sets the display CSS property of the object to the display type specified in the argument. Defaults to "block".
	 */
	ext.show = function(display) {
		element.style.display = display || "block";
	};

	/**
	 *	@method hide
	 *	@memberof DomExtend.prototype
	 *	@description Sets the display CSS property of the object to "none".
	 */
	ext.hide = function() {
		element.style.display = "none";
	};

	/**
	 *	@method visible
	 *	@memberof DomExtend.prototype
	 *	@description Returns true if the CSS display property is set to none on this element.
	 */	
	ext.visible = function() {
		return ext.readCss('display') != "none";
	};

	ext.on = function(event, callback, useCapture) {
		if(Simplrz.touch && event == 'click') {
			callback.___thProxy = Util.handleTap(element, callback);
			return callback.___thProxy;
		} else {
			return element.addEventListener(event, callback, useCapture);
		}
	};

	ext.off = function(event, callback, useCapture) {
		if(callback.___thProxy) {
			Util.clearTapHandler(element, callback.___thProxy);
			callback.___thProxy = null;
		} else {
			return element.removeEventListener(event, callback, useCapture);	
		}
		
	};

	/**
	 *	@method readCss
	 *	@memberof DomExtend.prototype
	 *
	 *	@param {string} property - the name of the CSS property
	 *	@param {Boolean} notCalculated - if true, grabs the value directly from the style property of the object.
	 *
	 *	@description <p>Returns true if the value of a CSS property, fetched using computed styles.
	 *	<p>The CSS values of the object can be defined in multiple stylesheets, so it's not straightforward
	 *	to read them - i.e. in most cases just saying ex. <code>var d = element.style.display</code> will not return 
	 *	expected results. 
	 *	<p>This method uses computed styles to fetch the actual CSS value of a property.
	 */	
	ext.readCss = function(property, notCalculated) {
		return (notCalculated) ? element.style[property] : getComputedStyle(element).getPropertyValue(property);
	}
};

/* --- --- [domExtend/Transform] --- --- */

var ExtTransform = function(ext, element) {

	var force2d = false;

	var zeroRect = { width: 0, height: 0, top: 0, left: 0 };

	/**
	 *	IE10 tends to throw and "unspecified error" here, so handle
	 *	the exception and just return a zero rect to avoid further damage
	 */
	ext.rect = function() {
		try {
			return element.getBoundingClientRect();
		} catch(e) {
			console.log(e.stack);
			return zeroRect;
		}
	};

	/**
	 *	The 'else' below is because IE somehow throws an error 
	 *	when the value is set and then rect() is called immediately after
	 */
	ext.width = function(v) {
		if(v) {
			element.style.width = v + "px";
			return v;
		} else {
			return ext.rect().width;
		}
	};

	ext.height = function(v) {
		if(v) {
			element.style.height = v + "px";
			return v;
		} else {
			return ext.rect().height;
		}
	};

	ext.x = 0;
	ext.y = 0;
	ext.z = 0;

	ext.rotX = 0;
	ext.rotY = 0;
	ext.rotZ = 0;

	ext.scaleX = 1;
	ext.scaleY = 1;
	ext.scaleZ = 1;

	ext.setX = function(v) { ext.x = v; return ext; };
	ext.setY = function(v) { ext.y = v; return ext; };
	ext.setZ = function(v) { ext.z = v; return ext; };

	ext.transformToString = function(values) {
		values = values || ext;

		var t = "";

		if(values.x) t += "translateX(" + values.x + "px) ";
		if(values.y) t += "translateY(" + values.y + "px) ";
		if(Simplrz.css3d && !force2d) t += "translateZ(" + values.z + "px) ";
		
		if(values.rotX && Simplrz.css3d) t += "rotateX(" + values.rotX + "deg)  ";
		if(values.rotY && Simplrz.css3d) t += "rotateY(" + values.rotY + "deg)";
		if(values.rotZ && Simplrz.css3d) t += "rotateZ(" + values.rotZ + "deg) ";
		else if(values.rotZ) t += "rotate(" + values.rotZ + "deg) ";
		
		if(values.scaleX != 1) t += "scaleX(" + values.scaleX + ") ";
		if(values.scaleY != 1) t += "scaleY(" + values.scaleY + ") ";
		if(values.scaleZ != 1 && Simplrz.css3d) t += "scaleZ(" + values.scaleZ + ")";
	
		return t;
	};

	ext.transform = function(values) {
		if(values) {
			for(var i in values) {
				ext[i] = values[i];
			}
		}

		var t = ext.transformToString(ext, force2d);
		element.style[Simplrz.prefixedProp('transform')] = t;
		element.style["transform"] = t;
	};
};










/* --- --- [domExtend/Transition] --- --- */

var ExtTransition = function(ext, element) {

	var events = {
		'transition': 'transitionEnd',
		'Moz': 'transitionend',
		'O': 'oTransitionEnd',
		'Webkit': 'webkitTransitionEnd',
		'Ms': 'MSTransitionEnd'
	};

	var trEvent = events[Simplrz.prefix.js];
	var TR = "transform";

	var now = function() {
		return new Date().getTime();
	}

	ext.createTransition = function() {

		var transition = {};
		var tr = [], ts = [];
		var cb, numTrans;
		var startTime, maxTime = 0, finalized;

		var onEnded = function(e) {
			numTrans--;
			if(numTrans <= 0) {
				var t = now() - startTime;
				if(t >= maxTime) {
					finalize();
				} else if(!finalized) {
					// console.log("Transition early end > ", t, maxTime);
					setTimeout(finalize, t);
					finalized = true;
				}
			}
		};

		var finalize = function() {
			transition.clear();
			if(cb) cb();
		}

		var setValues = function(vals) {
			var nv = vals.length;

			for(var i = 0; i < nv; i++) {
				var p = vals[i][0], v = vals[i][1];
				if(p == TR) ext.transform(v);
				else element.style[p] = v;
			}

			return transition;
		};

		function propToCss(str) {
			return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
		}

		transition.add = function(property, to, time, ease, delay) {
			maxTime = Math.max(maxTime, time);
			ease = ease || Util.cssEase.ease;
			delay = delay || 0;
			tr.push([propToCss(property), time+'ms', ease, delay+'ms'].join(' '));
			ts.push([property, to]);

			return transition;
		}

		transition.trs = function(values, time, ease, delay) {
			maxTime = Math.max(maxTime, time);
			ease = ease || Util.cssEase.ease;
			delay = delay || 0;
			tr.push([Simplrz.prefix.css + "transform", time+'ms', ease, delay+'ms'].join(' '));
			ts.push([TR, values]);

			return transition;
		}

		transition.clear = function() {
			element.removeEventListener(trEvent, onEnded);
			tr = [];
			ts = [];
			element.style[Simplrz.prefix.js + "Transition"] = "";
			element.style["transition"] = "";
		}

		transition.start = function(callback) {
			cb = callback;
			numTrans = ts.length;

			// force repaint
			element.offsetWidth = element.offsetWidth;

			element.addEventListener(trEvent, onEnded);
			startTime = now();
			finalized = false;
			element.style[Simplrz.prefix.js + "Transition"] = tr;
			element.style["transition"] = tr;
			setValues(ts);

			return transition;
		};

		transition.then = function(callback) {
			var t = ext.createTransition();

			var c = function() {
				callback();
				t.start();
			}

			transition.start(c);

			return t;
		}

		return transition;

	};

	ext.transition = function(properties, time, ease, delay, callback) {
		var t = ext.createTransition();

		for(var p in properties) {
			var v = properties[p];
			if(p == TR) t.trs(v, time, ease, delay);
			else t.add(p, v, time, ease, delay);
		}

		t.start(callback);
		return t;
	}
};




/* --- --- [domExtend/Animation] --- --- */

var ExtAnimation = function(ext, element, globalExt) {

	var events = {
		'animation': 'animationend',
		'Moz': 'animationend',
		'O': 'oanimationend',
		'Webkit': 'webkitAnimationEnd',
		'Ms': 'MSAnimationEnd'
	};

	var animStrigify = function(anim) {
		return [
			anim.name, 
			anim.duration + 's', 
			anim.ease, 
			anim.delay + 's', 
			anim.count, 
			anim.direction, 
			anim.fillMode//, 
			// anim.playState // doesn't work on Safari 8.0, but it's not very useful anyway
		].join(' ');
	}

	// animation: name duration timing-function delay iteration-count direction fill-mode (play-state - not-inplemented);
	var createAnimation = function(name, duration, ease, delay) {
		var a = {
			name: name,
			duration: duration || 1,
			ease: ease || 'ease',
			delay: delay || 0,
			count: 1,
			direction: 'normal',
			fillMode: 'backwards'//,
			// playState: 'running'
		};

		a.setTime = function(t) {
			a.time = t;
			return a;
		}

		a.setDelay = function(t) {
			a.delay = t;
			return a;
		}

		return a;
	}

	globalExt.createAnimation = createAnimation;
	ext.createAnimation = createAnimation;

	ext.animate = function(anim, callback, dontClear) {

		var a;

		if(anim instanceof Array) {
			var aa = [];
			anim.forEach(function(e) { aa.push(animStrigify(e)); });
			a = aa.join(', ');
		} else {
			a = animStrigify(anim);
		}

		var eventName = events[Simplrz.prefix.js];

		if(element._onEnded) element.removeEventListener(eventName, element._onEnded);

		element._onEnded = function() {
			element.removeEventListener(eventName, element._onEnded);

			if(dontClear == null) {
				element.style[Simplrz.prefix.js + "Animation"] = '';
				element.style["animation"] = '';
			}

			if(callback) callback();
		}


		element.style[Simplrz.prefix.js + "Animation"] = "";
		element.style["animation"] = "";

		setTimeout(function() {
			if(ext.show) ext.show();
			element.addEventListener(eventName, element._onEnded);
			element.style[Simplrz.prefix.js + "Animation"] = a;
			element.style["animation"] = a;
		}, 0);
	}
};

/* --- --- [FrameImpulse] --- --- */

/**
 *	@namespace FrameImpulse
 *
 *	@description A utility to handle <code>requestAnimationFrame</code> loops.
 *
 *	@example
var render = function() {
  // Do some rendering logic in here
}

// When the loop needs to be activated
FrameImpulse.on(render);

// ...and when it needs to stop
FrameImpulse.off(render);
 */
var FrameImpulse = (function() {

    var vendors = ['webkit', 'moz'];

    var r = {};
	var listeners = [], numListeners = 0, toRemove = [], numToRemove;
	var lastTime = 0;

    for(var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
        window.requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { 
            	callback(currTime + timeToCall); 
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

	var run = function(deltaTime) {
		requestAnimationFrame(run);

		if(numListeners == 0) return;
		
		for(var i = 0; i < numListeners; i++) {
			listeners[i].call(deltaTime);
		}

		if(numToRemove > 0) {
			var indexToRemove = [];
			for (var i = listeners.length - 1; i >= 0; i--) {
				for (var j = 0; j < toRemove.length; j++) {
					if (listeners[i] === toRemove[j])
						indexToRemove.push(i);
				};
			};

			for (var i = 0; i < indexToRemove.length; i++) {
				listeners.splice(indexToRemove[i], 1);
			};

			numListeners = listeners.length;
			toRemove = [];
			numToRemove = 0;
		}		
	}

	/**
	 *	@method on
	 *	@memberof FrameImpulse
	 *	@static
	 *
	 *	@param {Function} callback - the function used as callback for the listener
	 *	@description Adds a listener to be called on every frame
	 */
	r.on = function(f) {
		if(listeners.indexOf(f) > -1) { return; }
		listeners.push(f);
		numListeners = listeners.length;
		// console.log("FrameImpulse > new listener > total :", numListeners);
	}

	/**
	 *	@method off
	 *	@memberof FrameImpulse
	 *	@static
	 *
	 *	@param {Function} callback - the function used as callback for the listener. 
	 *	Needs to be the same function as passed to the <code>on()</code> when it was being registered.
	 *	@description Removes a listener to be called on every frame
	 */
	r.off = function(f) {
		if(listeners.indexOf(f) == -1) { return; }
		toRemove.push(f);
		numToRemove = toRemove.length;
		// console.log("FrameImpulse > scheduled removal > total :", numListeners);
	}

	r.getListeners = function() {
		return listeners;
	}
	
	run();
	return r;

})();


/* --- --- [HistoryRouter] --- --- */

/**
 *	@class HistoryRouter
 *
 *	@description <p>A router that handles browser/app history. 
 *	Works with either the History API or just internally within the app.</p>
 *	<p>In most cases - NOT TO BE used directly, it is used internally by {@link Application} instead.</p>
 */
var HistoryRouter = function (app, params) {

	var disableHistoryAPI = (params && params.disableHistoryAPI) || !Simplrz.history;

	var rootUrl = document.location.protocol + '//' + (document.location.hostname || document.location.host);
	if(document.location.port) rootUrl += ":" + document.location.port;
	app.navigate = new Trigger();
	app.hijackLinks = new Trigger();

	var routeHistory = [];
	app.historyBack = new Trigger();

	var hijackLinks = function (element) {

		var base = document.querySelector('base');
		base = (base && base.getAttribute('href')) ? base.getAttribute('href') : '/';

		if(base == '/') base = '';
		if(base[base.length-1] == '/') base = base.substring(0, base.length - 1);

		app.baseUrl = base;

		var allLinksSelector = 'a[href]';
		var allLinks = (element || document).querySelectorAll(allLinksSelector);
		
		allLinks = Array.prototype.slice.call(allLinks);

		for (var i = 0; i < allLinks.length; i++) {
			var link = allLinks[i];

			var url = link.getAttribute('href');
			var target = link.getAttribute('target');
			var hj = link.getAttribute('data-hj');

			if(url.indexOf(':') > -1 || target == '_blank' || hj == "no") {
				// Skip absolute URLs, those that have a _blank target 
				// and those that are explicitely set to not be hijacked
				// (this is done by adding an attribute like this: data-hj='no')

				// console.log('HistoryRouter.hijackLinks: skipping', url);
				continue;
			}
			
			if (!link.hijacked) {
				link.hijacked = true;

				link.hijackedHref = base + link.getAttribute('href');

				var cb = function (e) {
					if(e) e.preventDefault();
					pushState(this.hijackedHref);
				}

				if(Simplrz.touch) {
					Util.handleTap(link, cb);
				} else {
					link.addEventListener('click', cb);
				}
			}
		}
	};

	var notify = function(href) {
		var qs = document.location.href.indexOf('?');
		var hs = document.location.href.indexOf('#');

		var route = document.location.href;

		if(qs > -1) route = route.substring(0, qs);
		if(hs > -1) route = route.substring(0, hs);

		var r = {};

		if(!disableHistoryAPI)  {
			r.route = route.substring(rootUrl.length + 1 + app.baseUrl.length);
		} else {
			r.route = href || '';
		}

		r.parts = r.route.split('/');

		// Get rid of all trailing stuff
		while(r.parts[0] == '') r.parts.shift();
		while(r.parts[r.parts.length - 1] == '') r.parts.pop();

		r.lastPart = r.parts[r.parts.length - 1];
		r.route = r.parts.join('/');

		routeHistory.push(r);
		app.route.value = r;
	}

	var pushState = function (href) {
		if (!disableHistoryAPI) history.pushState(null, null, href);
		notify(href);
	};

	if(!disableHistoryAPI) {
		window.addEventListener('popstate', function(e) {
			notify();
		});
	}

	app.hijackLinks.on(hijackLinks);
	app.navigate.on(pushState);

	// app.historyBack.on(function() {
	// 	console.log(arguments)
	// });

	return {

		init: function () {
			hijackLinks();
			if (!disableHistoryAPI) {
				notify();
			} else {
				var home, qs = document.location.search;

				if(params || params.home) home = params.home;

				if(qs.indexOf('=') > -1) {
					var aq = qs.substring(1).split('&');
					aq.forEach(function(q) {
						if(q.indexOf('id=') > -1) {
							home = q.split('=')[1];
						}
					});
				} else if(qs) {
					home = qs.substring(1);
				}

				// console.log('home', qs, home);

				notify(home || '');
			}
		}
	}
};

/* --- --- [Loader] --- --- */

/**
 *	@namespace Loader
 *
 *	@description A very (very) simple AJAX loader.
 */
var Loader = {

	/**
	 *	@method loadText
	 *	@memberof Loader
	 *	@static
	 *
	 *	@description Loads a text file through AJAX
	 *
	 *	@param {string} path - the path to the file, absolute or relative
	 *	@param {Function} onLoadedFunc - callback for when the file is loaded. The contents of the file in string format will be passed to this callback as argument.
	 */
	loadText: function(path, onLoadedFunc){

		var request = new XMLHttpRequest();
		request.open("GET", path);

		request.onreadystatechange = function(){
			if (request.readyState == 4) {
				onLoadedFunc(request.responseText);
			}
		};

		request.send();
	},

	/**
	 *	@method loadJSON
	 *	@memberof Loader
	 *	@static
	 *
	 *	@description Loads a JSON file through AJAX
	 *
	 *	@param {string} path - the path to the file, absolute or relative
	 *	@param {Function} onLoadedFunc - callback for when the file is loaded. The contents of the file in JS object format will be passed to this callback as argument.
	 */
	loadJSON: function(path, onLoadedFunc){
		Loader.loadText(path, function(text) {
			onLoadedFunc(JSON.parse(text));
		});
	}
};

/* --- --- [VirtualScroll] --- --- */

/**
 *	@namespace VirtualScroll
 *
 *	@description World Famous VirtualScroll &copy;
 *
 *	<p><a href='http://www.everyday3d.com/blog/index.php/2014/08/18/smooth-scrolling-with-virtualscroll/'>How to use</a>.
 *
 *	@example
var onSroll = function(e) {
  // Do some scrolling action logic in here
}

// When the loop needs to be activated
VirtualScroll.on(onScroll);

// ...and when it needs to stop
VirtualScroll.off(onScroll);
 */
var VirtualScroll = (function(document) {

	var vs = {};

	var numListeners, listeners = [], initialized = false;

	var touchStartX, touchStartY;

	// [ These settings can be customized with the options() function below ]
	// Mutiply the touch action by two making the scroll a bit faster than finger movement
	var touchMult = 2;
	// Firefox on Windows needs a boost, since scrolling is very slow
	var firefoxMult = 15;
	// How many pixels to move with each key press
	var keyStep = 120;
	// General multiplier for all mousehweel including FF
	var mouseMult = 1;

	var bodyTouchAction;

	var hasWheelEvent = 'onwheel' in document;
	var hasMouseWheelEvent = 'onmousewheel' in document;
	var hasTouch = 'ontouchstart' in document;
	var hasKeyDown = 'onkeydown' in document;

	var hasTouchWin = navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1;
	var hasPointer = !!window.navigator.msPointerEnabled;

	var isFirefox = navigator.userAgent.indexOf('Firefox') > -1;

	var event = {
		y: 0,
		x: 0,
		deltaX: 0,
		deltaY: 0,
		originalEvent: null
	};

	vs.on = function(f) {
		if(!initialized) initListeners(); 

		var i = listeners.indexOf(f);
		if(i != -1) return;

		listeners.push(f);
		numListeners = listeners.length;
	}

	/**
	 *	@method options
	 *	@memberof VirtualScroll
	 *	@static
	 *
	 *	@param {Object} opt - object literal containing one or more options from the list above, specified as properties.
	 *
	 *	@description Sets custom parameters to the VirtualScroll (globally). The following options are supported:
	 *
	 *	<ul>
	 *	<li>touchMult (default: 2) - mutiply the touch action to make the scroll a faster/slower than finger movement</li>
	 *	<li>firefoxMult (defailt: 15)- Firefox on Windows needs a boost, since scrolling is very slow</li>
	 *	<li>keyStep (default: 120) - specified how many pixels to move with each key press</li>
	 *	<li>mouseMult (default: 1) - general multiplier for all mousehweel events including FF</li>
	 *	</ul>
	 */
	vs.options = function(opt) {
		keyStep = opt.keyStep || 120;
		firefoxMult = opt.firefoxMult || 15;
		touchMult = opt.touchMult || 2;
		mouseMult = opt.mouseMult || 1;
	}

	vs.off = function(f) {
		var i = listeners.indexOf(f);
		if(i == -1) return;

		listeners.splice(i, 1);
		numListeners = listeners.length;
		if(numListeners <= 0) destroyListeners();
	}

	/**
	 *	@method lockTouch
	 *	@memberof VirtualScroll
	 *	@static
	 *
	 *	@description For VirtualScroll to work on mobile, the default swipe-to-scroll behavior needs to be turned off. 
	 *	This function will take care of that, however it's a failt simple mechanism - see in the source code, linked below.
	 */
	vs.lockTouch = function() {
		document.addEventListener('touchmove', function(e) {
			e.preventDefault();
		});
	}

	var notify = function(e) {
		event.x += event.deltaX;
		event.y += event.deltaY;
		event.originalEvent = e;

		for(var i = 0; i < numListeners; i++) {
			listeners[i](event);
		}
	}

	var onWheel = function(e) {
		// In Chrome and in Firefox (at least the new one)
		event.deltaX = e.wheelDeltaX || e.deltaX * -1;
		event.deltaY = e.wheelDeltaY || e.deltaY * -1;

		// for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad 
		// real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes
		if(isFirefox && e.deltaMode == 1) {
			event.deltaX *= firefoxMult;
			event.deltaY *= firefoxMult;
		} 

		event.deltaX *= mouseMult;
		event.deltaY *= mouseMult;

		notify(e);
	}

	var onMouseWheel = function(e) {
		// In Safari, IE and in Chrome if 'wheel' isn't defined
		event.deltaX = (e.wheelDeltaX) ? e.wheelDeltaX : 0;
		event.deltaY = (e.wheelDeltaY) ? e.wheelDeltaY : e.wheelDelta;

		notify(e);	
	}

	var onTouchStart = function(e) {
		var t = (e.targetTouches) ? e.targetTouches[0] : e;
		touchStartX = t.pageX;	
		touchStartY = t.pageY;
	}

	var onTouchMove = function(e) {
		// e.preventDefault(); // < This needs to be managed externally
		var t = (e.targetTouches) ? e.targetTouches[0] : e;

		event.deltaX = (t.pageX - touchStartX) * touchMult;
		event.deltaY = (t.pageY - touchStartY) * touchMult;
		
		touchStartX = t.pageX;
		touchStartY = t.pageY;

		notify(e);
	}

	var onKeyDown = function(e) {
		// 37 left arrow, 38 up arrow, 39 right arrow, 40 down arrow
		event.deltaX = event.deltaY = 0;
		switch(e.keyCode) {
			case 37:
				event.deltaX = -keyStep;
				break;
			case 39:
				event.deltaX = keyStep;
				break;
			case 38:
				event.deltaY = keyStep;
				break;
			case 40:
				event.deltaY = -keyStep;
				break;
		}

		notify(e);
	}

	var initListeners = function() {
		if(hasWheelEvent) document.addEventListener("wheel", onWheel);
		if(hasMouseWheelEvent) document.addEventListener("mousewheel", onMouseWheel);

		if(hasTouch) {
			document.addEventListener("touchstart", onTouchStart);
			document.addEventListener("touchmove", onTouchMove);
		}
		
		if(hasPointer && hasTouchWin) {
			bodyTouchAction = document.body.style.msTouchAction;
			document.body.style.msTouchAction = "none";
			document.addEventListener("MSPointerDown", onTouchStart, true);
			document.addEventListener("MSPointerMove", onTouchMove, true);
		}

		if(hasKeyDown) document.addEventListener("keydown", onKeyDown);

		initialized = true;
	}

	var destroyListeners = function() {
		if(hasWheelEvent) document.removeEventListener("wheel", onWheel);
		if(hasMouseWheelEvent) document.removeEventListener("mousewheel", onMouseWheel);

		if(hasTouch) {
			document.removeEventListener("touchstart", onTouchStart);
			document.removeEventListener("touchmove", onTouchMove);
		}
		
		if(hasPointer && hasTouchWin) {
			document.body.style.msTouchAction = bodyTouchAction;
			document.removeEventListener("MSPointerDown", onTouchStart, true);
			document.removeEventListener("MSPointerMove", onTouchMove, true);
		}

		if(hasKeyDown) document.removeEventListener("keydown", onKeyDown);

		initialized = false;
	}

	return vs;
})(document);







/* --- --- [Gesture] --- --- */

/**
 * 	@class Gesture
 *
 *	@param {Object=} options - object holding settings (see above)
 *
 *	@description 
 *
 *	<p>A simple touch (or click/drag) gesture recognition class.</p>
 *
 *	<p>Works with touch gesture, mouse clik/drag gestures and key press (cursor keys), detects swipes in 4 directions.</p>
 *
 *	<p>For advanced scenarios <a href='http://hammerjs.github.io/'>Hammer.js</a> can be used instead.</p>
 *
 *	<p>Options include:
 *	<ul>
 *		<li>maxTime - how long before swipe is not considered a swipe (default 300ms)</li>
 *		<li>minDistance - how much must the user move to consider this a swipe (default 30px)</li>
 *		<li>tolerance - how far off vertical or horizontal axis is considered as swipe 
 *				default: 0.1, don't make it larger than 0.25 (i.e. 45deg)</li>
 *		<li>noKeyboard - if set tu true, key listeners will not be activated 
 *				(use if cursor keys are used for something else and there's a conflict)</li>
 *	</ul>
 *	</p>
 *
 *	@example
var g = new Gesture();
g.swipeUp.on(function() {
  console.log("User swiped up!");
});
 */
var Gesture = function(options) {

	options = options || {};

	var that = this;
	var cl;

	var isTouch = 'ontouchstart' in document;
	var downEvent = isTouch ? 'touchstart' : 'mousedown';
	var moveEvent = isTouch ? 'touchmove' : 'mousemove';
	var upEvent =   isTouch ? 'touchend' : 'mouseup';

	/**
	 *	@member {Trigger} swipeUp
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe up" gesture is detected
	 */	
	this.swipeUp = new Trigger();

	/**
	 *	@member {Trigger} swipeDown
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe down" gesture is detected
	 */	
	this.swipeDown = new Trigger();

	/**
	 *	@member {Trigger} swipeLeft
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe left" gesture is detected
	 */	
	this.swipeLeft = new Trigger();

	/**
	 *	@member {Trigger} swipeRight
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe right" gesture is detected
	 */	
	this.swipeRight = new Trigger();

	tolerance = options.tolerance || 0.1;

	var start = { x:0, y:0 }, 
		delta = { x: 0, y: 0 },
		startTime = 0,
		maxTime = options.maxTime || 300, minDistance = options.minDistance || 30; 
		minDistance = minDistance * minDistance; // square it for faster math

	var onStart = function(e) {
		e = isTouch ? e.targetTouches[0] : e;
		start.x = e.pageX;
		start.y = e.pageY;
		delta.x = 0;
		delta.y = 0;
		startTime = new Date().getTime();
	}

	var onMove = function(e) {
		e = isTouch ? e.targetTouches[0] : e;
		delta.x = e.pageX - start.x;
		delta.y = e.pageY - start.y;
	}

	var onStop = function(e) {
		var ds = delta.x * delta.x + delta.y * delta.y;
		var dt = new Date().getTime() - startTime;
		var t = tolerance;

		if(dt > maxTime) return;
		if(ds < minDistance) return;

		var a = Math.atan2(delta.y, delta.x) / Math.PI;
		// up = -0.5, down = 0.5, left = 1, right = 0
		if(a > -0.5 - t && a < -0.5 + t) that.swipeUp.trigger();
		if(a >  0.5 - t && a <  0.5 + t) that.swipeDown.trigger();
		if(a >  0.0 - t && a <  0.0 + t) that.swipeRight.trigger();
		if(a < -1.0 + t || a >  1.0 - t) that.swipeLeft.trigger();
	}

	var onKeyDown = function(e) {
		// 37 left arrow, 38 up arrow, 39 right arrow, 40 down arrow
		event.deltaX = event.deltaY = 0;
		switch(e.keyCode) {
			case 39:
				that.swipeLeft.trigger();
				break;
			case 37:
				that.swipeRight.trigger();
				break;
			case 40:
				that.swipeUp.trigger();
				break;
			case 38:
				that.swipeDown.trigger();
				break;
		}
	}

	/**
	 *	@method create
	 *	@memberof Gesture.prototype
	 *
	 *	@description registers all necessary listeners. 
	 *	This is done automatically in the constructor, 
	 *	so it doesn't need to be called, unless destroy()
	 *	was called before and we want to reuse the object.
	 */	
	this.create = function() {
		document.addEventListener(downEvent, onStart);
		document.addEventListener(moveEvent, onMove);
		document.addEventListener(upEvent, onStop);
		if(!options.noKeyboard) document.addEventListener("keydown", onKeyDown);
	}

	/**
	 *	@method destroy
	 *	@memberof Gesture.prototype
	 *
	 *	@description deregisters all listeners
	 */	
	this.destroy = function() {
		document.removeEventListener(downEvent, onStart);
		document.removeEventListener(moveEvent, onMove);
		document.removeEventListener(upEvent, onStop);
		if(!options.noKeyboard) document.removeEventListener("keydown", onKeyDown);
	}

	this.create();
}

/* --- --- [Util] --- --- */

/**
 *	@class Util
 */
var Util = {

	fullbleed: function(element, w, h) {
		var isVideo = element.videoWidth > 0;

		var sw = w || window.innerWidth,
			sh = h || window.innerHeight,
			vw = isVideo ? element.videoWidth : element.naturalWidth,
			vh = isVideo ? element.videoHeight : element.naturalHeight;
		// IE doesnt return correct values for width.height of images but naturalWidth/Height works just fine

		var sa = sw / sh;
		var va = vw / vh;

		var vx, vy, vcw, vch;

		// large aspect = wide screen, small aspect = tall screen
		// element aspect < screen aspect = height needs overflow
		// element apsect > screen aspect = width needs overflow

		if(va < sa) {
			vx = 0;
			vcw = sw;
			vch = vh / vw * sw;
			vy = (vch - sh) * -0.5;
		} else if(va > sa) {
			vy = 0;
			vch = sh;
			vcw = vw / vh * sh;
			vx = (vcw - sw) * -0.5;
		} else {
			vx = vy = 0, vcw = sw, vch = sh;
		}

		return [vx, vy, vcw, vch];
	},

	fullContain: function(img) {
		var isVideo = img.videoWidth > 0;

		var w = window.innerWidth;
		var h = window.innerHeight;
		var iw = isVideo ? img.videoWidth : img.width;
		var ih = isVideo ? img.videoHeight : img.height;
		var scrRatio = w / h;
		var imgRatio = iw / ih;
		var sx, sy, sw, sh;

		// contain
		if(scrRatio > imgRatio) {
			sy = 0;
			sh = h;
			sw = (h / ih) * iw;
			sx = (w - sw) * 0.5;
		} else if(scrRatio < imgRatio) {
			sx = 0;
			sw = w;
			sh = (w / iw) * ih;
			sy = (h - sh) * 0.5;
		} else {
			sx = 0, sy = 0, sw = w, sh = h;
		}

		return[sx, sy, sw , sh];
	},

	hexToRgb: function(hex) {
		var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? {
				r: parseInt(result[1], 16),
				g: parseInt(result[2], 16),
				b: parseInt(result[3], 16)
		} : null;
	},

	handleTap: function(element, callback) {

		var tapHandler = callback.___thProxy || (function() {

			var th = {};
			var minTime = 20000;
			var startTime;
			var minDistSq = 100;
			var sx, sy;
			var el = element;
			var cb = callback;

			th.click = function(e) {
				e.preventDefault();
			} 

			th.touchStart = function(e) {
				e.preventDefault();

				startTime = new Date().getTime();
				sx = e.targetTouches[0].pageX;
				sy = e.targetTouches[0].pageY;
			}

			th.touchEnd = function(e) {
				e.preventDefault();

				var t = new Date().getTime() - startTime;

				var dx = e.changedTouches[0].pageX - sx;
				var dy = e.changedTouches[0].pageY - sy;
				var dsq = (dx*dx + dy*dy);

				if(t < minTime && dsq < minDistSq) cb.call(el, e);
			}

			return th;

		})();

		element.addEventListener("touchstart", tapHandler.touchStart);
		element.addEventListener("touchend", tapHandler.touchEnd);
		element.addEventListener("click", tapHandler.click);

		return tapHandler;
	},

	clearTapHandler: function(element, tapHandler) {
		element.removeEventListener("touchstart", tapHandler.touchStart);
		element.removeEventListener("touchend", tapHandler.touchEnd);
		element.removeEventListener("click", tapHandler.click);
	},

	cssEase: {
		'ease': 'ease',
		'smoothstep': 'ease',
		'in': 'ease-in',
		'out': 'ease-out',
		'in-out': 'ease-in-out',
		'snap': 'cubic-bezier(0,1,.5,1)',
		'easeOutCubic': 'cubic-bezier(.215,.61,.355,1)',
		'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
		'easeInCirc': 'cubic-bezier(.6,.04,.98,.335)',
		'easeOutCirc': 'cubic-bezier(.075,.82,.165,1)',
		'easeInOutCirc': 'cubic-bezier(.785,.135,.15,.86)',
		'easeInExpo': 'cubic-bezier(.95,.05,.795,.035)',
		'easeOutExpo': 'cubic-bezier(.19,1,.22,1)',
		'easeInOutExpo': 'cubic-bezier(1,0,0,1)',
		'easeInQuad': 'cubic-bezier(.55,.085,.68,.53)',
		'easeOutQuad': 'cubic-bezier(.25,.46,.45,.94)',
		'easeInOutQuad': 'cubic-bezier(.455,.03,.515,.955)',
		'easeInQuart': 'cubic-bezier(.895,.03,.685,.22)',
		'easeOutQuart': 'cubic-bezier(.165,.84,.44,1)',
		'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
		'easeInQuint': 'cubic-bezier(.755,.05,.855,.06)',
		'easeOutQuint': 'cubic-bezier(.23,1,.32,1)',
		'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
		'easeInSine': 'cubic-bezier(.47,0,.745,.715)',
		'easeOutSine': 'cubic-bezier(.39,.575,.565,1)',
		'easeInOutSine': 'cubic-bezier(.445,.05,.55,.95)',
		'easeInBack': 'cubic-bezier(.6,-.28,.735,.045)',
		'easeOutBack': 'cubic-bezier(.175, .885,.32,1.275)',
		'easeInOutBack': 'cubic-bezier(.68,-.55,.265,1.55)'
	}

};







