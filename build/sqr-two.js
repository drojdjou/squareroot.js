/* --- --- [SQR.js] --- --- */

/**
 *	@namespace SQR
 *	@description The global engine namespace. Everything in SQR belongs to this namespace.
 */
var SQR = {

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 2`
	 */
	TWOPI: Math.PI * 2,

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 0.5`
	 */
	HALFPI: Math.PI * 0.5,

	/**
	 *	@property EPSILON - a very small number, used to prevent rounding errors
	 */
	EPSILON: 1.0e-6,

	/**
	 *	@property gl - Placeholder that holds current gl context. This is set in SQR.Context.create(), but can be modified manually too
	 */
	gl: null, 

	/** 
	 *	Setting this value to true will use the old matrix calculation. 
	 *	Best to keep it false, but for now it's true by default for backwards compatibility.
	 */
	flipMatrix: true,
	
	/** 
	 *	@property fullScreenQuad - placeholder that holds a fullscreen geometry for post effects. Lazily created in PostEffect.js
	 *	Typically not set manually.
	 */
	fullScreenQuad: null,

	/**
	 *	@property shaderPath - a path relative to the main HTML file where the src/glsl folder is located.
	 *	Only necessary to if builtin shader code is loaded (using ~ paths).
	 *
	 *	@default .
	 */
	shaderPath: '.',


	/**
	 *	@namespace Primitives
	 *	@memberof SQR
	 *	@description A collection of classes & functions and utilities to create geometries
	 */
	Primitives: {

		V2: function(x, y) { return new SQR.V2(x, y); },
		V3: function(x, y, z) { return new SQR.V3(x, y, z); },
		Q:  function(x, y, z, w) { return new SQR.Quaternion(x, y, z, w); },
		M4: function() { return new SQR.Matrix44(); },

		F: 	function(options) { 

			var f = function(a, b, c, d) {
				var fc = SQR.Face().v(a, b, c, d);
				f.faces.push(fc);
				return fc; 
			};

			f.faces = [];

			f.toBuffer = function(geo) {
				var c = 0;
				f.faces.forEach(function(fc) {
					if(options && options.reverseNormals) fc.flip();
					fc.calculateNormal();
					c += fc.toBuffer(geo, c, options && options.perVertexNormal);
				});
				return c;
			}

			return f;
		}
	},

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2 }
	 */
	v2: function() { return { aPosition: 2 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2 }
	 */
	v3: function() { return { aPosition: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2, aUV: 2 }
	 */
	v2u2: function() { return { aPosition: 2, aUV: 2 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2, aColor: 3 }
	 */
	v2c3: function() { return { aPosition: 2, aColor: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 3, aNormal: 3 }
	 */
	v3n3: function() { return { aPosition: 3, aNormal: 3 }; },

	/**
	 *	@method v3n3u2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 3, aNormal: 3, aUV: 2 }
	 */
	v3n3u2: function() { return { aPosition: 3, aNormal: 3, aUV: 2 }; },

    // Error reporting 

    // Issues a console.warn() is user attempts to set a uniform that does not exist on the shader
    WARN_UNIFORM_NOT_PRESENT : false 

};

/* --- --- [Version.js] --- --- */

/**
 *	@property Version - autogenerated with build script, holds current verison info
 */
// DO NOT EDIT. Updated from version.json
SQR.Version = {"version":"3.0","build":230,"date":"Mar 15th 2018"};

/* --- --- [math/Bezier.js] --- --- */

/**
 *  @class Bezier
 *  @memberof SQR
 *
 *  @description Represents a cubic bezier curve. All paramaters can be either {@link SQR.V3} or {@link SQR.V2}.
 *
 *  @param _p0 start position
 *  @param _c0 first control point
 *  @param _c1 last control point
 *  @param _c1 end position
 *
 */
SQR.Bezier = function(_p0, _c0, _c1, _p1) {

    var that = this;

    /**
     *  @var p0 
     *  @memberof SQR.Bezier.prototype
     *  @descripton The start position, can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.p0 = _p0;

    /**
     *  @var c0 
     *  @memberof SQR.Bezier.prototype
     *  @descripton First control point. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.c0 = _c0;

    /**
     *  @var c1 
     *  @memberof SQR.Bezier.prototype
     *  @descripton Second control point. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.c1 = _c1;

    /**
     *  @var p1 
     *  @memberof SQR.Bezier.prototype
     *  @descripton End position. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.p1 = _p1;

    var interpolatedValue, interpolatedVelocity, interpolatedMatrix;

    var pfunc = SQR.Interpolation.bezierPosition;
    var vfunc = SQR.Interpolation.bezierVelocity;

    /**
     *  @method velocityAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the velocity on a curve. 
     *  @param t interpolation value [0-1]
     *  @param v vector to write the value to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.velocityAt = function(t, v) {
        interpolatedVelocity = interpolatedVelocity || this.p0.clone().set();
        v = v || interpolatedVelocity;
        v.x = vfunc(t, this.p0.x, this.c0.x, this.c1.x, this.p1.x);
        v.y = vfunc(t, this.p0.y, this.c0.y, this.c1.y, this.p1.y);

        if(v.z !== null && this.p0.z !== null) {
            v.z = vfunc(t, this.p0.z, this.c0.z, this.c1.z, this.p1.z);
        }

        return v;
    }

    /**
     *  @method valueAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the position on a curve.
     *  @param t interpolation value [0-1]
     *  @param v vector to write the value to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.valueAt = function(t, v) {
        interpolatedValue = interpolatedValue || this.p0.clone().set();
        v = v || interpolatedValue;
        v.x = pfunc(t, this.p0.x, this.c0.x, this.c1.x, this.p1.x);
        v.y = pfunc(t, this.p0.y, this.c0.y, this.c1.y, this.p1.y);

        if(v.z !== null && this.p0.z !== null) {
            v.z = pfunc(t, this.p0.z, this.c0.z, this.c1.z, this.p1.z);
        }
        
        return v;
    }

    /** 
     *  @method matrixAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the transformation matrix that can be used to align an object to the curve at a given point.
     *  Not tested in 2D but shoud work fine.
     *  @param t interpolation value [0-1]
     *  @param m {@link SQR.Matrix44} to write the matrix to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.matrixAt = function(t, m) {
        interpolatedMatrix = interpolatedMatrix || new SQR.Matrix44();
        m = m || interpolatedMatrix;
        m.identity();

        var va = that.valueAt(t);
        var vc = that.velocityAt(t).norm();
        var vl = SQR.V3.__tv1.set().cross(vc, SQR.V3.up);//.norm();
        var vn = SQR.V3.__tv2.set().cross(vc, vl);//.norm()

        m.data[0] = vl.x, m.data[4] = vn.x, m.data[8] = vc.x;
        m.data[1] = vl.y, m.data[5] = vn.y, m.data[9] = vc.y;
        m.data[2] = vl.z, m.data[6] = vn.z, m.data[10] = vc.z;
        m.setTranslation(va.x, va.y, va.z);

        return m;
    }
}













/* --- --- [math/Color.js] --- --- */

/**
 *  @class Color
 *  @memberof SQR
 *
 *  @descrption represents an RGB color. This class works with float values, 
 *	so all the color components are in range of 0-1, not 0-255.
 *
 *	@param {Number=} r the red component of the color
 *	@param {Number=} g the green component of the color
 *	@param {Number=} b the blue component of the color
 *	@param {Number=} a the transparency (alpha) component of the color
 *
 */
SQR.Color = function(r, g, b, a) {
	if(!(this instanceof SQR.Color)) return new SQR.Color(r, g, b, a);
	
	if(typeof(r) == 'string') {
		this.setHex(r);
		this.a = (g == undefined) ? 1 : g; // if r is a hex color code, the next argument will be alpha
	} else if(r && r.r != undefined) {
		this.setRGB(r.r, r.g, r.b);

		if(r.a != undefined) this.a = r.a;
		else if(g != undefined) this.a = g;
		else this.a = 1; 

	} else {
		this.setRGB(r, g, b);
		this.a = (a == undefined) ? 1 : a;
	}
}

/**
 *	@method setRGB
 *	@memberof SQR.Color.prototype
 *
 *	@description sets the color component values.
 *
 *	@param {Number=} r the red component of the color
 *	@param {Number=} g the green component of the color
 *	@param {Number=} b the blue component of the color
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.setRGB = function(r, g, b, a) {
	var c = this;
	c.r = r || 0;
	c.g = g || 0;
	c.b = b || 0;
	c.a = a != null ? a : 1;
	return c;
}

/**
 *	@method setHex
 *	@memberof SQR.Color.prototype
 *
 *	@description sets the color component values from a hex string (ex. #a4d278) or number (ex. 0xa4d278) 
 *	Useful when copying color vaues from ex. Photoshop.
 *
 *	@param {string|Number} hex the hex color values as string (ex. #a4d278) or number (ex. 0xa4d278) 
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.setHex = function(hex) {

	var c = this;

	if(typeof(hex) == 'string') {
		hex = (hex.indexOf('#') == 0) ? hex.substring(1) : hex;
		hex = (hex.indexOf('0x') == -1) ? '0x' + hex : hex;
		hex = parseInt(hex);
	}

	c.r = (hex >> 16 & 255 ) / 255;
	c.g = (hex >> 8 & 255) / 255;
	c.b = (hex & 255) / 255;
	c.a = 1;

	return c;
}

SQR.Color.prototype.setCSS = function(css) {

	var c = this;

	if(css.indexOf("#") > -1) {
		this.setHex(css);
	} else {
		var v = css.match(/\(([^\)]+)\)/);
		v = v[1].split(",");
		
		c.r = parseInt(v[0]) / 255;
		c.g = parseInt(v[1]) / 255;
		c.b = parseInt(v[2]) / 255;

		var a = css.indexOf("a") > -1;
		if(a) c.a = parseFloat(v[3]);
		else c.a = 1;
	}

	return c;
}

/**
 *	@method toCSS
 *	@memberof SQR.Color.prototype
 *
 *	@returns {string} a CSS friendly string representing the color. The format used is <code>rgb(r, g, b)</code>.
 */
SQR.Color.prototype.toCSS = function() {
	var c = this;
	var ri = (c.r * 255) | 0;
	var gi = (c.g * 255) | 0;
	var bi = (c.b * 255) | 0;
	var ai = (c.a < 1) ? ', ' + c.a.toPrecision(2) : '';
	var h =  (c.a < 1) ? 'rgba' : 'rgb';
	return h + '(' + ri + ', ' + gi + ', ' + bi + '' + ai + ')';
}

SQR.Color.prototype.toHex = function() {

	var c = this;

	var c2h = function(c) {
		var hex = Math.round(c * 255).toString(16);
		return hex.length == 1 ? "0" + hex : hex;
	}

	return "#" + c2h(c.r) + c2h(c.g) + c2h(c.b);
}

/**
 *	@method setRGB
 *	@memberof SQR.Color.prototype
 *
 *	@description copies the color component values from another instance of SQR.Color
 *
 *	@param {SQR.Color} oc the color instance to copy from
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.copyFrom = function(oc) {
	var c = this;
	c.r = oc.r;
	c.g = oc.g;
	c.b = oc.b;
	return c;
}

/**
 *	@method lighten
 *	@memberof SQR.Color.prototype
 *
 *	@description <p>modfies the color values to make them darker of lighter in a more fance way than a simple multiplication. 
 *	However this is not currently implemented so for now it really does the same thing as <code>SQR.Color.mul</code>.</p>
 *
 *	<p>Here's <a href='http://stackoverflow.com/questions/141855/programmatically-lighten-a-color'>some info on how to implement this properly</a>.</p>
 */
SQR.Color.prototype.lighten = function(v) {
	return this.mul(v);
}

/**
 *	@method clone
 *	@memberof SQR.Color.prototype
 *
 *	@description creates a copy of the color instance
 *
 *	@returns {Object} a new SQR.Color instance
 */
SQR.Color.prototype.clone = function() {
	return new SQR.Color(c.r, c.g, c.b);
}

/**
 *	@method mul
 *	@memberof SQR.Color.prototype
 *
 *	@description modfies the color values to make it darker of lighter
 *
 *	@param {Number} v the amount by which to change the color (1 will leave it as it, > 1 will lightned, < 1 will darken the color)
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.mul = function(v) {
	var c = this;
	c.r = Math.min(1.0, c.r * v);
	c.g = Math.min(1.0, c.g * v);
	c.b = Math.min(1.0, c.b * v);
	return c;
}

/**
 *	@method lerp
 *	@memberof SQR.Color.prototype
 *
 *	@description performs a linear interpolation between two colors and stores the value in the color instance
 *
 *	@param {SQR.Color} a the first color to use in interpolation
 *	@param {SQR.Color} b the second color to use in interpolation
 *	@param {Number} t the interpolation value [0-1]
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.lerp  = function(a, b, t) {
	var c = this;
	var m = 1 - t;
	c.r = a.r * m + b.r * t;
	c.g = a.g * m + b.g * t;
	c.b = a.b * m + b.b * t;
	return c;
}

SQR.Color.prototype.toUniform = function(type) {

	var alpha = type == SQR.gl.FLOAT_VEC4;

	var c = this;
	if(!c._array) c._array = new Float32Array(alpha ? 4 : 3);
	c._array[0] = c.r;
	c._array[1] = c.g;
	c._array[2] = c.b; 
	if(alpha) c._array[3] = c.a;
	return c._array;
}








/* --- --- [math/Delaunay.js] --- --- */

/**
 *  
 *	@class Delaunay
 *  @memberof SQR
 *
 *  @description based on:<br> 
 *  
 *  {@link http://paulbourke.net/papers/triangulate/}<br>
 *  {@link http://www.travellermap.com/tmp/delaunay.htm} (original code)<br> 
 *  {@link https://github.com/ironwallaby/delaunay/blob/master/delaunay.js}<br> 
 *  {@link http://www.amazon.com/Computational-Geometry-Applications-Mark-Berg/dp/3642096816}
*/
SQR.Delaunay = (function() {

	var delaunay = {};

	var Edge = function(v0, v1) {
		this.v0 = v0;
		this.v1 = v1;
	}

	Edge.prototype.equals = function(other) {
		return (this.v0 === other.v0 && this.v1 === other.v1);
	};

	Edge.prototype.inverse = function() {
		return new Edge(this.v1, this.v0);
	};

	var createSuperTriangle = function(vertices) {
		// NOTE: There's a bit of a heuristic here. If the bounding triangle 
		// is too large and you see overflow/underflow errors. If it is too small 
		// you end up with a non-convex hull.

		var minx, miny, maxx, maxy;
		vertices.forEach(function(vertex) {
			if (minx === undefined || vertex.x < minx) { minx = vertex.x; }
			if (miny === undefined || vertex.y < miny) { miny = vertex.y; }
			if (maxx === undefined || vertex.x > maxx) { maxx = vertex.x; }
			if (maxy === undefined || vertex.y > maxy) { maxy = vertex.y; }
		});

		var dx = (maxx - minx) * 10;
		var dy = (maxy - miny) * 10;

		var stv0 = vertices[0].clone().set(minx - dx, miny - dy * 3);
		var stv1 = vertices[0].clone().set(minx - dx, maxy + dy);
		var stv2 = vertices[0].clone().set(maxx + dx * 3, maxy + dy);

		return new SQR.Triangle(stv0, stv1, stv2);
	}

	function addVertex(vertex, triangles) {
		var edges = [];

		triangles = triangles.filter(function(triangle) {
			if (triangle.vertexInCircumcircle(vertex)) {
				edges.push(new Edge(triangle.v0, triangle.v1));
				edges.push(new Edge(triangle.v1, triangle.v2));
				edges.push(new Edge(triangle.v2, triangle.v0));
				return false;
			}

			return true;
		});

		edges = uniqueEdges(edges);

		edges.forEach(function(edge) {
			triangles.push(new SQR.Triangle(edge.v0, edge.v1, vertex));
		});

		return triangles;
	}

	var uniqueEdges = function(edges) {
		var uniqueEdges = [];

		for (var i = 0; i < edges.length; ++i) {
			var edge1 = edges[i];
			var unique = true;

			for (var j = 0; j < edges.length; ++j) {
				if (i === j) continue;
				var edge2 = edges[j];
				if (edge1.equals(edge2) || edge1.inverse().equals(edge2)) {
					unique = false;
					break;
				}
			}

			if (unique) uniqueEdges.push(edge1);
		}

		return uniqueEdges;
	}

	/**
	 *	@method triangulate
	 *	@memberof SQR.Delaunay
	 *
	 *	@description Performs Delaunay triangulation.
	 *
	 *	@param vertices - a list of 2d vertices. 
	 *	Can be {@link SQR.V2}, {@link SQR.V3} or any object that has `x` and `y` properties. 
	 *	In case of a 3d vector, the `z` component is ignored.
	 *	@returns a list of {@link SQR.Triangles}
	 */
	delaunay.triangulate = function(vertices) {
		var triangles = [];

		var st = createSuperTriangle(vertices);

		triangles.push(st);

		vertices.forEach(function(vertex) {
			// NOTE: This is O(n^2) - can be optimized by sorting vertices
			// along the x-axis and only considering triangles that have 
			// potentially overlapping circumcircles
			triangles = addVertex(vertex, triangles);
		});

		// Remove triangles that shared edges with "supertriangle"
		triangles = triangles.filter(function(triangle) {
			return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
			triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
			triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
		});

		return triangles;
	}

	return delaunay;

})();

/* --- --- [math/Interpolation.js] --- --- */

/**
 *  @namespace Interpolation
 *  @memberof SQR
 *
 *  @description A collection of interpolation functions.
 */
SQR.Interpolation = {

    /**
     *  Returns the position on a curve for a position (per axis)
     *  @param {Number} t interpolation value [0-1]
     *  @param {Number} p0 start position
     *  @param {Number} c0 first control point
     *  @param {Number} c1 second control point
     *  @param {Number} p1 end position
     */
    bezierPosition: function(t, p0, c0, c1, p1) {
        return p0 * (1 - t) * (1 - t) * (1 - t) +
            c0 * 3 * t * (1 - t) * (1 - t) +
            c1 * 3 * t * t * (1 - t) +
            p1 * t * t * t;
    },

    /**
     *  Returns the velocity on the curve for a position (per axis)
     *  @param {Number} t interpolation value [0-1]
     *  @param {Number} p0 start position
     *  @param {Number} c0 first control point
     *  @param {Number} c1 second control point
     *  @param {Number} p1 end position
     */
    bezierVelocity: function(t, p0, c0, c1, p1) {
        return (3 * c0 - 3 * p0)
            + 2 * (3 * p0 - 6 * c0 + 3 * c1) * t
            + 3 * (-p0 + 3 * c0 - 3 * c1 + p1) * t * t;
    },

    /**
     *  Linear interpolation a between two values
     *  @param {Number} e0 start value
     *  @param {Number} e1 end value
     *  @param {Number} t interpolation value [0-1]
     */
    linear: function(e0, e1, t) {
        if(t <= e0) return e0;
        if(t >= e1) return e1;

        t = (t - e0) / (e1 - e0);

        return e0 + (e1 - e0) * t;
    },
    
    /**
     *  Smoothstep interpolation a between two values
     *  @param {Number} t interpolation value [0-1]
     */
    smoothStep: function(t) {
        return (3 * t * t - 2 * t * t * t);
    },

    /**
     *  Quadratic ease in based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadIn: function (t) {
        return t * t;
    },

    /**
     *  Quadratic ease out based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadOut: function (t) {
        return t * (2 - t);
    },

    /**
     *  Quadratic ease in-out based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadInOut: function (t) {
        if (( t *= 2 ) < 1)
            return 0.5 * t * t;
        else
            return -0.5 * ( --t * ( t - 2 ) - 1 );
    }

};

/* --- --- [math/Intersection.js] --- --- */

/**
 * @namespace Intersection
 * @memberof SQR
 * 
 * @description Utility to perform intersection tests of rays against colliders. It is a static singleton, no need to instantiate. Just use: SQR.Intersection.rayTest(...)
 */
SQR.Intersection = {};

/**
 * Performs an intersection test of a ray against a transform that has a collider. J3D supports three types of colliders: sphere, box and mesh. This method will check what type of collider the transform has and call the apropriate method to make the intersection tests.
 *
 * WARNING. For meshes that have lots of polys, the ray/mesh intersection test can be very slow! It's better to wrap it into a box or sphere collider or have a simpler version of the mesh to make intersection tests against.
 *
 * @param {SQR.Ray} r an instance of J3D.Ray
 * @param {SQR.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a collider the method returns false.
 */
SQR.Intersection.rayTest = function(r, t) {

	if (!t.collider) {
		console.log("Intersection test failed. " + t.name + " has no collider.");
		return false;
	}

	if (!SQR.Intersection.__tv1) {
		SQR.Intersection.__tv1 = new SQR.V3();
		SQR.Intersection.__tv2 = new SQR.V3();
		SQR.Intersection.__tv3 = new SQR.V3();
		SQR.Intersection.__tv4 = new SQR.V3();
		SQR.Intersection.__tv5 = new SQR.V3();
		SQR.Intersection.__tv6 = new SQR.V3();
		SQR.Intersection.__tv7 = new SQR.V3();
	}

	switch (t.collider.type) {
		case SQR.Collider.SPHERE:
			return SQR.Intersection.raySphere(r, t);
		case SQR.Collider.BOX:
			return SQR.Intersection.rayBox(r, t);
		case SQR.Collider.MESH:
			return SQR.Intersection.rayMesh(r, t);
		default:
			console.log(t.collider);
			throw "> SQR.Intersection > unknown collider type on " + t.name;
			return false;
	}
}

/**
 * Performs an intersection test of a ray against a transform that has a mesh collider.
 *
 * WARNING. For meshes that have lots of polys, the ray/mesh intersection test can be very slow! It's better to wrap it into a box or sphere collider or have a simpler version of the mesh to make intersection tests against.
 *
 * @param {J3D.Ray} r an instance of J3D.Ray
 * @param {J3D.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a geometry the method returns false.
 */
SQR.Intersection.rayMesh = function(r, t) {

	if (t.collider.box) {
		if (!SQR.Intersection.rayBox(r, t)) {
			return false;
		}
	} else {
		r.makeLocal(t);
	}

	var v = t.buffer.getDataArray();
	var d = t.buffer.getIndexArray();
	var op = t.buffer.attributes['aPosition'].offset;

	var c = false;

	var p0 = SQR.Intersection.__tv1;
	var p1 = SQR.Intersection.__tv2;
	var p2 = SQR.Intersection.__tv3;
	

	for (var i = 0; i < d.length; i += 3) {
		var i0 = d[i + 0] * t.buffer.strideSize + op;
		var i1 = d[i + 1] * t.buffer.strideSize + op;
		var i2 = d[i + 2] * t.buffer.strideSize + op;

		p0.set(v[ i0 ], v[ i0 + 1 ], v[ i0 + 2 ]);
		p1.set(v[ i1 ], v[ i1 + 1 ], v[ i1 + 2 ]);
		p2.set(v[ i2 ], v[ i2 + 1 ], v[ i2 + 2 ]);

		c = c || SQR.Intersection.rayTriangle(r, p0, p1, p2);
		if (c) break;
	}

	return c;
}

/**
 * Performs an intersection test of a ray against a single triangle.
 * You should not have to call this method directly, unless you have specific needs, like ex. doing intersection tests for particles.
 */
SQR.Intersection.rayTriangle = function(r, p0, p1, p2, n) {

	var p = SQR.Intersection.__tv4;
	var n = SQR.Intersection.__tv5;

	var t1 = SQR.Intersection.__tv6;
	var t2 = SQR.Intersection.__tv7;

	t1.sub(p0, p1);
	t2.sub(p2, p0);

	n.cross(t1, t2).norm();

	var dot = SQR.V3.dot(n, r.localDirection);
	if (!( dot < 0 )) {
		return false;
	}

	var d = SQR.V3.dot(n, p0);
	var t = d - SQR.V3.dot(n, r.localOrigin);

	if (!( t <= 0 )) {
		return false;
	}

	t = t / dot;

	p.copyFrom(r.localDirection);
	p = p.norm().mul(t);
	p.add(r.localOrigin);

	var u0, u1, u2, v0, v1, v2;

	if (Math.abs(n.x) > Math.abs(n.y)) {

		if (Math.abs(n.x) > Math.abs(n.z)) {

			u0 = p.y - p0.y;
			u1 = p1.y - p0.y;
			u2 = p2.y - p0.y;

			v0 = p.z - p0.z;
			v1 = p1.z - p0.z;
			v2 = p2.z - p0.z;

		} else {

			u0 = p.x - p0.x;
			u1 = p1.x - p0.x;
			u2 = p2.x - p0.x;

			v0 = p.y - p0.y;
			v1 = p1.y - p0.y;
			v2 = p2.y - p0.y;

		}

	} else {

		if (Math.abs(n.y) > Math.abs(n.z)) {

			u0 = p.x - p0.x;
			u1 = p1.x - p0.x;
			u2 = p2.x - p0.x;

			v0 = p.z - p0.z;
			v1 = p1.z - p0.z;
			v2 = p2.z - p0.z;

		} else {

			u0 = p.x - p0.x;
			u1 = p1.x - p0.x;
			u2 = p2.x - p0.x;

			v0 = p.y - p0.y;
			v1 = p1.y - p0.y;
			v2 = p2.y - p0.y;

		}

	}

	var temp = u1 * v2 - v1 * u2;
	if (!(temp != 0)) {
		return false;
	}

	temp = 1 / temp;

	var alpha = ( u0 * v2 - v0 * u2 ) * temp;
	if (!(alpha >= 0)) {

		return false;
	}

	var beta = ( u1 * v0 - v1 * u0 ) * temp;
	if (!(beta >= 0)) {
		return false;
	}

	var gamma = 1 - alpha - beta;
	if (!(gamma >= 0)) {
		return false;
	}

	return t;

}

/**
 * Performs an intersection test of a ray against a transform that has a sphere collider.
 *
 * @param {J3D.Ray} r an instance of J3D.Ray
 * @param {J3D.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a sphere collider the method returns false.
 */
SQR.Intersection.raySphere = function(r, t) {

	var e = SQR.Intersection.__tv1;
	var radius = t.collider.radius;
	var radiusSq = radius * radius;

	r.makeLocal(t);

	e.sub(t.collider.center, r.localOrigin);
	if (e.lengthSq < radiusSq) return false;

	var a = SQR.V3.dot(e, r.localDirection);
	if (a <= 0) return false;

	var t = radiusSq - ( e.magsq() - a * a );
	if (t >= 0) return Math.abs(a) - Math.sqrt(t);

	return false;

};

/**
 * Performs an intersection test of a ray against a transform that has a box collider.
 *
 * @param {J3D.Ray} r an instance of J3D.Ray
 * @param {J3D.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a box collider the method returns false.
 */
SQR.Intersection.rayBox = function(r, t) {
	
	var b = t.collider.box;

	r.makeLocal(t);

	var xt = 0, yt = 0, zt = 0;
	var xn = 0, yn = 0, zn = 0;
	var ins = true;

	if (r.localOrigin.x < b.minX) {

		xt = b.minX - r.localOrigin.x;
		//if(xt > r.localDirection.x) return return Number.MAX_VALUE;
		xt /= r.localDirection.x;
		ins = false;
		xn = -1;

	} else if (r.localOrigin.x > b.maxX) {

		xt = b.maxX - r.localOrigin.x;
		//if(xt < r.localDirection.x) return return Number.MAX_VALUE;
		xt /= r.localDirection.x;
		ins = false;
		xn = 1;

	}

	if (r.localOrigin.y < b.minY) {

		yt = b.minY - r.localOrigin.y;
		//if(yt > r.localDirection.y) return return Number.MAX_VALUE;
		yt /= r.localDirection.y;
		ins = false;
		yn = -1;

	} else if (r.localOrigin.y > b.maxY) {

		yt = b.maxY - r.localOrigin.y;
		//if(yt < r.localDirection.y) return return Number.MAX_VALUE;
		yt /= r.localDirection.y;
		ins = false;
		yn = 1;

	}

	if (r.localOrigin.z < b.minZ) {

		zt = b.minZ - r.localOrigin.z;
		//if(zt > r.direction.z) return return Number.MAX_VALUE;
		zt /= r.localDirection.z;
		ins = false;
		zn = -1;

	} else if (r.localOrigin.z > b.maxZ) {

		zt = b.maxZ - r.localOrigin.z;
		//if(zt < r.direction.z) return return Number.MAX_VALUE;
		zt /= r.localDirection.z;
		ins = false;
		zn = 1;

	}

	if (ins) return -1;

	var which = 0;
	var td = xt;

	if (yt > td) {

		which = 1;
		td = yt;

	}

	if (zt > td) {

		which = 2;
		td = zt;

	}

	switch (which) {

		case 0:

			var y = r.localOrigin.y + r.localDirection.y * td;
			if (y < b.minY || y > b.maxY) return false;
			var z = r.localOrigin.z + r.localDirection.z * td;
			if (z < b.minZ || z > b.maxZ) return false;
			//ab.normal = v3(xn, 0, 0);
			break;

		case 1:

			var x = r.localOrigin.x + r.localDirection.x * td;
			if (x < b.minX || x > b.maxX) return false;
			var z = r.localOrigin.z + r.localDirection.z * td;
			if (z < b.minZ || z > b.maxZ) return false;
			//ab.normal = v3(0, yn, 0);
			break;

		case 2:

			var x = r.localOrigin.x + r.localDirection.x * td;
			if (x < b.minX || x > b.maxX) return false;
			var y = r.localOrigin.y + r.localDirection.y * td;
			if (y < b.minY || y > b.maxY) return false;
			//ab.normal = new v3(0, 0, zn);
			break;

	}

	return td;
}

/* --- --- [math/Math.js] --- --- */

Math.clamp = function(v, s, e) {
	if(v <= s) return s;
	if(v >= e) return e;
	return v;
}

Math.clamp01 = function(v) {
	if(v <= 0) return 0;
	if(v >= 1) return 1;
	return v;
}

Math.absMin = function(a, b) {
	if(a <= -b || a >= b) return a;
	else if(a >= 0) return b;
	else return -b;
}

Math.map = function(v, s, e) {
	if(v <= s) return 0;
	if(v >= e) return 1;
	return (v - s) / (e - s);
}

/* --- --- [math/Matrix2D.js] --- --- */

/**
 *  @class Matrix2D
 *  @memberof SQR
 *
 *  @description A matrix that implements 2D affine transformations. 
 *  Most of the method return the current instance for chaining.
 *
 *  @todo Make it column major
 */
SQR.Matrix2D = function() {

    this.data = new Float32Array(9);

    var a, b, d, x, y;

    /**
     *  @method identity
     *  @memberof SQR.Matrix2D.prototype
     *  @description Resets the matrix to identity values.
     */
    this.identity = function(d) {
        d = d || this.data;
        d[0] = 1,d[3] = 0,d[6] = 0;
        d[1] = 0,d[4] = 1,d[7] = 0;
        d[2] = 0,d[5] = 0,d[8] = 1;

        return this;
    }

    /**
     *  @method transformVector
     *  @memberof SQR.Matrix2D.prototype
     *  @description Multiplies the vector by the matrix
     *  @param v vector to multiply
     *  @returns the same vector as passed in the parameter, multiplied by this matrix
     */
    this.transformVector = function(v) {
        d = this.data;
        x = v.x,y = v.y;
        v.x = d[0] * x + d[1] * y + d[2];
        v.y = d[3] * x + d[4] * y + d[5];
        return v;
    }

    /**
     *  @method setTranslation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the translation values.
     *  @param tx x translation
     *  @param ty y translation
     *  @param m the matrix to set translation to, applies to this if ommited
     */
    this.setTranslation = function(tx, ty, m) {
        d = m || this.data;
        d[0] = 1,d[3] = 0,d[6] = tx;
        d[1] = 0,d[4] = 1,d[7] = ty;
        d[2] = 0,d[5] = 0,d[8] = 1;
        return this;
    }

    /**
     *  @method getTranslation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Returns the translation value as 2d vector.
     *  @param {SQR.V2} v vector to use to return values in, if ommited a new vector object is returned
     *  @returns {SQR.V2} 2d vector with translation values
     */
    this.getTranslation = function(v) {
        d = this.data;
        v = v || new SQR.V2();
        v.x = d[2];
        v.y = d[5];
        return v;
    }

    /**
     *  @method setScale
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the scale values.
     *  @param sx x scale
     *  @param sy y scale
     *  @param m the matrix to set scale to, applies to `this` if ommited
     */
    this.setScale = function(sx, sy, m) {
        d = m || this.data;
        d[0] = sx,d[3] = 0, d[6] = 0;
        d[1] = 0, d[4] = sy,d[7] = 0;
        d[2] = 0, d[5] = 0, d[8] = 1;
        return this;
    }

    /**
     *  @method setShear
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the scale values.
     *  @param sx x shear
     *  @param sy y shear
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setShear = function(sx, sy, m) {
        d = m || this.data;
        d[0] = 1, d[3] = sx,d[6] = 0;
        d[1] = sy,d[4] = 1, d[7] = 0;
        d[2] = 0, d[5] = 0, d[8] = 1;
        return this;
    }

    /**
     *  @method setRotation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the rotation value.
     *  @param a angle in radians
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setRotation = function(a, m) {
        d = m || this.data;
        var r0 = Math.cos(a);
        var r1 = Math.sin(a);
        d[0] = r0,d[3] = -r1,d[6] = 0;
        d[1] = r1,d[4] = r0, d[7] = 0;
        d[2] = 0, d[5] = 0,  d[8] = 1;
        return this;
    }

    /**
     *  @method setTRS
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the translation/rotation/scale values at once.
     *  @param tx x translation
     *  @param ty y translation
     *  @param a angle in radians
     *  @param sx x scale
     *  @param sy y scale
     */
    this.setTRS = function(tx, ty, a, sx, sy) {
        d = this.data;
        var r0 = Math.cos(a);
        var r1 = Math.sin(a);
        d[0] = r0 * sx,d[3] = -r1 * sy,d[6] = tx;
        d[1] = r1 * sx,d[4] = r0 * sy, d[7] = ty;
        d[2] = 0,      d[5] = 0,       d[8] = 1;
        return this;
    }

    /** 
     *  @method translate
     *  @memberof SQR.Matrix2D.prototype
     *  @description Applies translation to matrix
     *  @param tx x translation
     *  @param ty y translation
     */
    this.translate = function(tx, ty) {
        this.identity(SQR.Matrix2D.__temp);
        this.setTranslation(tx, ty, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method rotate
     *  @memberof SQR.Matrix2D.prototype
     *  @param a angle in radians
     *  @description Applies rotation to matrix
     */
    this.rotate = function(a) {
        this.identity(SQR.Matrix2D.__temp);
        this.setRotation(a, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method scale
     *  @memberof SQR.Matrix2D.prototype
     *  @param sx x scale
     *  @param sy y scale
     *  @description Applies scale to matrix
     */
    this.scale = function(sx, sy) {
        this.identity(SQR.Matrix2D.__temp);
        this.setScale(sx, sy, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method shear
     *  @memberof SQR.Matrix2D.prototype
     *  @param sx x shear
     *  @param sy y shear
     *  @description Applies shear to matrix
     */
    this.shear = function(sx, sy) {
        this.identity(SQR.Matrix2D.__temp);
        this.setRotation(sx, sy, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    var a11, a12, a13, a21, a22, a23, a31, a32, a33;
    var b11, b12, b13, b21, b22, b23, b31, b32, b33;

    /** 
     *  @method multiply
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to multiply the current matrix by
     *  @description Multiples current matrix by m and stores result in current matrix.
     */
    this.multiply = function(m) {
        a = this.data, b = m.data || m;

        a11 = a[0],a12 = a[3],a13 = a[6];
        a21 = a[1],a22 = a[4],a23 = a[7];
        a31 = a[2],a32 = a[5],a33 = a[8];

        b11 = b[0],b12 = b[3],b13 = b[6];
        b21 = b[1],b22 = b[4],b23 = b[7];
        b31 = b[2],b32 = b[5],b33 = b[8];

        a[0] = a11 * b11 + a12 * b21 + a13 * b31;
        a[3] = a11 * b12 + a12 * b22 + a13 * b32;
        a[6] = a11 * b13 + a12 * b23 + a13 * b33;

        a[1] = a21 * b11 + a22 * b21 + a23 * b31;
        a[4] = a21 * b12 + a22 * b22 + a23 * b32;
        a[7] = a21 * b13 + a22 * b23 + a23 * b33;

        //a[6] = a31 * b11 + a32 * b21 + a33 * b31;
        //a[7] = a31 * b12 + a32 * b22 + a33 * b32;
        //a[8] = a31 * b13 + a32 * b23 + a33 * b33;

        return this;
    }

    /** 
     *  @method copyTo
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to copy values to. Can be {SQR.Matrix2D} or {Float32Array}
     *  @description Copies current matrix values to m
     */
    this.copyTo = function(m) {
        a = this.data,b = m.data || m;

        b[0] = a[0],b[1] = a[1],b[2] = a[2];
        b[3] = a[3],b[4] = a[4],b[5] = a[5];
        b[6] = a[6],b[7] = a[7],b[8] = a[8];

        return m;
    }

    /** 
     *  @method copyFrom
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to copy values from. Can be {SQR.Matrix2D} or {Float32Array}
     *  @description Copies values from m into the current matrix
     */
    this.copyFrom = function(m) {
        a = m.data || m,b = this.data;

        b[0] = a[0],b[1] = a[1],b[2] = a[2];
        b[3] = a[3],b[4] = a[4],b[5] = a[5];
        b[6] = a[6],b[7] = a[7],b[8] = a[8];

        return this;
    }

    this.identity();
}

SQR.Matrix2D.__temp = new Float32Array(9);
















/* --- --- [math/Matrix33.js] --- --- */

/**
 *  @class Matrix33
 *  @memberof SQR
 *
 *  @description A 3x3 matrix for used to hold rotations and normal matrices
 */
SQR.Matrix33 = function() {

    this.data = new Float32Array(9);

    this.identity = function() {
        var d = this.data;
        d[0] = 1,d[3] = 0,d[6] = 0;
        d[1] = 0,d[4] = 1,d[7] = 0;
        d[2] = 0,d[5] = 0,d[8] = 1;
        return this;
    }

    this.copyTo = function(m) {
        var a = this.data, b = m.data || m;
        for (var i = 0; i < 9; i++) b[i] = a[i];
        return this;
    }

    this.copyFrom = function(m) {
        var a = this.data, b = m.data || m;
        for (var i = 0; i < 9; i++) a[i] = b[i];
        return this;
    }

    this.transformVector = function (v, pv) {
        var d = this.data;
        var x = v.x, y = v.y, z = v.z;
        pv = pv || v;

        pv.x = d[0] * x + d[3] * y + d[6] * z;
        pv.y = d[1] * x + d[4] * y + d[7] * z;
        pv.z = d[2] * x + d[5] * y + d[8] * z;

        return pv;
    }

    this.determinant = function() {
        var d = this.data;

        return d[0] * (d[4] * d[8] - d[7] * d[5]) +
               d[3] * (d[7] * d[2] - d[1] * d[8]) +
               d[6] * (d[1] * d[5] - d[4] * d[2]);
    }

    this.inverse = function(m) {
        var d = this.data;
        m = m || this.data;

        var a00 = d[0], a01 = d[1], a02 = d[2],
            a10 = d[3], a11 = d[4], a12 = d[5],
            a20 = d[6], a21 = d[7], a22 = d[8],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) {
            console.warn("Attempt to inverse a singular matrix33. ", this.data);
            return m;
        }
        
        id = 1 / d;

        m[0] = b01 * id;
        m[1] = (-a22 * a01 + a02 * a21) * id;
        m[2] = (a12 * a01 - a02 * a11) * id;
        m[3] = b11 * id;
        m[4] = (a22 * a00 - a02 * a20) * id;
        m[5] = (-a12 * a00 + a02 * a10) * id;
        m[6] = b21 * id;
        m[7] = (-a21 * a00 + a01 * a20) * id;
        m[8] = (a11 * a00 - a01 * a10) * id;

        return m;

    }

    this.transpose = function() {
        var d = this.data;

        var d0 = d[0], d3 = d[3], d6 = d[6],
            d1 = d[1], d4 = d[4], d7 = d[7],
            d2 = d[2], d5 = d[5], d8 = d[8];

        d[0] = d0;
        d[1] = d3;
        d[2] = d6;

        d[3] = d1;
        d[4] = d4;
        d[5] = d7;

        d[6] = d2;
        d[7] = d5;
        d[8] = d8;
    }

}

/* --- --- [math/Matrix44.js] --- --- */

/**
 *  @class Matrix44
 *  @memberof SQR
 *
 *  @description A multi-purpose 4x4 matrix.
 */
SQR.Matrix44 = function(data) {

	this.data = data || new Float32Array(16);

	this.identity = function(m) {
		var d = m || this.data;
		d[0] = 1,d[4] = 0,d[8] = 0,d[12] = 0;
		d[1] = 0,d[5] = 1,d[9] = 0,d[13] = 0;
		d[2] = 0,d[6] = 0,d[10] = 1,d[14] = 0;
		d[3] = 0,d[7] = 0,d[11] = 0,d[15] = 1;
		return this;
	}

	/**
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Multiplies the vector v by my this matrix and stores the result in the vector pv.
	 *
	 *  @param {SQR.V3} v - the vector to be multiplies by this matrix
	 *  @param {SQR.V3=} pv - the vector in which to store the result. If ommited, result is stored in v.
	 */
	this.transformVector = function (v, pv) {
		var d = this.data;
		var x = v.x, y = v.y, z = v.z, w = v.w;
		pv = pv || v;
		
		pv.x = d[0] * x + d[4] * y + d[8] * z + d[12] * w;
		pv.y = d[1] * x + d[5] * y + d[9] * z + d[13] * w;
		pv.z = d[2] * x + d[6] * y + d[10] * z + d[14] * w;
		// pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

		return pv;
	}

	this.rotateVector = function (v, pv) {
		var d = this.data;
		var x = v.x, y = v.y, z = v.z, w = v.w;
		pv = pv || v;
		
		pv.x = d[0] * x + d[4] * y + d[8] * z;
		pv.y = d[1] * x + d[5] * y + d[9] * z;
		pv.z = d[2] * x + d[6] * y + d[10] * z;
		// pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

		return pv;
	}

	/**
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Multiplies this matrix by m
	 *  @param {SQR.Matrix44} m - matrix to multiply this matrix by
	 */
	this.multiply = function(m) {
		var a = this.data, b = m.data || m;

		var a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11, a12, a13, a14, a15;
		var b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, b12, b13, b14, b15;

		a00 = a[0],a01 = a[1],a02 = a[2],a03 = a[3];
		a04 = a[4],a05 = a[5],a06 = a[6],a07 = a[7];
		a08 = a[8],a09 = a[9],a10 = a[10],a11 = a[11];
		a12 = a[12],a13 = a[13],a14 = a[14],a15 = a[15];

		b00 = b[0],b01 = b[1],b02 = b[2],b03 = b[3];
		b04 = b[4],b05 = b[5],b06 = b[6],b07 = b[7];
		b08 = b[8],b09 = b[9],b10 = b[10],b11 = b[11];
		b12 = b[12],b13 = b[13],b14 = b[14],b15 = b[15];

		a[0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
		a[1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
		a[2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
		a[3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;

		a[4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
		a[5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
		a[6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
		a[7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;

		a[8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
		a[9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
		a[10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
		a[11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;

		a[12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
		a[13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
		a[14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
		a[15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

		return this;
	}

	/**
	 *  @method setTQS
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the translation/rotation/scale values at once. 
	 *  Similar to setTRS but the rotation is defined as a quaternion.
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz y translation
	 *  @param qw w compoment of the quaternion
	 *  @param qx x compoment of the quaternion
	 *  @param qx y compoment of the quaternion
	 *  @param qx z compoment of the quaternion
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @param m the matrix to set scale to, applies to `this` if ommited
	 */
	this.setTQS = function(tx, ty, tz, qw, qx, qy, qz, sx, sy, sz, m) {

		var d = m || this.data;
		this.identity(m);

		var sqx = qx * qx;
		var sqy = qy * qy;
		var sqz = qz * qz;

		// fliping this part changes from left handed to right handed (I think)
		if(SQR.flipMatrix) {
			d[0] = (1 - 2 * sqy - 2 * sqz) * sx;
			d[1] = (2 * qx * qy - 2 * qz * qw) * sx;
			d[2] = (2 * qx * qz + 2 * qy * qw) * sx;

			d[4] = (2 * qx * qy + 2 * qz * qw) * sy;
			d[5] = (1 - 2 * sqx - 2 * sqz) * sy;
			d[6] = (2 * qy * qz - 2 * qx * qw) * sy;

			d[8] = (2 * qx * qz - 2 * qy * qw) * sz;
			d[9] = (2 * qy * qz + 2 * qx * qw) * sz;
			d[10] = (1 - 2 * sqx - 2 * sqy) * sz;
		} else {
			d[0] = (1 - 2 * sqy - 2 * sqz) * sx;
			d[4] = (2 * qx * qy - 2 * qz * qw) * sx;
			d[8] = (2 * qx * qz + 2 * qy * qw) * sx;

			d[1] = (2 * qx * qy + 2 * qz * qw) * sy;
			d[5] = (1 - 2 * sqx - 2 * sqz) * sy;
			d[9] = (2 * qy * qz - 2 * qx * qw) * sy;

			d[2] = (2 * qx * qz - 2 * qy * qw) * sz;
			d[6] = (2 * qy * qz + 2 * qx * qw) * sz;
			d[10] = (1 - 2 * sqx - 2 * sqy) * sz;
		}

		d[12] = tx;
		d[13] = ty;
		d[14] = tz;

		return m || this;
	}

	/**
	 *  @method setTRS
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the translation/rotation/scale values at once.
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz y translation
	 *  @param rx rotation angle in radians on the x axis
	 *  @param ry rotation angle in radians on the y axis
	 *  @param rz rotation angle in radians on the z axis
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @param m the matrix to set scale to, applies to `this` if ommited
	 */
	this.setTRS = function(tx, ty, tz, rx, ry, rz, sx, sy, sz, m) {

		var d = m || this.data;
		this.identity(m);

		var six = Math.sin(rx), cox = Math.cos(rx), siy = Math.sin(ry), coy = Math.cos(ry), siz = Math.sin(rz), coz = Math.cos(rz);

		// fliping this part changes from left handed to right handed (I think)
		if(SQR.flipMatrix) {
			d[0] = (coy * coz + siy * six * siz) * sx;
			d[1] = (-coy * siz + siy * six * coz) * sx;
			d[2] = siy * cox * sx;

			d[4] = siz * cox * sy;
			d[5] = coz * cox * sy;
			d[6] = -six * sy;

			d[8] = (-siy * coz + coy * six * siz) * sz;
			d[9] = (siz * siy + coy * six * coz) * sz;
			d[10] = coy * cox * sz;
		} else {
			d[0] = (coy * coz + siy * six * siz) * sx;
			d[4] = (-coy * siz + siy * six * coz) * sx;
			d[8] = siy * cox * sx;

			d[1] = siz * cox * sy;
			d[5] = coz * cox * sy;
			d[9] = -six * sy;

			d[2] = (-siy * coz + coy * six * siz) * sz;
			d[6] = (siz * siy + coy * six * coz) * sz;
			d[10] = coy * cox * sz;
		}

		d[12] = tx;
		d[13] = ty;
		d[14] = tz;

		return m || this;
	}

	/**
	 *  @method setScale
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the scale values.
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @param m the matrix to set scale to, applies to `this` if ommited
	 */
	this.setScale = function(sx, sy, sz, m) {
		var d = m || this.data;
		d[0] = sx, d[5] = sy, d[10] = sz;
		return m || this;
	}

	/**
	 *  @method setTranslation
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the translation values.
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz z translation
	 *  @param m the matrix to set translation to, applies to `this` if ommited
	 */
	this.setTranslation = function(tx, ty, tz, m) {
		var d = m || this.data;
		d[12] = tx, d[13] = ty, d[14] = tz;
		return m || this;
	}

	/**
	 *  @method setRotation
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the rotation value.
	 *  @param rx angle in radians of the rotation on x axis
	 *  @param ry angle in radians of the rotation on y axis
	 *  @param rz angle in radians of the rotation on z axis
	 *  @param m the matrix to set rotation to, applies to `this` if ommited
	 */
	this.setRotation = function(rx, ry, rz, m) {
		var d = m || this.data;
		var six = Math.sin(rx), cox = Math.cos(rx), 
			siy = Math.sin(ry), coy = Math.cos(ry), 
			siz = Math.sin(rz), coz = Math.cos(rz);

		d[0] = coy * coz + siy * six * siz;
		d[1] = -coy * siz + siy * six * coz;
		d[2] = siy * cox;

		d[4] = siz * cox;
		d[5] = coz * cox;
		d[6] = -six;

		d[8] = -siy * coz + coy * six * siz;
		d[9] = siz * siy + coy * six * coz;
		d[10] = coy * cox;

		return m || this;
	}

	/** 
	 *  @method translate
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Applies translation to matrix
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz z translation
	 */
	this.translate = function(tx, ty, tz) {
		this.identity(SQR.Matrix44.__temp);
		this.setTranslation(tx, ty, tz, SQR.Matrix44.__temp);
		return this.multiply(SQR.Matrix44.__temp);
	}

	/** 
	 *  @method rotate
	 *  @memberof SQR.Matrix44.prototype
	 *  @param rx angle in radians of the rotation on x axis
	 *  @param ry angle in radians of the rotation on y axis
	 *  @param rz angle in radians of the rotation on z axis
	 *  @description Applies rotation to matrix
	 */
	this.rotate = function(rx, ry, rz) {
		this.identity(SQR.Matrix44.__temp);
		this.setRotation(rx, ry, rz, SQR.Matrix44.__temp);
		return this.multiply(SQR.Matrix44.__temp);
	}

	/** 
	 *  @method scale
	 *  @memberof SQR.Matrix44.prototype
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @description Applies scale to matrix
	 */
	this.scale = function(sx, sy, sz) {
		this.identity(SQR.Matrix44.__temp);
		this.setScale(sx, sy, sz, SQR.Matrix44.__temp);
		return this.multiply(SQR.Matrix44.__temp);
	}

	/** 
	 *  @method copyTo
	 *  @memberof SQR.Matrix44.prototype
	 *  Copies the values from this matrix into m
	 *
	 *  @param {SQR.Matrix44|Float32Array} m - the matrix or 16-compoment array to copy the values to
	 */
	this.copyTo = function(m) {
		var a = this.data, b = m.data || m;
		for (var i = 0; i < 16; i++) b[i] = a[i];
		return this;
	}

	this.copyFrom = function(m) {
		var a = this.data, b = m.data || m;
		for (var i = 0; i < 16; i++) a[i] = b[i];
		return this;
	}

	/** 
	 *  @method copyRotationTo
	 *  @memberof SQR.Matrix44.prototype
	 *  Copies only the rotation/scale portion of the matrix into m to the current matrix
	 *
	 *  @param {SQR.Matrix44|Float32Array} m - the matrix or 16-compoment array to copy the values to
	 */
	this.copyRotationTo = function(m) {
		var a = this.data, b = m.data || m;

		b[0] = a[0];
		b[1] = a[1];
		b[2] = a[2];

		b[3] = a[4];
		b[4] = a[5];
		b[5] = a[6];

		b[6] = a[8];
		b[7] = a[9];
		b[8] = a[10];

		return m;
	}

	/** 
	 *  @method extractPosition
	 *  @memberof SQR.Matrix44.prototype
	 *  Sets v to the translation vakue of this matrix. Useful for extracting position of an element
	 *  based on it's transformation matrix, ex. this is how the the global position of a {@link SQR.Transform} 
	 *  is obtained.
	 *
	 *  @param {SQR.V3} v - the vector to copy the translation values to
	 */
	this.extractPosition = function(v) {
		var d = this.data;
		v.set(d[12], d[13], d[14]);
		return v;
	}

	this.determinant = function() {
		var d = this.data;

		return d[0] * (d[5] * d[10] - d[9] * d[6]) +
			d[4] * (d[9] * d[2] - d[1] * d[10]) +
			d[8] * (d[1] * d[6] - d[5] * d[2]);
	}

	this.inverse = function(m) {
		var a = this.data;
		var d = (m) ? m.data || m : this.data;

		var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
			a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
			a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
			a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

			b00 = a00 * a11 - a01 * a10,
			b01 = a00 * a12 - a02 * a10,
			b02 = a00 * a13 - a03 * a10,
			b03 = a01 * a12 - a02 * a11,
			b04 = a01 * a13 - a03 * a11,
			b05 = a02 * a13 - a03 * a12,
			b06 = a20 * a31 - a21 * a30,
			b07 = a20 * a32 - a22 * a30,
			b08 = a20 * a33 - a23 * a30,
			b09 = a21 * a32 - a22 * a31,
			b10 = a21 * a33 - a23 * a31,
			b11 = a22 * a33 - a23 * a32,

			// Calculate the determinant
			det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		if (!det) { 
			return null; 
		}
		det = 1.0 / det;

		d[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		d[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		d[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		d[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
		d[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		d[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		d[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		d[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
		d[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
		d[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
		d[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
		d[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
		d[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
		d[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
		d[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
		d[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

		return m;
	};

	
	this.inverseMat3 = function(m) {
		// adapted from gl-Matrix.js
		var d = this.data;
		var a = m.data;
		var det = this.determinant();

		if (Math.abs(det) < 0.0001) {
			console.warn("> SQR.Matrix44 - Attempt to inverse a singular matrix44. ", this.data);
			console.trace();
			return m;
		}

		var d0 = d[0], d4 = d[4], d8 = d[8],   d12 = d[12],
			d1 = d[1], d5 = d[5], d9 = d[9],   d13 = d[13],
			d2 = d[2], d6 = d[6], d10 = d[10], d14 = d[14];

		det = 1 / det;

		// To make a NormalMatrix - needs to be transposed
		a[0] = (d5 * d10 - d9 * d6) * det;
		a[1] = (d8 * d6 - d4 * d10) * det;
		a[2] = (d4 * d9 - d8 * d5) * det;

		a[3] = (d9 * d2 - d1 * d10) * det;
		a[4] = (d0 * d10 - d8 * d2) * det;
		a[5] = (d8 * d1 - d0 * d9) * det;

		a[6] = (d1 * d6 - d5 * d2) * det;
		a[7] = (d4 * d2 - d0 * d6) * det;
		a[8] = (d0 * d5 - d4 * d1) * det;
		
		// To make a NormalMatrix - doesn't need to be transposed
		// a[0] = (d5 * d10 - d9 * d6) * det;
		// a[3] = (d8 * d6 - d4 * d10) * det;
		// a[6] = (d4 * d9 - d8 * d5) * det;

		// a[1] = (d9 * d2 - d1 * d10) * det;
		// a[4] = (d0 * d10 - d8 * d2) * det;
		// a[7] = (d8 * d1 - d0 * d9) * det;

		// a[2] = (d1 * d6 - d5 * d2) * det;
		// a[5] = (d4 * d2 - d0 * d6) * det;
		// a[8] = (d0 * d5 - d4 * d1) * det;

		

		return m;
	}

	this.transpose = function(m) {
		var d = this.data;
		var a = (m) ? m.data || m : this.data;

		var d0 = d[0], d4 = d[4], d8 = d[8],
			d1 = d[1], d5 = d[5], d9 = d[9],
			d2 = d[2], d6 = d[6], d10 = d[10];

		a[0] = d0;
		a[1] = d4;
		a[2] = d8;

		a[4] = d1;
		a[5] = d5;
		a[6] = d9;

		a[8] = d2;
		a[9] = d6;
		a[10] = d10;
	}

	this.lookAt = function (target, up) {
		var d = this.data;
		var x = SQR.V3.__tv1;
		var y = SQR.V3.__tv2;
		var z = SQR.V3.__tv3;

		up = up || SQR.V3.up;

		// console.log(target, up);

		z.set(d[12], d[13], d[14]);
		z.sub(z, target).norm();
		if (z.magsq() === 0) z.z = 1;

		x.cross(up, z).norm();
		if (x.magsq() === 0) {
			z.x += 0.0001;
			x.cross(up, z).norm();
		}

		y.cross(z, x);

		d[0] = x.x, d[4] = y.x, d[8] = z.x;
		d[1] = x.y, d[5] = y.y, d[9] = z.y;
		d[2] = x.z, d[6] = y.z, d[10] = z.z;

		return this;
	}

	if(!data) this.identity();
}

SQR.Matrix44.__temp = new Float32Array(16);












/* --- --- [math/PerlinNoise.js] --- --- */

/**
 *  @class PerlinNoise
 *  @memberof SQR
 *
 *  @description <p>A speed-improved perlin and simplex noise algorithms for 2D.</p>
 *
 *	<p>Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 *	Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 *	Better rank ordering method by Stefan Gustavson in 2012.
 *	Converted to Javascript by Joseph Gentle.</p>
 *
 *	<p>Version 2012-03-09</p>
 *
 *	<p>This code was placed in the public domain by its original author,
 *	Stefan Gustavson. You may use it as you see fit, but attribution is appreciated.</p>
 *
 *	<p>This code below is copied from <a href='https://github.com/josephg/noisejs/blob/master/perlin.js'>perlin.js</a> and only slightly chnaged to  adapt for SQR API.</p>
 *	
 */
SQR.PerlinNoise = (function(){

	var module = {};

	function Grad(x, y, z) {
		this.x = x; this.y = y; this.z = z;
	}
	
	Grad.prototype.dot2 = function(x, y) {
		return this.x*x + this.y*y;
	};

	Grad.prototype.dot3 = function(x, y, z) {
		return this.x*x + this.y*y + this.z*z;
	};

	var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
							 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
							 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

	var p = [151,160,137,91,90,15,
	131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
	190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
	88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
	77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
	102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
	135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
	5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
	223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
	129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
	251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
	49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
	// To remove the need for index wrapping, double the permutation table length
	var perm = new Array(512);
	var gradP = new Array(512);

	// This isn't a very good seeding function, but it works ok. It supports 2^16
	// different seed values. Write something better if you need more seeds.
	module.seed = function(seed) {
		if(seed > 0 && seed < 1) {
			// Scale the seed out
			seed *= 65536;
		}

		seed = Math.floor(seed);
		if(seed < 256) {
			seed |= seed << 8;
		}

		for(var i = 0; i < 256; i++) {
			var v;
			if (i & 1) {
				v = p[i] ^ (seed & 255);
			} else {
				v = p[i] ^ ((seed>>8) & 255);
			}

			perm[i] = perm[i + 256] = v;
			gradP[i] = gradP[i + 256] = grad3[v % 12];
		}
	};

	module.seed(0);

	/*
	for(var i=0; i<256; i++) {
		perm[i] = perm[i + 256] = p[i];
		gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
	}*/

	// Skewing and unskewing factors for 2, 3, and 4 dimensions
	var F2 = 0.5*(Math.sqrt(3)-1);
	var G2 = (3-Math.sqrt(3))/6;

	var F3 = 1/3;
	var G3 = 1/6;

	/** 
	 *	@method perlin2
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.simplex2 = function(xin, yin) {
		var n0, n1, n2; // Noise contributions from the three corners
		// Skew the input space to determine which simplex cell we're in
		var s = (xin+yin)*F2; // Hairy factor for 2D
		var i = Math.floor(xin+s);
		var j = Math.floor(yin+s);
		var t = (i+j)*G2;
		var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
		var y0 = yin-j+t;
		// For the 2D case, the simplex shape is an equilateral triangle.
		// Determine which simplex we are in.
		var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
		if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
			i1=1; j1=0;
		} else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
			i1=0; j1=1;
		}
		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6
		var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		var y1 = y0 - j1 + G2;
		var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
		var y2 = y0 - 1 + 2 * G2;
		// Work out the hashed gradient indices of the three simplex corners
		i &= 255;
		j &= 255;
		var gi0 = gradP[i+perm[j]];
		var gi1 = gradP[i+i1+perm[j+j1]];
		var gi2 = gradP[i+1+perm[j+1]];
		// Calculate the contribution from the three corners
		var t0 = 0.5 - x0*x0-y0*y0;
		if(t0<0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
		}
		var t1 = 0.5 - x1*x1-y1*y1;
		if(t1<0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * gi1.dot2(x1, y1);
		}
		var t2 = 0.5 - x2*x2-y2*y2;
		if(t2<0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * gi2.dot2(x2, y2);
		}
		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70 * (n0 + n1 + n2);
	};

	/** 
	 *	@method simplex3
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *	@param {Number} z
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.simplex3 = function(xin, yin, zin) {
		var n0, n1, n2, n3; // Noise contributions from the four corners

		// Skew the input space to determine which simplex cell we're in
		var s = (xin+yin+zin)*F3; // Hairy factor for 2D
		var i = Math.floor(xin+s);
		var j = Math.floor(yin+s);
		var k = Math.floor(zin+s);

		var t = (i+j+k)*G3;
		var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
		var y0 = yin-j+t;
		var z0 = zin-k+t;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
		var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
		if(x0 >= y0) {
			if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
			else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
			else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
		} else {
			if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
			else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
			else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
		}
		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		var x1 = x0 - i1 + G3; // Offsets for second corner
		var y1 = y0 - j1 + G3;
		var z1 = z0 - k1 + G3;

		var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
		var y2 = y0 - j2 + 2 * G3;
		var z2 = z0 - k2 + 2 * G3;

		var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
		var y3 = y0 - 1 + 3 * G3;
		var z3 = z0 - 1 + 3 * G3;

		// Work out the hashed gradient indices of the four simplex corners
		i &= 255;
		j &= 255;
		k &= 255;
		var gi0 = gradP[i+   perm[j+   perm[k   ]]];
		var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
		var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
		var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

		// Calculate the contribution from the four corners
		var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
		if(t0<0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
		}
		var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
		if(t1<0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
		}
		var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
		if(t2<0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
		}
		var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
		if(t3<0) {
			n3 = 0;
		} else {
			t3 *= t3;
			n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
		}
		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 32 * (n0 + n1 + n2 + n3);

	};

	// ##### Perlin noise stuff

	function fade(t) {
		return t*t*t*(t*(t*6-15)+10);
	}

	function lerp(a, b, t) {
		return (1-t)*a + t*b;
	}

	/** 
	 *	@method perlin2
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.perlin2 = function(x, y) {
		// Find unit grid cell containing point
		var X = Math.floor(x), Y = Math.floor(y);
		// Get relative xy coordinates of point within that cell
		x = x - X; y = y - Y;
		// Wrap the integer cells at 255 (smaller integer period can be introduced here)
		X = X & 255; Y = Y & 255;

		// Calculate noise contributions from each of the four corners
		var n00 = gradP[X+perm[Y]].dot2(x, y);
		var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
		var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
		var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

		// Compute the fade curve value for x
		var u = fade(x);

		// Interpolate the four results
		return lerp(
				lerp(n00, n10, u),
				lerp(n01, n11, u),
			 fade(y));
	};

	/** 
	 *	@method perlin3
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *	@param {Number} z
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.perlin3 = function(x, y, z) {
		// Find unit grid cell containing point
		var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
		// Get relative xyz coordinates of point within that cell
		x = x - X; y = y - Y; z = z - Z;
		// Wrap the integer cells at 255 (smaller integer period can be introduced here)
		X = X & 255; Y = Y & 255; Z = Z & 255;

		// Calculate noise contributions from each of the eight corners
		var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
		var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
		var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
		var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
		var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
		var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
		var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
		var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

		// Compute the fade curve value for x, y, z
		var u = fade(x);
		var v = fade(y);
		var w = fade(z);

		// Interpolate
		return lerp(
				lerp(
					lerp(n000, n100, u),
					lerp(n001, n101, u), w),
				lerp(
					lerp(n010, n110, u),
					lerp(n011, n111, u), w),
			 v);
	};

	return module;

})();






/* --- --- [math/ProjectionMatrix.js] --- --- */

/**
 *  @class ProjectionMatrix
 *  @memberof SQR
 *
 *  @description The 4x4 matrix is a specialized 4x4 matrix used for perspective and orthographic projection.
 */
SQR.ProjectionMatrix = function() {
	if (typeof Float32Array == 'undefined') Float32Array = Array;
	this.data = new Float32Array(16);

	this.copyTo = function(m) {
		var a = this.data, b = m.data || m;
		for (var i = 0; i < 16; i++) b[i] = a[i];
		return m;
	}

	this.identity();
}


SQR.ProjectionMatrix.getBoundsAtDistance = function(fov, distance, width, height) {
	width = width || window.innerWidth;
	height = height || window.innerHeight;
	var aspect = width/height;
	var t = Math.tan(fov / 180 * Math.PI / 2);
	var h = distance * t;
	var w = h * aspect;
	return { w : w, h : h };
};

/**
 *  Resets the matrix to identity
 */
SQR.ProjectionMatrix.prototype.identity = function() {
	var m = this.data;
	m[0] = 1,m[1] = 0,m[2] = 0,m[3] = 0;
	m[4] = 0,m[5] = 1,m[6] = 0,m[7] = 0;
	m[8] = 0,m[9] = 0,m[10] = 1,m[11] = 0;
	m[12] = 0,m[13] = 0,m[14] = 0,m[15] = 1;
	return this;
}

/**
 *  Returns an orthographic projection matrix that is set in screen coordinates.
 */
SQR.ProjectionMatrix.prototype.screenPixels2d = function() {
	this.orthographic(window.innerWidth, 0, window.innerHeight, 0, -1, 1000);
	return this;
}

/**
 *  Returns an orthographic projection matrix.
 */
SQR.ProjectionMatrix.prototype.orthographic = function(left, right, top, bottom, near, far) {

	var m = this.data;

	 /**
	 *  @property the near clipping
	 *  @readonly
	 */
	this.near = near;

	/**
	 *  @property the far clipping
	 *  @readonly
	 */
	this.far = far;
	
	var w = right - left;
	var h = top - bottom;
	var p = far - near;

	var x = ( right + left ) / w;
	var y = ( top + bottom ) / h;
	var z = ( far + near ) / p;

	m[0] = 2 / w;    m[4] = 0;        m[8] = 0;        m[12] = -x;
	m[1] = 0;        m[5] = 2 / h;    m[9] = 0;        m[13] = -y;
	m[2] = 0;        m[6] = 0;        m[10] = -2/p;    m[14] = -z;
	m[3] = 0;        m[7] = 0;        m[11] = 0;       m[15] = 1;
	return this;
}

/**
 *  Returns a perspective projection matrix.
 */
SQR.ProjectionMatrix.prototype.perspective = function(fov, aspect, near, far) {

	fov = fov || 60;
	near = near || 1;
	far = far || 1000;

	var m = this.data;
	var t = near * Math.tan(fov * Math.PI / 360);
	var n = far - near;

	m[0] = near / (t * aspect);
	m[4] =  0;
	m[8] =  0;
	m[12] = 0;

	m[1] = 0;
	m[5] = near / t;
	m[9] = 0;
	m[13] = 0;

	m[2] = 0;
	m[6] = 0;
	m[10] = -(far + near) / n;
	m[14] = -(2 * far * near) / n;

	m[3] = 0;
	m[7] = 0;
	m[11] = -1;
	m[15] = 0;

	/**
	 *  @property {Number} the field ov view
	 *	@default 60
	 *  @readonly
	 */
	this.fov = fov;

	/**
	 *  @property {Number=} the near clipping plane
	 *	@default 1
	 *  @readonly
	 */
	this.near = near;

	/**
	 *  @property {Number=} the far clipping plane
	 *	@default 1000
	 *  @readonly
	 */
	this.far = far;
	

	return this;
}

/**
 *  Returns vector mautipled by this matrix
 */
SQR.ProjectionMatrix.prototype.transformVector = function(v, pv) {
	var x = v.x, y = v.y, z = v.z, w = v.w;
	var m = this.data;
	pv = pv || v;

	pv.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	pv.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	pv.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
//  pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

	return pv;
}

/**
 *  Inverses the matrix. Useful for projecting screen coordinates back in to 3d space.
 */
/*
SQR.ProjectionMatrix.prototype.inverse = function (m) {
	var mat = this.data;
	m = m || this.data;

	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
		a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
		a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
		a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

		b00 = a00 * a11 - a01 * a10,
		b01 = a00 * a12 - a02 * a10,
		b02 = a00 * a13 - a03 * a10,
		b03 = a01 * a12 - a02 * a11,
		b04 = a01 * a13 - a03 * a11,
		b05 = a02 * a13 - a03 * a12,
		b06 = a20 * a31 - a21 * a30,
		b07 = a20 * a32 - a22 * a30,
		b08 = a20 * a33 - a23 * a30,
		b09 = a21 * a32 - a22 * a31,
		b10 = a21 * a33 - a23 * a31,
		b11 = a22 * a33 - a23 * a32,

		d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
		invDet;

	// Calculate the determinant
	if (!d) {
		return null;
	}
	invDet = 1 / d;

	m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
	m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
	m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
	m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;

	m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
	m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
	m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
	m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;

	m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
	m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
	m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
	m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;

	m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
	m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
	m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
	m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

	return m;
};

*/

/* --- --- [math/Quaternion.js] --- --- */

/**
 *  @class Quaternion
 *  @memberof SQR
 *
 *  @description Represents a quaternion with optionally setting the values directly.
 *
 *  Just as a reminder, given an angle `a` and an axis `x,y,z` 
 *  this is what the quaternion values are:
 *  @example
var q = new SQR.Quaternion();
var s = Math.sin(a / 2);
q.x = x * s;
q.y = y * s;
q.z = z * s;
q.w = Math.cos(a / 2);
 */
SQR.Quaternion = function(x, y, z, w) {
    this.set(w, x, y, z);
}

/**
 *  Set value of the Quaternion directly.
 */
SQR.Quaternion.prototype.set = function(x, y, z, w) {
    this.w = w || 1;
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    return this;
}

SQR.Quaternion.prototype.copyTo = function(p) {
    p.x = this.x;
    p.y = this.y;
    p.z = this.z;
    p.w = this.w;
    return this;
}

/**
 *  Copy the values from another quaternion.
 *  @param q the quaternion to copy values from
 */
SQR.Quaternion.prototype.copyFrom = function(q) {
    if(q instanceof Array) {
        this.x = q[0];
        this.y = q[1];
        this.z = q[2];
        this.w = q[3];
    } else {
        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
        this.w = q.w;
    }
    return this;
}

/**
 *  Resets the quaternion values to identity.
 */
SQR.Quaternion.prototype.identity = function() {
    this.set();
    return this;
}

/**
 * Multiplies rq (or this if no rq) by q
 * @param q
 * @param rq if not defined this is multiplied by q
 */
SQR.Quaternion.prototype.mul = function(q, rq) {
    rq = rq || this;

    var w = (rq.w * q.w - rq.x * q.x - rq.y * q.y - rq.z * q.z);
    var x = (rq.w * q.x + rq.x * q.w + rq.y * q.z - rq.z * q.y);
    var y = (rq.w * q.y - rq.x * q.z + rq.y * q.w + rq.z * q.x);
    var z = (rq.w * q.z + rq.x * q.y - rq.y * q.x + rq.z * q.w);

    rq.set(x, y, z, w);

    rq.normalize();

    return rq;
}

SQR.Quaternion.prototype.dot = function(q) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
}

/**
 *  Sets the quaternion to point in the given direction.
 *  @param _dir the direction to look at
 *  @param _up the up vector
 */
SQR.Quaternion.prototype.lookAt = function(_dir, _up) {

    var dir = SQR.Quaternion.__tv1;
    var right = SQR.Quaternion.__tv2;
    var up = SQR.Quaternion.__tv3;

    _dir.copyTo(dir);
    _up.copyTo(up);

    dir.norm();

    // If direction is back, the returned quaternion is flipped. Not sure why, but that fixes it.
    if(dir.z == -1) {
        dir.x = 0.0001;
        dir.norm();
    }

    // Probably should do the orthonormalization but not sure how that works :)
    // tangent.sub(up, forward.mul(SQR.V3.dot(forward, up))).norm();
    right.cross(up, dir);
    up.cross(dir, right);

    this.w = Math.sqrt(1 + right.x + up.y + dir.z) * 0.5;
    var rc = 4 * this.w;
    this.x = (dir.y - up.z) / rc;
    this.y = (right.z - dir.x) / rc;
    this.z = (up.x - right.y) / rc;

    this.normalize();

    return this;
}

/**
 *  Creates a quaternion out of an angle axis representation.
 *  @param a angle in radians
 *  @param x x component of the axis
 *  @param y y component of the axis
 *  @param z z component of the axis
 */
SQR.Quaternion.prototype.fromAngleAxis = function(a, x, y, z) {
    var s = Math.sin(a / 2);
    this.x = x * s;
    this.y = y * s;
    this.z = z * s;
    this.w = Math.cos(a / 2);
    return this;
}

/**
 *  Returns the magniture of the quaternion.
 */
SQR.Quaternion.prototype.mag = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
}

/**
 *  Normalizes the quaternion.
 */
SQR.Quaternion.prototype.normalize = function() {
    var n = this.mag();
    this.x /= n;
    this.y /= n;
    this.z /= n;
    this.w /= n;
    return this;
}


/**
 *  Inverses the quaternion.
 */
SQR.Quaternion.prototype.neg = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
}

/**
 *  That method doesn't do anything. 
 *  Check {SQR.Matrix44.TQS()} to see how to turn a 
 *  Quanternion into a matrix representation.
 *
 *  @todo Implement (or not... not sure how much this is needed)
 */
SQR.Quaternion.prototype.toMatrix = function(m) {
    throw "SQR.Quaternion.toMatrix() is not implemented. Check SQR.Matrix44.TQS()"; 
}


// This one is from three.js (used for reference )
// SQR.Quaternion.slerp2 = function(qa, qb, t, qr) {

//     qr = qr || new SQR.Quaternion();


//     if ( t === 0 ) return qr.copyFrom(qa);
//     if ( t === 1 ) return qr.copyFrom(qb);

//     var x = qa.x, y = qa.y, z = qa.z, w = qa.w;

//     // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
//     var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

//     if (cosHalfTheta < 0) {
//         qr.w = - qb.w;
//         qr.x = - qb.x;
//         qr.y = - qb.y;
//         qr.z = - qb.z;
//         cosHalfTheta = - cosHalfTheta;
//     } else {
//         qr.copyFrom( qb );
//     }

//     if (cosHalfTheta >= 1.0) {
//         qr.w = w;
//         qr.x = x;
//         qr.y = y;
//         qr.z = z;
//         return qr;
//     }

//     var halfTheta = Math.acos( cosHalfTheta );
//     var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

//     if (Math.abs( sinHalfTheta ) < 0.001) {
//         qr.w = 0.5 * (w + qr.w);
//         qr.x = 0.5 * (x + qr.x);
//         qr.y = 0.5 * (y + qr.y);
//         qr.z = 0.5 * (z + qr.z);
//         return qr;
//     }

//     var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
//     ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

//     qr.w = (w * ratioA + qr.w * ratioB);
//     qr.x = (x * ratioA + qr.x * ratioB);
//     qr.y = (y * ratioA + qr.y * ratioB);
//     qr.z = (z * ratioA + qr.z * ratioB);

//     return qr;

// }

/**
 *  Returns a spherical linear interpolation between two quaternions.
 *  @param qa first quaternion
 *  @param qb second quaternion
 *  @param t interpolation value [0-1]
 *  @param qr the quaterion to store the results in and return. If omitted results are returned in a new quaternion object.
 */
SQR.Quaternion.slerp = function(qa, qb, t, qr) {
    qr = qr || new SQR.Quaternion();

    if (t === 0) return qr.copyFrom(qa);
    if (t === 1) return qr.copyFrom(qb);

    // Try taking the dot product of your two quaternions (i.e., the 4-D dot product), 
    // and if the dot product is negative, replace your quaterions q1 and q2 with -q1 and q2 before performing Slerp.
    // http://stackoverflow.com/questions/2886606/flipping-issue-when-interpolating-rotations-using-quaternions

    // (This is not working for me)


    var cha = SQR.Quaternion.dot(qa, qb);

    if(cha < 0) {
        qa.neg();
        cha = SQR.Quaternion.dot(qa, qb);
    }

    var ha = Math.acos(cha);
    var sha = Math.sqrt(1 - cha * cha);
    var ra = Math.sin((1 - t) * ha) / sha;
    var rb = Math.sin(t * ha) / sha;

    if (Math.abs(cha) >= 1) {
        // If angle is 0 (i.e cos(a) = 1) just
        // return the first quaternion
        ra = 1;
        rb = 0;
    } else if (Math.abs(sha) < 0.001) {
        // If angle is 180 deg (i.e. sin(a) = 0) there is
        // an infinite amount of possible rotations between those 2
        ra = 0.5;
        rb = 0.5;
    }

    qr.w = (qa.w * ra + qb.w * rb);
    qr.x = (qa.x * ra + qb.x * rb);
    qr.y = (qa.y * ra + qb.y * rb);
    qr.z = (qa.z * ra + qb.z * rb);
    return qr;
}

SQR.Quaternion.dot = function(qa, qb) {
    return qa.x * qb.x + qa.y * qb.y + qa.z * qb.z + qa.w * qb.w;
}

SQR.Quaternion.prototype.slerp = function(qa, qb, t) {
    SQR.Quaternion.slerp(qa, qb, t, this);
    return this;
}

SQR.Quaternion.__tv1 = new SQR.Quaternion();
SQR.Quaternion.__tv2 = new SQR.Quaternion();
SQR.Quaternion.__tv3 = new SQR.Quaternion();
















/* --- --- [math/Random.js] --- --- */

/*

This is the code from https://github.com/davidbau/seedrandom
with minor modifications.

Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
		width = 256,        // each RC4 output is 0 <= x < 256
		chunks = 6,         // at least six RC4 outputs for each double
		digits = 52,        // there are 52 significant digits in a double
		rngname = 'random', // rngname: name for Math.random and Math.seedrandom
		startdenom = math.pow(width, chunks),
		significance = math.pow(2, digits),
		overflow = significance * 2,
		mask = width - 1,
		nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
	var key = [];
	options = (options == true) ? { entropy: true } : (options || {});

	// Flatten the seed string or build one from local entropy if needed.
	var shortseed = mixkey(flatten(
		options.entropy ? [seed, tostring(pool)] :
		(seed == null) ? autoseed() : seed, 3), key);

	// Use the seed to initialize an ARC4 generator.
	var arc4 = new ARC4(key);

	// This function returns a random double in [0, 1) that contains
	// randomness in every bit of the mantissa of the IEEE 754 value.
	var prng = function() {
		var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
				d = startdenom,                 //   and denominator d = 2 ^ 48.
				x = 0;                          //   and no 'extra last byte'.
		while (n < significance) {          // Fill up all significant digits by
			n = (n + x) * width;              //   shifting numerator and
			d *= width;                       //   denominator and generating a
			x = arc4.g(1);                    //   new least-significant-byte.
		}
		while (n >= overflow) {             // To avoid rounding up, before adding
			n /= 2;                           //   last byte, shift everything
			d /= 2;                           //   right using integer math until
			x >>>= 1;                         //   we have exactly the desired bits.
		}
		return (n + x) / d;                 // Form the number within [0, 1).
	};

	prng.int32 = function() { return arc4.g(4) | 0; }
	prng.quick = function() { return arc4.g(4) / 0x100000000; }
	prng.double = prng;

	// Mix the randomness into accumulated entropy.
	mixkey(tostring(arc4.S), pool);

	// Calling convention: what to return as a function of prng, seed, is_math.
	return (options.pass || callback ||
			function(prng, seed, is_math_call, state) {
				if (state) {
					// Load the arc4 state from the given state if it has an S array.
					if (state.S) { copy(state, arc4); }
					// Only provide the .state method if requested via options.state.
					prng.state = function() { return copy(arc4, {}); }
				}

				// If called as a method of Math (Math.seedrandom()), mutate
				// Math.random because that is how seedrandom.js has worked since v1.0.
				if (is_math_call) { math[rngname] = prng; return seed; }

				// Otherwise, it is a newer calling convention, so return the
				// prng directly.
				else return prng;
			})(
	prng,
	shortseed,
	'global' in options ? options.global : (this == math),
	options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
	var t, keylen = key.length,
			me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

	// The empty key [] is treated as [0].
	if (!keylen) { key = [keylen++]; }

	// Set up S using the standard key scheduling algorithm.
	while (i < width) {
		s[i] = i++;
	}
	for (i = 0; i < width; i++) {
		s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
		s[j] = t;
	}

	// The "g" method returns the next (count) outputs as one number.
	(me.g = function(count) {
		// Using instance members instead of closure state nearly doubles speed.
		var t, r = 0,
				i = me.i, j = me.j, s = me.S;
		while (count--) {
			t = s[i = mask & (i + 1)];
			r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
		}
		me.i = i; me.j = j;
		return r;
		// For robust unpredictability, the function call below automatically
		// discards an initial batch of values.  This is called RC4-drop[256].
		// See http://google.com/search?q=rsa+fluhrer+response&btnI
	})(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
	t.i = f.i;
	t.j = f.j;
	t.S = f.S.slice();
	return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
	var result = [], typ = (typeof obj), prop;
	if (depth && typ == 'object') {
		for (prop in obj) {
			try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
		}
	}
	return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
	var stringseed = seed + '', smear, j = 0;
	while (j < stringseed.length) {
		key[mask & j] =
			mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	}
	return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
	try {
		if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
		var out = new Uint8Array(width);
		(global.crypto || global.msCrypto).getRandomValues(out);
		return tostring(out);
	} catch (e) {
		var browser = global.navigator,
				plugins = browser && browser.plugins;
		return [+new Date, global, plugins, global.screen, tostring(pool)];
	}
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
	return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
	module.exports = seedrandom;
	// When in node.js, try using crypto package for autoseeding.
	try {
		nodecrypto = require('crypto');
	} catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
	define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
	[],     // pool: entropy pool starts empty
	Math    // math: package containing random, pow, and seedrandom
);

/* --- --- [math/Spline.js] --- --- */

/**
 *  @class Spline
 *  @memberof SQR
 *
 *  @description Represents a spline composed of multiple cubic beziers
 */
SQR.Spline = function() {

	// Bezier paths generated from segments/controlPoints in create() 
	var paths = [];

	// Points from the input source defining the path of the spline
	var segments = [];

	// Each segment has two control points (the "hands" coming out fo paths)
	var controlPoints = [];

	var s = {};

	var _tv1, _tv2;

	var getcontrolPoints = function(point, previous, next, c1, c2, smoothness) {
		var vab = _tv1.sub(point, previous).neg();
		var vcb = _tv2.sub(point, next);
		var d = (smoothness > 1) ? smoothness : smoothness * Math.min(vab.mag(), vcb.mag());
		c1.set().add(vab, vcb).norm().mul(d);
		c2.copyFrom(c1).neg();
		c1.add(c1, point);
		c2.add(c2, point);
	}

	s.addSegment = function(p) {
		var v;

		if(p.x !== undefined) {
			v = p;
		} else {
			var a = arguments, l = a.length;
			if(l == 2) v = new SQR.V2(a[0], a[1]);
			else if(l == 3) v = new SQR.V3(a[0], a[1], a[2]);
		}

		segments.push(v);
		controlPoints.push(v.clone(), v.clone());

		if(!_tv1) {
			_tv1 = segments[0].clone();
			_tv2 = segments[0].clone();
		}

		return s;
	}

	s.create = function(smoothness, close) {

		if(segments.length < 2) return segments;

		smoothness = (smoothness !== null) ? smoothness : 0.5;
		paths.length = 0;
		var firstPoint, firstControlPoint;

		var sg = segments, cp = controlPoints, sl = segments.length;
		
		for(var i = 0; i < sl; i++) {
			var si = sg[i];
			var c1 = cp[i * 2].set();
			var c2 = cp[i * 2 + 1].set();

			var a = (i == 0) ? sg[sl-1] : sg[i-1];
			var b = (i == sl-1) ? sg[0] : sg[i+1];

			getcontrolPoints(si, a, b, c1, c2, smoothness);
			cp.push(c1, c2);
		}

		for(var i = 0; i < sl-1; i++) {
			var a = sg[i];
			var b = (i == sl-1) ? sg[0] : sg[i+1];

			var c1 = (i == 0 && !close) ? a : cp[i * 2 + 1];
			var c2 = (i == sl-2 && !close) ? b : cp[i * 2 + 2];

			var c = new SQR.Bezier(a, c1, c2, b);
			paths.push(c);
		}

		if(close) {
			var c = new SQR.Bezier(sg[sl-1], cp[(sl-1)*2+1], cp[0], sg[0]);
			paths.push(c);
		}

		s.smoothness = smoothness;
		s.close = s.close;

		return s;
	}

	s.valueAt = function(t, v) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0].valueAt(tf % 1, v);
	}

	s.bezierAt = function(t) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0];
	}

	s.velocityAt = function(t, v) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0].velocityAt(tf % 1, v);
	}

	s.matrixAt = function(t, m) {
		if(t == 0) t = SQR.EPSILON;
		if(t == 1) t = 1 - SQR.EPSILON;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0].matrixAt(tf % 1, m);
	}

	Object.defineProperty(s, 'segments', {
		get: function() { 
			return segments; 
		}
	});

	Object.defineProperty(s, 'paths', {
		get: function() { 
			return paths; 
		}
	});

	return s;

}

/* --- --- [math/Triangle.js] --- --- */

/**
 *  @class Triangle
 *  @memberof SQR
 *
 *  @description Represents a triangle composed on 3 vectors. 
 *	Vectors can be of any size, though some of it methods only work with 2-dimensional vectors.
 *
 *	@param v1 Vector {@link SQR.V2} or {@link SQR.V3}
 *
 *	@property {SQR.V2} centroid - the centroid, undef until `calculateCentroid` is called.
 *	@property {Number} circumRadius - the  radius of the 
 *		circum-circle, undef until `calculateCircumCircle` is called.
 *	@property {SQR.V2} circumCenter - the center of the cirsum-circle, 
 *		undef until `calculateCircumCircle` is called.
 *	
 */
SQR.Triangle = function(v0, v1, v2) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

	/**
	 *	Calculates the centroid for this triangle. Only works with 2d coordinates for now.
	 *	The resulting centroid is stored in the `centroid` property.
	 *
	 *	@memberof SQR.Triangle.prototype
	 *	@method calculateCentroid
	 */
	this.calculateCentroid = function() {
		this.centroid = new SQR.V2();
		this.centroid.x = (this.v0.x + this.v1.x + this.v2.x) / 3;
		this.centroid.y = (this.v0.y + this.v1.y + this.v2.y) / 3;
	}

	/**
	 *	Calculates circumcircle, only works with 2d coordinates.
	 *	<br><br>
	 *	Based on 
	 *	{@link http://jwilson.coe.uga.edu/emat6680/dunbar/assignment4/assignment4_kd.htm this}
	 *	and
	 *	{@link http://www.exaflop.org/docs/cgafaq/cga1.html this}.
	 *
	 *	@memberof SQR.Triangle.prototype
	 *	@method calculateCircumCircle
	 */
	this.calculateCircumCircle = function() {
		var A = this.v1.x - this.v0.x;
		var B = this.v1.y - this.v0.y;
		var C = this.v2.x - this.v0.x;
		var D = this.v2.y - this.v0.y;

		var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
		var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);

		var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));

		var dx, dy;

		if (Math.abs(G) < SQR.EPSILON) {
			// Collinear - find extremes and use the midpoint
			var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);
			var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);
			var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);
			var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);

			this.circumCenter = new SQR.V2((minx + maxx) / 2, (miny + maxy) / 2);

			dx = this.circumCenter.x - minx;
			dy = this.circumCenter.y - miny;
		} else {
			var cx = (D * E - B * F) / G;
			var cy = (A * F - C * E) / G;

			this.circumCenter = new SQR.V2(cx, cy);

			dx = this.circumCenter.x - this.v0.x;
			dy = this.circumCenter.y - this.v0.y;
		}

		this.circumRadiusSq = dx * dx + dy * dy;
		this.circumRadius = Math.sqrt(this.circumRadiusSq);
	}

	/**
	 *	Test whether the point v is inside the triangles circumcircle. 
	 *	If circum-circle was not calculated, calculateCircumCircle will be called first
	 *	@memberof SQR.Triangle.prototype
	 *	@method vertexInCircumcircle
	 *	@param {SQR.V2} v - vertex to be checked
	 *	@returns {boolean} true is vertex is in circumcircle
	 */
	this.vertexInCircumcircle = function(v) {

		if(!this.circumCenter) this.calculateCircumCircle();

		var dx = this.circumCenter.x - v.x;
		var dy = this.circumCenter.y - v.y;
		var sq = dx * dx + dy * dy;
		return (sq <= this.circumRadiusSq);

	}

	this.get = function(i) {
		if(i == 0) return this.v0;
		if(i == 1) return this.v1;
		if(i == 2) return this.v2;
	}

};

/* --- --- [math/Vector2.js] --- --- */

/**
 *  @class V2
 *  @memberof SQR
 *
 *  @description A 2-dimensional vector
 *
 */
SQR.V2 = function(x, y) {
	this.set(x, y);
	this.size = 2;
}

SQR.V2.prototype.set = function(x, y) {
	this.x = x || 0;
	this.y = y || 0;
	return this;
}

SQR.V2.prototype.copyTo = function(p) {
	p.x = this.x;
	p.y = this.y;
	return p;
}

SQR.V2.prototype.copyFrom = function(p) {
	if(p instanceof Array) {
		this.x = p[0];
		this.y = p[1];
	} else {
		this.x = p.x;
		this.y = p.y;
	}
	return this;
}

SQR.V2.prototype.clone = function() {
	return new SQR.V2(this.x, this.y);
}

SQR.V2.prototype.magsq = function() {
	return this.x * this.x + this.y * this.y;
};

SQR.V2.prototype.mag = function() {
	return Math.sqrt(this.magsq());
};

SQR.V2.prototype.isZero = function() {
	return this.x == 0 && this.y == 0;
};

SQR.V2.prototype.mul = function(s) {
	this.x *= s;
	this.y *= s;
	return this;
}

SQR.V2.prototype.neg = function() {
	this.x = -this.x;
	this.y = -this.y;
	return this;
}

SQR.V2.prototype.norm = function() {
	var m = 1 / this.mag();
	this.set(this.x * m, this.y * m);
	return this;
}

/**
 * a.add(a, b).add(a, c) -> a + b + c
 *
 * @param a
 * @param b
 */
SQR.V2.prototype.add = function(a, b) {
	b = b || this;
	this.x = a.x + b.x;
	this.y = a.y + b.y;
	return this;
}

/**
 * a.sub(b, a) ->  a = from a to b
 *
 * @param a
 * @param b
 */
SQR.V2.prototype.sub = function(a, b) {
	b = b || this;
	this.x = a.x - b.x;
	this.y = a.y - b.y;
	return this;
}

SQR.V2.prototype.lerp = function(a, b, t) {
	this.x = a.x + (b.x - a.x) * t;
	this.y = a.y + (b.y - a.y) * t;
	return this;
}

SQR.V2.dot = function(a, b) {
	return (a.x * b.x + a.y * b.y)
}

SQR.V2.prototype.perp = function() {
	this.set(this.y, -this.x);
	return this;
}

SQR.V2.prototype.toUniform = function() {
	return this.toArray();
}

SQR.V2.prototype.toArray = function() {
	if(!this.array) this.array = new Float32Array(2);
	this.array[0] = this.x;
	this.array[1] = this.y;
	return this.array;
}

/* --- --- [math/Vector3.js] --- --- */

/**
 *  @class V3
 *  @memberof SQR
 *
 *  @descrption A 3-dimensional vector
 *
 */
SQR.V3 = function(x, y, z) {
	this.set(x, y, z)
	this.size = 3;
	SQR.V3.instances++;
}

/**
 *  Sets the vector compoment to values. Note that this class has actually 4 not 3 compoments.
 *  @param x - the value of the x compoment
 *  @param y - the value of the y compoment
 *  @param z - the value of the z compoment
 *  @param w - the value of the homogeneous coordinate, defaults to 1 
 *      and leave it that way unless you really know what ypu are doing.
 */ 
SQR.V3.prototype.set = function(x, y, z, w) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = w || 1;
	return this;
}

/**
 *  Copies values from this vector into the p vector
 *
 *  @param {SQR.V2|SQR.V3} p - vector to copy the values to
 */
SQR.V3.prototype.copyTo = function(p) {
	p.x = this.x;
	p.y = this.y;
	if(p.z != undefined) p.z = this.z;
	return p;
}

/**
 *  Copies values from vector p into this vector
 *
 *  @param {SQR.V2|SQR.V3} p - vector to copy the values from if available, otherwise defaults to zero
 */
SQR.V3.prototype.copyFrom = function(p) {
	if(p instanceof Array) {
		this.x = p[0] || 0;
		this.y = p[1] || 0;
		this.z = p[2] || 0;
	} else {
		this.x = p.x || 0;
		this.y = p.y || 0;
		this.z = p.z || 0;
	}
	return this;
}

/**
 *  Creates and returns a copy of this vector. 
 *  Be careful with this method, because it creates a new object. 
 *  Calling this function repeatedly in a rendering loop can have an adverce impact on performance.
 *
 *  @returns {SQR.V3} a new vector that is a copy of this vector
 */
SQR.V3.prototype.clone = function() {
	return new SQR.V3(this.x, this.y, this.z);
}

/** 
 *  Returns the squared length of this vector. This can be useful to optimize some calculations, since
 *  the actual length requires a squareroot operation (`Math.sqrt()`) 
 *  which can be slow if used on many vectors.
 */
SQR.V3.prototype.magsq = function() {
	return this.x * this.x + this.y * this.y + this.z * this.z;
};

/**
 *  Return the length (magnitude) of this vector
 *  @returns {Number} the length of this vector
 */
SQR.V3.prototype.mag = function() {
	return Math.sqrt(this.magsq());
};

/**
 *  Shorthand to check if this vector is a zero vector 
 *  (i.e. all compoments are very small or equal to 0) The values are compared against SQR.EPSILON
 */
SQR.V3.prototype.isZero = function() {
	return Math.abs(this.x) < SQR.EPSILON &&  Math.abs(this.y) < SQR.EPSILON && Math.abs(this.z) < SQR.EPSILON;
};

/**
 *  Multiples this vector by a scalar. 
 *  This function can be used in conjunction with {@link SQR.V3#norm} 
 *  to set the vector to a given length `v.norm().mul(10)1 yields a vector of length 10.
 *
 *  @param {Number} s - the value to multiply the the vector by.
 */
SQR.V3.prototype.mul = function(s) {
	this.x *= s;
	this.y *= s;
	this.z *= s;
	return this;
}

/**
 *  Negates this vector.
 */
SQR.V3.prototype.neg = function() {
	this.x = -this.x;
	this.y = -this.y;
	this.z = -this.z;
	return this;
}

/**
 *  Normalizes this vector, i.e. sets its length (magnitude) to 1.
 */
SQR.V3.prototype.norm = function() {
	var m = 1 / this.mag();
	this.set(this.x * m, this.y * m, this.z * m);
	return this;
}

/**
 *  Sets this vector to the sum of a and b. 
 *
 *  @example
a.add(b, c); // a = b + c
a.add(a, b); // a += b
a.add(b);    // alt a += b
a.add(a, b).add(a, c); // = a + b + c
 *
 *  @param {SQR.V3} a
 *  @param {SQR.V3=} b - if omitted the current vector is used, which basically means that a is added to current vector.
 */
SQR.V3.prototype.add = function(a, b) {
	b = b || this;
	this.x = a.x + b.x;
	this.y = a.y + b.y;
	this.z = a.z + b.z;
	return this;
}

/**
 * a.sub(b, a) ->  a = from a to b
 *
 * @param a
 * @param b
 */
SQR.V3.prototype.sub = function(a, b) {
	this.x = a.x - b.x;
	this.y = a.y - b.y;
	this.z = a.z - b.z;
	return this;
}

SQR.V3.prototype.lerp = function(a, b, t) {
	this.x = a.x + (b.x - a.x) * t;
	this.y = a.y + (b.y - a.y) * t;
	this.z = a.z + (b.z - a.z) * t;
	return this;
}

SQR.V3.prototype.random = function() {
	this.x = Math.random() * 2 - 1;
	this.y = Math.random() * 2 - 1;
	this.z = Math.random() * 2 - 1;
	return this;
}

/**
 *  Returns the dot product of a nd b (`a . b`).
 *  @returns {Number} result of a . b
 */
SQR.V3.dot = function(a, b) {
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/**
 *  Sets this vector to the result of a cross-product of a and b (`a x b`).
 */
SQR.V3.prototype.cross = function(a, b) {
	var x = a.y * b.z - a.z * b.y;
	var y = a.z * b.x - a.x * b.z;
	var z = a.x * b.y - a.y * b.x;
	this.set(x, y, z, this.w);
	return this;
}

/**
 *  @private
 *  @description Alias for toArray
 *
 *  @returns {Float32Array} array - the array holding the values of this vector
 */
SQR.V3.prototype.toUniform = function() {
	return this.toArray();
}

/**
 *  @private
 *  @description Lazily creates a Float32Array and stores 
 *  the components of this vector in the array.
 *  This is mostly used when the value of this vector is 
 *  passed as uniform to a shader
 *  (this function is called internally by the renderer).
 *
 *  @returns {Float32Array} array - the array holding the values of this vector
 */
SQR.V3.prototype.toArray = function() {
	if(!this.array) this.array = new Float32Array(3);
	this.array[0] = this.x;
	this.array[1] = this.y;
	this.array[2] = this.z; 
	return this.array;
}

SQR.V3.prototype.toString = function toString() {
  return x;
}

/**
 *  Assuming the vector was projected using the {@link SQR.ProjectionMatrix}, use this
 *  to calculate it's screen space. (useful for software rendering, ex. on canvas 2d)
 *
 *  @param {Number=} w - the width of the screen (defaults to `window.innerWidth`) 
 *  @param {Number=} h - the height of the screen (defaults to `window.innerHeight`) 
 */
SQR.V3.prototype.toScreenSpace = function(w, h) {
	w = w || window.innerWidth;
	h = h || window.innerHeight;
	this.x = (this.x / this.z) * w/2 + w/2;
	this.y = (this.y / this.z) * h/2 + h/2;

	// TODO: make sure this is ok to be here in any case
	this.y = h - this.y;
}

/**
 *  Use this for caculating per-vertex normals. 
 *  A normal from each contributing face can be added here. 
 *  When all the normals are added, a vector that is the sum of them all 
 *  is available as `this.normal` property. The pre-vertex normal can be caluculated
 *  by normalizing this vector.
 */
SQR.V3.prototype.addNormal = function(_n) {

	if(!this.normal) {
		this.normal = new SQR.V3();
	}

	this.normal.add(this.normal, _n);
}

/** 
 *  This is used to reset the normal to 0,0,0.
 */
SQR.V3.prototype.resetNormal = function(_n) {
	if(this.normal) this.normal.set();
}


/**
 *  @const
 *  @memberof SQR.V3
 *  @description A constant the defines the up vector. 
 *  WARNING: be extremly careful not to modify the values of this vector, because this will cause some
 *  matrix functions, like {@link SQR.Matrix44#lookAt} to not fuction properly.
 */
SQR.V3.up = new SQR.V3(0,1,0);

/**
 *  @const
 *  @memberof SQR.V3
 *  @description A constant the defines the forward vector. 
 *  WARNING: be extremly careful not to modify the values of this vector, because this will cause some
 *  matrix functions to not fuction properly.
 */
SQR.V3.forward = new SQR.V3(0,0,1);

SQR.V3.__tv1 = new SQR.V3();
SQR.V3.__tv2 = new SQR.V3();
SQR.V3.__tv3 = new SQR.V3();

SQR.V3.instances = 0;

/* --- --- [two/CanvasRenderer.js] --- --- */

/**
 *  @class CanvasRenderer
 *  @memberof SQR
 *
 *  @description Part of a minimal Canvas 2d rendering engine. The paremeter is a canvas element or a selector (ex. #gl-canvas) 
 *	can be passed to this function. If omitted a new canvas element will be created
 *	and it will be available as the canvas property of the object.
 *
 *	@param {HTMLCanvasElement} the underlying canvas element
 *	@property {HTMLCanvasElement} the underlying canvas element
 */
SQR.CanvasRenderer = function(canvas) {

	var r = {}, clearColor = null;

	var BADCTX = "> SQR.Context - Invalid canvas reference.";

	if(!canvas) canvas = document.createElement('canvas');
	if(!(canvas instanceof HTMLElement)) canvas = document.querySelector(canvas);
	if(!canvas.getContext) throw BADCTX;

	var ctx = canvas.getContext('2d');

	// Dash line shim
	if(!ctx.setLineDash) ctx.setLineDash = function() {};

	r.canvas = canvas;
	r.context = ctx;

	/** 
	 *	Set the size of the underlying canvas element.
	 *	@method setSize
	 *	@memberof SQR.CanvasRenderer.prototype
	 *	@param {Number} w - the width of the canvas
	 *	@param {Number} h - the height of the canvas
	 *	@param {Number} r - the resolution (aka pixel ratio)
	 */
	r.setSize = function(w, h, r) {
		r = r || 1;
		canvas.width = w * r;
		canvas.height = h * r;
		canvas.style.width = w + 'px';
		canvas.style.height = h + 'px';
		return r;
	}

	r.setClearColor = function(c) {
		clearColor = c;
		return r;
	}

	/**
	 *	Render the transform tree
	 *	@method render
	 *	@memberof SQR.CanvasRenderer.prototype
	 *	@param {SQR.Transform2d} root - the root transform to render
	 */
	r.render = function(root) {
		if(clearColor) {
			
			if(clearColor.indexOf('rgba') > -1) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
			}

			ctx.fillStyle = clearColor;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
		} else {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}
		

		if(root) root.draw(ctx);
	}

	return r;
}

/* --- --- [two/Transform2d.js] --- --- */

/**
 *  @class Transform2d
 *  @memberof SQR
 *
 *  @description Similar to {SQR.Transform} but specialized to work with 2d rendeirng on a 2d canvas element.
 *  
 */
SQR.Transform2d = function(name) {

	var t = {};

	t.name = name || 'sqr.transform.' + SQR.Transform2dCount++;

    /** 
     *  @var {SQR.V3} position - the position of this transform relative to it's parent.
     *  It's a 3d vector, because z is used for depth indexing.
     *  @memberof SQR.Transform2d.prototype
     */
	t.position = new SQR.V3(0, 0, 0);

    /**
     *  @var {SQR.V3} rotation - the rotation of the transform in radians
     *  @memberof SQR.Transform2d.prototype
     */
	t.rotation = 0;

    /**
     *  @var {SQR.V2} scale - the scale of the object on x and y axis
     *  @memberof SQR.Transform2d.prototype
     */
	t.scale = new SQR.V2(1, 1);

    /**
     *  @var {Number} alpha - the transparency of this element. 
     *  @memberof SQR.Transform2d.prototype
     *  0 = transparent, 1 = opaque, default 1
     */
    t.alpha = 1;

	t.children = [], t.numChildren = 0;

   /**
    *   @method add
    *   @memberof SQR.Transform2d.prototype
    *   
    *   @description Add a child transform. Accepts multiple arguments but all of them need to be of type {SQR.Transform2D}.
    *   It doesn't do any sort of type checking so if you add non object that are not {SQR.Transform2D} 
    *   it will result in errors when the scene is rendered.
    */
    t.add = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            c.parent = t;
            if (t.children.indexOf(c) == -1) t.children.push(c);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method remove
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Removes a child transform. Accepts multiple arguments 
     *  but all of them need to be of type {SQR.Transform2D}
     */
    t.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            var j = t.children.indexOf(c);
            if (j == -1) return false;
            c.parent = null;
            t.children.splice(j, 1);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method removeAll
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Removes all children transform.
     */
    t.removeAll = function() {
        t.children.length = 0;
        t.numChildren = 0;
    }

    /**
     *  @method contains
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Checks if transform is child of this transfom
     *  @param {SQR.Transform2D} c the transform to look for
     */
    t.contains = function(c) {
        return t.children.indexOf(c) > -1;
    }

    /**
     *  @method recurse
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Execute this function on all the child transforms including this current one.
     *
     *  @param {function} f the function that will be called on each child. 
     *  This function will receive the transform as argument.
     *
     *  @param {boolean} excludeSelf if set to true, the function will only be called for all 
     *  the ancestors of the Transform.
     */
    t.recurse = function(f, excludeSelf) {
       if(!excludeSelf) f(t);
        for (var i = 0; i < t.numChildren; i++) {
            t.children[i].recurse(f);
        }
    }

    t.draw = function(context) {
        var c = context;

    	c.save();
    	c.translate(t.position.x, t.position.y);
    	c.rotate(t.rotation);

        c.scale(t.scale.x, t.scale.y);

    	// First draw the children, then self, so that alpha/scale do not affect children
        // * Not sure why scale should not affect children, so moving this before drawing children (check again)

    	for(var i = 0; i < t.numChildren; i++) t.children[i].draw(c);

        if(t.alpha < 1) c.globalAlpha = t.alpha;
        // c.scale(t.scale.x, t.scale.y);
        if(t.shape) t.shape(c, t);

    	c.restore();
	}

	return t;
}

SQR.Transform2dCount = 0;









