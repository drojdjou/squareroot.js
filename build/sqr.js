/* --- --- [SQR.js] --- --- */

/**
 *	@namespace SQR
 *	@description The global engine namespace. Everything in SQR belongs to this namespace.
 */
var SQR = {

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 2`
	 */
	TWOPI: Math.PI * 2,

	/**
	 *	@property TWOPI - shorthand for `Math.PI * 0.5`
	 */
	HALFPI: Math.PI * 0.5,

	/**
	 *	@property EPSILON - a very small number, used to prevent rounding errors
	 */
	EPSILON: 1.0e-6,

	/**
	 *	@property gl - Placeholder that holds current gl context. This is set in SQR.Context.create(), but can be modified manually too
	 */
	gl: null, 

	/** 
	 *	Setting this value to true will use the old matrix calculation. 
	 *	Best to keep it false, but for now it's true by default for backwards compatibility.
	 */
	flipMatrix: true,
	
	/** 
	 *	@property fullScreenQuad - placeholder that holds a fullscreen geometry for post effects. Lazily created in PostEffect.js
	 *	Typically not set manually.
	 */
	fullScreenQuad: null,

	/**
	 *	@property shaderPath - a path relative to the main HTML file where the src/glsl folder is located.
	 *	Only necessary to if builtin shader code is loaded (using ~ paths).
	 *
	 *	@default .
	 */
	shaderPath: '.',


	/**
	 *	@namespace Primitives
	 *	@memberof SQR
	 *	@description A collection of classes & functions and utilities to create geometries
	 */
	Primitives: {

		V2: function(x, y) { return new SQR.V2(x, y); },
		V3: function(x, y, z) { return new SQR.V3(x, y, z); },
		Q:  function(x, y, z, w) { return new SQR.Quaternion(x, y, z, w); },
		M4: function() { return new SQR.Matrix44(); },

		F: 	function(options) { 

			var f = function(a, b, c, d) {
				var fc = SQR.Face().v(a, b, c, d);
				f.faces.push(fc);
				return fc; 
			};

			f.faces = [];

			f.toBuffer = function(geo) {
				var c = 0;
				f.faces.forEach(function(fc) {
					if(options && options.reverseNormals) fc.flip();
					fc.calculateNormal();
					c += fc.toBuffer(geo, c, options && options.perVertexNormal);
				});
				return c;
			}

			return f;
		}
	},

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2 }
	 */
	v2: function() { return { aPosition: 2 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2 }
	 */
	v3: function() { return { aPosition: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2, aUV: 2 }
	 */
	v2u2: function() { return { aPosition: 2, aUV: 2 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 2, aColor: 3 }
	 */
	v2c3: function() { return { aPosition: 2, aColor: 3 }; },

	/**
	 *	@method v2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 3, aNormal: 3 }
	 */
	v3n3: function() { return { aPosition: 3, aNormal: 3 }; },

	/**
	 *	@method v3n3u2
	 *	@memberof SQR
	 *
	 *	Shorthand for { aPosition: 3, aNormal: 3, aUV: 2 }
	 */
	v3n3u2: function() { return { aPosition: 3, aNormal: 3, aUV: 2 }; },

    // Error reporting 

    // Issues a console.warn() is user attempts to set a uniform that does not exist on the shader
    WARN_UNIFORM_NOT_PRESENT : false 

};

/* --- --- [Version.js] --- --- */

/**
 *	@property Version - autogenerated with build script, holds current verison info
 */
// DO NOT EDIT. Updated from version.json
SQR.Version = {"version":"3.0","build":215,"date":"Oct 19th 2017"};

/* --- --- [GLSL.js] --- --- */

/**
 * @namespace GLSL
 * @memberof SQR
 * @description The global namespace holding GLSL code of all built-in shaders and shader chunks.
 */
SQR.GLSL = {

	/**
	 * @property diffspec
	 * 
	 * @description <p>A general purpose diffuse-specular shader.</p> 
	 * 
	 * <p>It is used internally by the Unity scene parses as the default shader. 
	 * It works with several light related uniforms, but for now only one light per
	 * shader is supported as well it can only be a directiona light.</p>
	 * 
	 * <p>This shader is meant to make working with basic shading easier, but is not 
	 * intended to be some sort of one-shader-to-rule-them-all, so in most scenarios
	 * a custom GLSL shader might be required.</p>
	 * 
	 * <a href='https://github.com/drojdjou/squareroot.js/tree/master/html/src/glsl/builtin/diffspec.glsl'>Shader source</a>
	 */
	"diffspec": "/*#docs*/\n//#vertex\nprecision mediump float;\nattribute vec3 aNormal;\nattribute vec3 aPosition;\nattribute vec2 aUV;\nuniform mat4 uMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjection;\nuniform mat3 uNormalMatrix;\nuniform vec3 uEyePosition;\nvarying vec3 vNormal;\nvarying vec3 vIncident;\nvarying vec2 vUV;\nvoid main() {\n	vNormal = uNormalMatrix * aNormal;\n	vec3 p = (uMatrix * vec4(aPosition, 1.0)).xyz;\n	vIncident = normalize(p - uEyePosition);\n	vUV = aUV;\n	gl_Position = uProjection * uViewMatrix * vec4(aPosition, 1.0);\n}\n//#fragment\nprecision mediump float;\n//#include standardLight\nuniform vec3 uAmbient;\nuniform vec3 uColor;\nuniform float uEmissive;\nuniform vec3 uLightDirection;\n#ifdef USE_DIFFUSE_MAP\nuniform sampler2D uTexture;\nuniform vec4 uTextureTileOffset;\n#endif\n#ifdef USE_SPECULAR\nuniform vec4 uSpecularColor;\nuniform float uShininess;\n#endif\n#ifdef USE_SPECULAR_MAP\nuniform sampler2D uSpecularMap;\n#endif\nvarying vec3 vNormal;\nvarying vec3 vIncident;\nvarying vec2 vUV;\nvec4 texture(sampler2D t, vec2 uv) {\n	return texture2D(t, uv * uTextureTileOffset.xy + uTextureTileOffset.zw);\n}\nvoid main() {\n	#ifdef USE_DIFFUSE_MAP\n	vec3 dm = uColor * texture(uTexture, vUV).rgb;\n	#else\n	vec3 dm = uColor;\n	#endif\n	vec3 e = dm * uEmissive;\n	vec3 d = diffuse(vNormal, uLightDirection, dm, 1.0);\n	#ifdef USE_SPECULAR_MAP\n	#define SI uSpecularColor.a * texture(uSpecularMap, vUV).r\n	#else\n	#define SI uSpecularColor.a\n	#endif\n	#ifdef USE_SPECULAR\n	#define SP specular(vNormal, vIncident, uLightDirection, uSpecularColor.rgb, uShininess, SI)\n	#else \n	#define SP vec3(0.0) \n	#endif\n	gl_FragColor = vec4(uAmbient + e + d + SP, 1.0);\n}\n",

	/**
	 * @property normal2color
	 * 
	 * @description <p>A simple debug shader</p> 
	 * 
	 * <p>The direction of the normal is translated into the color for each pixel. Simple and useful for debugging.</p>
	 * 
	 * <a href='https://github.com/drojdjou/squareroot.js/tree/master/html/src/glsl/builtin/normal2color.glsl'>Shader source</a>
	 */
	"normal2color": "/*#docs*/\n//#vertex indicates that this is where the vertex shader starts\n//#fragment indicates that this is where the fragment shader starts\n//#vertex\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nuniform mat4 uMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjection;\nuniform mat3 uNormalMatrix;\nvarying vec3 vNormal;\nvoid main() {\n	vNormal = normalize(uNormalMatrix * aNormal);\n	gl_Position = uProjection * uViewMatrix * vec4(aPosition, 1.0);\n}\n//#fragment\nprecision mediump float;\nvarying vec3 vNormal;\nvoid main() {\n	gl_FragColor = vec4(vec3(0.5) + vNormal * 0.5, 1.0);\n}\n",

	/**
	 * @property standardLight
	 * 
	 * @description <p>A collection of light related functions</p> 
	 * 
	 * <p>Includes diffuse(), specular() and brightness()</p>
	 * 
	 * <a href='https://github.com/drojdjou/squareroot.js/tree/master/html/src/glsl/builtin/standardLight.glsl'>Shader source</a>
	 */
	"standardLight": "/*#docs*/\nvec3 diffuse(vec3 n, vec3 l, vec3 c, float i) {\n	#ifdef HEMISPHERE_DIFFUSE\n	return (dot(-l, n) * 0.5 + 0.5) * c * i;\n	#else\n	return max(0.0, dot(-l, n)) * c * i;\n	#endif\n}\nvec3 specular(vec3 n, vec3 v, vec3 l, vec3 c, float sh, float i) {\n	return pow(max(0.0, dot(reflect(-l, n), v)), sh) * c.rgb * i;\n}\nfloat brightness(vec3 c) {\n	return c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722;\n}\n",

	/**
	 * @property texture
	 * 
	 * @description <p>A simple textured shader</p> 
	 * 
	 * <p>The shader accepts a single texture and UV channel to map it to.</p>
	 * 
	 * <a href='https://github.com/drojdjou/squareroot.js/tree/master/html/src/glsl/builtin/texture.glsl'>Shader source</a>
	 */
	"texture": "/*#docs*/\nattribute vec3 aPosition;\nattribute vec2 aUV;\nuniform mat4 uMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjection;\nuniform mat3 uNormalMatrix;\nvarying vec2 vUV;\nvoid main() {\n	vUV = aUV;\n	gl_Position = uProjection * uViewMatrix * vec4(aPosition, 1.0);\n}\n//#fragment\nprecision mediump float;\nuniform sampler2D uTexture;\nvarying vec2 vUV;\nvoid main() {\n	gl_FragColor = texture2D(uTexture, vUV);\n}\n",
};


/* --- --- [common/Animation.js] --- --- */

/**
 *	@class Animation
 *	@memberof SQR
 *
 *	@description Represents a single animation as a collection of clips
 */
SQR.Animation = function(duration) {

	var clips = [], numClips = 0;

	var a = {
		duration: duration
	};

	a.addClip = function(c) {
		clips.push(c);
		numClips = clips.length;
	} 

	a.play = function() {
		for(var i = 0; i < numClips; i++) clips[i].playing = true;	
	}

	a.reverse = function(v) {
		for(var i = 0; i < numClips; i++) clips[i].reverse = v;
	}

	a.pause = function() {
		for(var i = 0; i < numClips; i++) clips[i].playing = false;	
	}

	a.gotoTime = function(ms) {
		for(var i = 0; i < numClips; i++) clips[i].gotoTime(ms);	
	}

	a.setTimeScale = function(ts) {
		for(var i = 0; i < numClips; i++) clips[i].timeScale = ts;	
	}

	return a;
}

/* --- --- [common/Buffer.js] --- --- */

/**
 *	@class Buffer
 *	@memberof SQR
 *
 *	@description A buffer represents a 2d or 3d geometry and an attribute buffer.
 *	A buffer is internally composed of a Float32Array array and a WebGL buffer object.
 *	Squareroot does rely on strides, so each geometry is only composed of one array/buffer.
 *	A stride is a portion of the array that holds data for all attributes in a specific order.
 *	For example if the geometry is composed of 3D vertices, normals and 2D UV coordinates, 
 *	the stride look like this<br>
 *	`vx, vy, vz, nx, ny, nz, u, v`<br>
 *	The creation of strides in handled internally by the Buffer class.
 *	<br><br>
 *	More info on strides can be found in the {@link https://www.khronos.org/registry/webgl/specs/latest/1.0/ specs}.
 *	<br><br>
 *	Please read the {@tutorial basic-setup} tutorial to see how to use a buffer  
 *	and the {@tutorial understanding-buffers} tutorial  for an in depth discussion on buffers.
 */
SQR.Buffer = function() {

	var b = {};
	var hasIndex = false;
	var data, indices;
	var buffer, indexBuffer;

	b.mode = SQR.gl.TRIANGLES;
	b.drawMode = SQR.gl.STATIC_DRAW;

	/**
	 *	@method setMode
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description set the drawing mode for this buffer. 
	 *	Can be any one of the supported webgl drawing modes such as 
	 *	`gl.POINTS`, `gl.LINES` or `gl.TRIANGLES` which is the default.
	 *
	 *	Reminder: all the gl constants are available through the `SQR.gl` property.
	 */
	b.setMode = function(m) {
		b.mode = m
		return b;
	}

	/**
	 *	@method layout
	 *	@memberof SQR.Buffer.prototype
	 *	
	 *	@description Sets the layout of the buffer. 
	 *	A layout describes all the attributes of the geometry and their respective sizes. 
	 *	{@link SQR} has a few global functions that ar shorthands for typical layouts, like ex. {@link SQR.v2c3()}
	 *	@example 
var l = { aPosition: 3, aColor: 4, aUV: 2 };
// the `new` keyword is optional, all methods are chainable
var buffer = SQR.Buffer().layout(l, 100).update();
	 *
	 *	@param {object} layout - the layout of the buffer (see desc above) and {@tutorial understanding-buffers}
	 *	@param {Number} size - the size of the buffer i.e. how many vertices it has
	 *	
	 */
	b.layout = function(layout, size) {
		b.size = size;
		b.strideSize = 0;
		b.layout = layout;
		b.attributes = {};

		for(var a in layout) {
			var aa = { offset: b.strideSize, byteOffset: b.strideSize * 4, size: layout[a] };
			b.strideSize += layout[a];
			b.attributes[a] = aa;
		}

		b.strideByteSize = b.strideSize * 4;
		data = new Float32Array(size * b.strideSize);

		return b;
	}

	/**
	 *	@method resize
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Resizes the data array and/or offsets all the data in the array.
	 */
	b.resize = function(size, offset) {
		b.size = size;
		var nd = new Float32Array(size * b.strideSize);
		
		if(!offset) { 
			nd.set(data); 
		} else {
			for(var i = 0; i < data.length; i++) {
				var k = i - offset * b.strideSize;
				if(k >= 0) nd[k] = data[i];
			}
		}

		data = nd;
	}

	/**
	 *	@method data
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets all the data for a given attribute.
	 */
	b.data = function(attribute, array) {

		if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 1);
		}

		var s = b.attributes[attribute];
		var dl = array.length / s.size;

		for(var i = 0; i < dl; i++) {
			for(var j = 0; j < s.size; j++) {
				data[i * b.strideSize + j + s.offset] = array[i * s.size + j];
			}
		}

		return b;
	}

	/**
	 *	@method set
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets a value for an attribute at a defined position.
	 *
	 *	@param {string} attribute - name of the attribute (ex. `aPosition`)
	 *	@param {Number} position - the index of this attrbute (related to the size of the buffer)
	 *	@param {Array=} array - the data in form of an `Array` or as separate arguments 
	 *	or an object that has a `toArray` attribute (see example to see all the possible options)
	 *
	 *	@example
b.set('aPosition', 1, 	[3, 5, 6]);
b.set('aPosition', 1, 	4, 8, 9);
b.set('aPosition', 1, 	new SQR.V3(3, 5, 6));
	 */
	b.set = function(attribute, position, array) {
		if(array.toArray) {
			array = array.toArray();
		} else if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 2);
		}

		var s = attribute ? b.attributes[attribute].offset : 0;

		if(position < 0) position += b.size;
		if(position >= b.size) position = position % b.size;

		for(var j = 0, al = array.length; j < al; j++) {
			data[position * b.strideSize + j + s] = array[j];
		}

		return b;
	}

	// Is this even useful?

	// b.get = function(attribute, position, array) {
	// 	array = array || [];

	// 	var s = b.attributes[attribute];

	// 	if(position < 0) position += b.size;
	// 	if(position >= b.size) position = position % b.size;

	// 	var c = position * b.strideSize + s.offset;
	// 	for(var i = 0; i < b.size; i++) array[i] = data[c + i];

	// 	return array;
	// }

	/**
	 *	@method iterate
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Iterates over each value for an attribute or over every stride.
	 *	See example below to see how to move all the vertices by 4 on the y-axis.
	 *
	 *	@param {string=} attribute - the name of the attribute to interate over, if null, it will iterate over entire strides
	 *
	 *	@param {SQR.Buffer~iterateCallback} callback - the callback function processing the data.
	 *
	 *	@example
b.iterate('aPosition', function(i, data, count)) {
	// i+0 = x, i+1 = y, i+2 = z
	// so, to increment the y value do:
	data[i+1] += 4;
});
	 */
	b.iterate = function(attribute, callback) {
		var s = b.attributes[attribute];

		if(attribute && !s) throw "> SQR.Buffer.iterate > no such attribute: " + attribute;

		var o = attribute ? s.offset : 0;
		var c = 0;

		for(var i = 0; i < data.length; i += b.strideSize) {
			callback(i + o, data, c);
			c++;
		}
		return b;
	}
	/**
	 *	This callback for the iterate function allowing processing of the buffer data.
	 *
	 *	@callback SQR.Buffer~iterateCallback
	 *	@param {Number} i - <p>the index of the first value for this attribute in the buffer</p>
	 *
	 *	<p>Example: if a buffer has 2 attributes - aPosition (3d vector) and aUV (2d vector)
	 *	this means the stride size is 3 + 2 = 5. In this case i for the first position attribute is
	 *	0 and for the second one it is 6. This index points to the index of first component of the attribute
	 *	- in case of a position which is a 3d vector - it points to the x component. 
	 *	To access the next component - y - add 1 to i, so data[i+1] is the y component.</p>
	 *
	 *	@param {Float3dArray} data - the entire the buffer array. Use the i parameter to read/write data to this array.
	 *
	 *	@param {Number} count - the current index for the attribute - it is incremented by 1 at each iteration
	 */

	/**
	 *	@method bind
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Binds the buffer in gl, 
	 *	which does the same thing as calling `gl.bindBuffer` directly.
	 */
	b.bind = function() {
		SQR.gl.bindBuffer(SQR.gl.ARRAY_BUFFER, buffer);
		if(hasIndex)SQR.gl.bindBuffer(SQR.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
		return b;
	}

	/**
	 *	@method update
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Updates the webgl buffer with the data from the internal array. 
	 *	When called for the first time it lazily creates the webgl buffer.
	 */
	b.update = function() {
		var gl = SQR.gl;

		buffer = buffer || gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, b.drawMode);

        if(hasIndex) {
        	indexBuffer = gl.createBuffer();
        	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, b.drawMode);
        }

        return b;
	}

	/**
	 *	@method index
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Sets index data. 
	 *
	 *	@param {Array=} array either an array or argument list of all the indexes. 
	 *	Used when setting up meshes imported as OBJ or JSON object from Unity, Blender or similar.
	 */
	b.index = function(array) {

		if(!(array instanceof Array)) {
			array = Array.prototype.slice.call(arguments, 0);
		}

		indices = new Uint16Array(array);
		b.indexSize = array.length;
        hasIndex = true;

        return b;
	}

	/**
	 *	@method isIndexed
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description returns true if buffer data is indexed and has an index array
	 */
	b.isIndexed = function() {
		return hasIndex;
	}

	/**
	 *	@method draw
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description used by the {SQR.Renderer}, called when this geometry is drawn. 
	 *	Will call `gl.drawArrays` or `gl.drawElements` to draw the geometry using the current shader.
	 */
	b.draw = function(t) {
		var gl = SQR.gl;

		if(hasIndex)
			gl.drawElements(t.drawMode || b.mode, b.indexSize, gl.UNSIGNED_SHORT, 0);
		else 
			gl.drawArrays(t.drawMode || b.mode, 0, b.size);
	}

	/**
	 *	@method setRawData
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description sets the raw data into the array at offset 
	 */
	b.setRawData = function(array, offset) {
		data.set(array, offset);
	}

	/**
	 *	@method getDataArray
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Returns the raw array data
	 *	
	 *	@data {Float32Array} - Array containing all the vertex attributes data organized in strides
	 *	according to the layout.
	 */
	b.getDataArray = function() {
		return data;
	}

	b.getIndexArray = function() {
		return indices;
	}

	/**
	 *	@method destroy
	 *	@memberof SQR.Buffer.prototype
	 *
	 *	@description Destroys the buffer and clears all data from the array.
	 */
	b.destroy  = function() {
		data.length = 0;
		SQR.gl.deleteBuffer(buffer);

		if(hasIndex) {
			indices.length = 0;
			SQR.gl.deleteBuffer(indexBuffer);
		}
	}

	return b;

}

/* --- --- [common/Clip.js] --- --- */

/**
 *	@class Clip
 *	@memberof SQR
 *
 *	@description Represents a single animation clip
 */
SQR.Clip = function(duration) {

	var c = {
		timeScale: 1,
		duration: duration,
		reverse: false,
		playing: false
	};

	var t = 0;
	var properties = [];
	var numProps = 0;
	var tmp = new SQR.V3();

	var setValue = function(target, key, value) {
		switch(key) {
			case 'px': target.position.x = value; break;
			case 'py': target.position.y = value; break;
			case 'pz': target.position.z = value; break;
			case 'rx': target.quaternion.x = value; break;
			case 'ry': target.quaternion.y = value; break;
			case 'rz': target.quaternion.z = value; break;
			case 'rw': target.quaternion.w = value; break;
			default:
				console.warn('Unknown animation property: ', key, ' on ', target);
		}
	}

	// keyframes = Array of V2||V3 or and array of bezier curves
	c.addProperty = function(property, keyframes) {

		var p = {
			prop: property,
			keys: keyframes
		};

		p.size = p.keys.length;

		properties.push(p);
		numProps = properties.length;

		return c;
	}

	c.gotoTime = function(ms) {
		t = Math.max(ms, 0); 
		t = Math.min(ms, c.duration);
	}

	c.update = function(target, time, delta) {

		if(!c.playing || numProps == 0) return;

		var p = delta / 1000 * c.timeScale;
		t += c.reverse ? -p : p;
		if(t < 0) t += duration;
		t = t % duration;

		for(var i = 0; i < numProps; i++) {
			var p = properties[i];

			for(var j = 0; j < p.size; j++) {
				var k1 = p.keys[j+0];
				var k2 = p.keys[j+1];

				if(k1 instanceof SQR.V2) {
					if(t >= k1.x && t < k2.x) {
						var lt = (t - k1.x) / (k2.x - k1.x);
						var v = k1.y + (k2.y - k1.y) * lt;
						setValue(target, p.prop, v);
						break;
					}
				} else if(k1 instanceof SQR.Bezier) {
					var ts = t;
					if(ts >= k1.p0.x && ts < k1.p1.x) {
						var lt = ((ts) - k1.p0.x) / (k1.p1.x - k1.p0.x);
						k1.valueAt(lt, tmp);
						setValue(target, p.prop, tmp.y);
						break;
					}
				}
			}
		}
	}

	

	return c;

}

/* --- --- [common/Collider.js] --- --- */

/**
 * @class Collider 
 * @memberof SQR
 *
 * @description A collider can be attached to a transform and later used with the functions in the Intersection utility to detect collisions.
 */
SQR.Collider = function(t) {

	var that = this;

	this.center = new SQR.V3();
	this.type = t;

	this.radius;
	this.box;
	this.buffer;

	this.hit = false;

	this.calculateBoundingBox = function() {

		var mx = Number.MAX_VALUE;

		var b = {
			minX: mx, maxX: -mx,
			minY: mx, maxY: -mx,
			minZ: mx, maxZ: -mx
		};

		that.buffer.iterate('aPosition', function(i, d, c) {
			b.minX = Math.min(b.minX, d[i + 0]);
			b.maxX = Math.max(b.maxX, d[i + 0]);

			b.minY = Math.min(b.minY, d[i + 1]);
			b.maxY = Math.max(b.maxY, d[i + 1]);

			b.minZ = Math.min(b.minZ, d[i + 2]);
			b.maxZ = Math.max(b.maxZ, d[i + 2]);
		});

		return b;
	}
}

SQR.Collider.SPHERE = 1;
SQR.Collider.BOX = 2;
SQR.Collider.MESH = 3;

SQR.Collider.Sphere = function(radius, center) {
	var c = new SQR.Collider(SQR.Collider.SPHERE);
	c.radius = radius || 0;
	if(center) c.center.copyFrom(center);
	return c;
}

SQR.Collider.Box = function(box) {
	var c = new SQR.Collider(SQR.Collider.BOX);
	c.box = box;
	return c;
}

SQR.Collider.Mesh = function(buffer) {
	var c = new SQR.Collider(SQR.Collider.MESH);
	c.buffer = buffer;
	c.box = c.calculateBoundingBox();
	return c;
}

/* --- --- [common/Context.js] --- --- */

/**
 *	@class Context
 *	@memberof SQR
 *	
 *	@description When creating the Context object, a canvas element or a selector (ex. #gl-canvas) 
 *	can be passed to this function. If omitted a new canvas element will be created
 *	and it will be available as the canvas property of the object 
 *	returned by the SQR.Context functiom. See quick example below or read more in {@tutorial basic-setup}.
 *
 *	@example
// the `new` keyword is optional, all methods are chainable
var w = window.innerWidth, h = window.innerHeight;
var c = SQR.Context('#canvas').create().size(w, h).clearColor(0, 0, 0, 1);
 */
SQR.Context = function(canvas, options, onError) {

	if(!SQR._versionDisplayed && SQR.Version) {
		console.log('%cSquareroot v' + SQR.Version.version + ' b' + SQR.Version.build, 'background: #663399; color: #dd99ff; padding: 4px 10px 4px 10px');
		SQR._versionDisplayed = true;
	}
 
	var NOGL = "> SQR.Context - Webgl is not supported.";
	var BADCTX = "> SQR.Context - Invalid canvas reference.";

	if(!canvas) canvas = document.createElement('canvas');
	if(!(canvas instanceof HTMLElement)) canvas = document.querySelector(canvas);
	if(!canvas.getContext) throw BADCTX;

	var c = { 

		/**
		 *	@var {HTMLCanvasElement} canvas - Represents the canvas used to get the webgl context from.
		 *	@memberof SQR.Context.prototype
		 */
		canvas: canvas 
	}, gl;

	/**
	 *	@method create
	 *	@memberof SQR.Context.prototype
	 *	
	 *	@description Creates the webgl context. 
	 *	
	 *	@param options Options as defined in Specs, section 5.2.
	 *	Passing the options is not mandatory, if uses default values otherwise.
	 *	@link https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2
	 *	
	 *	@param onError callback in case WebGL is not supported
	 *	if ommited, this function will throw (see below) a error if there are problems.
	 *
	 *	@throws error is webgl context cannot be created (ex. webgl is not supported)
	 *
	 *	@returns SQR.Context
	 */
	c.create = function(options, onError) {

		onError = onError || function() { throw NOGL; };

		options = options || {};
		if(options.antialias === undefined) options.antialias = true;
		if(options.stencil === undefined) options.stencil = false;

		if(!window.WebGLRenderingContext) onError();

		try {
			gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
		} catch(e) { 
			console.error(e);
			onError();
		} 

		c.gl = gl;
		c.setAsCurrent();

		gl.enable(gl.CULL_FACE);
		if(options.customGLSetup) options.customGLSetup();

		return c;
	}

	/** 
	 *	Sets the canvas and the viewport size to the given values.
	 */
	c.size = function(w, h, res) {
		res = res || 1;
		
		canvas.width = w * res;
		canvas.height = h * res;

		c.viewport(0, 0, w * res, h * res);

		// canvas.style.width =  w + 'px';
		// canvas.style.height = h + 'px';
		// var s = 1 / res;
		// canvas.ext.transform({ scaleX: s, scaleY: s });

		return c;
	}

	c.viewport = function(x, y, w, h) {
		gl.viewport(x, y, w, h);
		return c;
	}

	c.clearColor = function(r, g, b, a) {
		// console.log('context.clearColor is deprecated, use renderer clear color instead');
		// console.trace();
		gl.clearColor(r, g, b, a);
		gl.clear(gl.COLOR_BUFFER_BIT);
		return c;
	}

	/**
	 *	Quick viewport clear function - clears both color and depth buffers.
	 *	Typically called at each frame before rendering to screen.
	 *	For custom clearing options use SQR.gl.clear()
	 */
	c.clear = function() {
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		return c;
	}

	/**
	 *	Sets this context as current in the global SQR.gl variable.
	 *	This variable is used by the engine to perform rendering.
	 */
	c.setAsCurrent = function() {
		SQR.gl = gl;
		return c;
	}

	c.destroy = function() {
		gl = null;
		canvas = null;
	}

	// Create the context
	c.create(options, onError);

	return c;
}

/* --- --- [common/Cubemap.js] --- --- */

/**
 *  @class Cubemap
 *  @memberof SQR
 *
 *  @descrption A cubemap texture is used for texturing reflections, skyboxes and similar effects. If your shader expects a cubemap uniform use this object to create one.
 *  @param faces {Object} 6 paths to the textures for each face.
 *  @param faces.up {string} the path to the image for the face up
 *  @param faces.down {string} the path to the image for the face down
 *  @param faces.left {string} the path to the image for the face left
 *  @param faces.right {string} the path to the image for the face right
 *  @param faces.back {string} the path to the image for the face back
 *  @param faces.front {string} the path to the image for the face front
 *
 *  @param params {object} parameter for the texture
 *  @param params.onLoad {function} a callback to call when all the images are loaded 
 */
SQR.Cubemap = function(faces, params) {

    var c = {};
    c.tex = SQR.gl.createTexture();

    var facesLeft = 6;
    var faceImages = {};

    params = params || {};

    var onLoad = function() {

    	var gl = SQR.gl;

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, c.tex);

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.right);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.left);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.up);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.down);

        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.front);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, faceImages.back);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        var wrapS = params.wrapS || params.wrap || gl.CLAMP_TO_EDGE;
        var wrapT = params.wrapT || params.wrap || gl.CLAMP_TO_EDGE;

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, wrapT);

        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

        if (params.onLoad) params.onLoad();
    }

    var onFace = function() {
        facesLeft--;
        if (facesLeft <= 0) onLoad();
    }

    var load = function(name, src) {

        if (typeof(src) == "string") {
            faceImages[name] = new Image();
            faceImages[name].onload = onFace;
            faceImages[name].src = src;
        } else if (src instanceof Image || !!src.getContext) {
            faceImages[name] = src;
            onFace();
        }
    }

    if (faces.left) {
        load("left", faces.left);
        load("right", faces.right);
        load("up", faces.up);
        load("down", faces.down);
        load("back", faces.back);
        load("front", faces.front);
    } else if(faces) {
        load("left", faces);
        load("right", faces);
        load("up", faces);
        load("down", faces);
        load("back", faces);
        load("front", faces);
    }

    return c;
}

/* --- --- [common/FrameBuffer.js] --- --- */

/**
 *  @class FrameBuffer
 *  @memberof SQR
 *  
 *  @description A FrameBuffer is used in render-to-texture, image effects and other advances rendering schemes.
 *
 *  @params width The width of the frame buffer
 *  @params height The height of the frame buffer
 */
SQR.FrameBuffer = function(width, height, isCubemap, options) {

	width = width || window.innerWidth;
	height = height || window.innerHeight;
	options = options || {};

	var f = {}, gl = SQR.gl;

	f.texture = gl.createTexture();
	f.depthBuffer = gl.createRenderbuffer();

	// bind & setup texture
	if(!isCubemap) {
		f.fbo = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, f.fbo);
		gl.bindTexture(gl.TEXTURE_2D, f.texture);
		// gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

		if(options.mipmap) gl.generateMipmap(gl.TEXTURE_2D);

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.magFilter || options.filter || gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.minFilter || options.filter || gl.LINEAR);
		
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrapS || options.wrap || gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrapT || options.wrap || gl.CLAMP_TO_EDGE);

		// bind render buffer
		gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

		// attach texture and render buffer to fbo
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, f.texture, 0);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f.depthBuffer);

		// unbind all
		if(options.leaveBind) return;
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	} else {
		// based on http://jsperf.com/webgl-cubemap-fbo-change-face-test
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, f.texture);

		// gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

		gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		for (var i = 0; i < 6; i++) {
			gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		}
	
		gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
		
	
		var makeFace = function(index) {
			var fbo = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + index, f.texture, 0);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, f.depthBuffer);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			return fbo;
		};

		f.faces = {
			right: makeFace(0),
			left: makeFace(1),
			up: makeFace(2),
			down: makeFace(3),
			front: makeFace(4),
			back: makeFace(5),
		};

		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	}

	f.bind = function(name) {
		var fbo = (f.faces) ? f.faces[name] : f.fbo;
		gl.viewport(0, 0, width, height);
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	}

	f.unbind = function() {
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		gl.bindTexture(gl.TEXTURE_2D, f.texture);
		if(options.mipmap) gl.generateMipmap(gl.TEXTURE_2D);
	}

	f.resize = function(w, h) {
		width = w;
		height = h;

		gl.bindFramebuffer(gl.FRAMEBUFFER, f.fbo);
		gl.bindTexture(gl.TEXTURE_2D, f.texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

		gl.bindRenderbuffer(gl.RENDERBUFFER, f.depthBuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	}

	return f;
}


/* --- --- [common/Loader.js] --- --- */

/**
 *	@namespace Loader
 *	@memberof SQR
 *
 *	@description Utility to load different types of files (and also some WebRTC related stuff, see below)
 */
SQR.Loader = {

	/** 
	 *	@method load
	 *	@memberof SQR.Loader
	 *
	 *	@description Load a text file and return it's contents in the callback.
	 */
	loadText: function(path, callback){
		var request = new XMLHttpRequest();
		request.open("GET", path);

		var onReadystatechange = function(){
			if (request.readyState == 4) {
				request.removeEventListener('readystatechange', onReadystatechange);
				callback(request.responseText, path);
			}
		}

		request.addEventListener('readystatechange', onReadystatechange);

		request.send();
	},

	/** 
	 *	@method loadJSON
	 *	@memberof SQR.Loader
	 *
	 *	@description Load a JSON file and return it's contents in the callback.
	 *	This function will parse the JSON data for you and return an Object.
	 */
	loadJSON: function(path, callback){
		SQR.Loader.loadText(path, function(text) {
			callback(JSON.parse(text), path);
		});
	},

	/** 
	 *	@method loadImage
	 *	@memberof SQR.Loader
	 *
	 *	@description Load an image file and return it's contents in the callback
	 *	as Image object.
	 */
	loadImage: function(path, callback, errorCallback){
		var img = new Image();

		if(callback) {
			var onload = function() {
				img.removeEventListener('load', onload);
				callback(img, path);
			}
			img.addEventListener('load', onload);
		}

		if(errorCallback) {
			var onerror = function() {
				img.src = '';
				img.removeEventListener('error', onerror);
				errorCallback(null, path);
				return false;
			}
			img.addEventListener('error', onerror);
		}

		img.src = path;
		return img;
	},

	/** 
	 *	@method loadWebcam
	 *	@memberof SQR.Loader
	 *
	 *	@description Initiate user stream (webcam). 
	 */
	loadWebcam: function(callback, options) {
		navigator.getUserMedia  = navigator.getUserMedia ||
                                navigator.webkitGetUserMedia ||
                                navigator.mozGetUserMedia ||
                                navigator.msGetUserMedia;

        if(!navigator.getUserMedia) {
        	console.error('> SQR.Loader - getUserMedia not supported');
        	callback();
        }

        options = options || {
        	audio: false,
	        video: {
	        	// mandatory: { minWidth: 1920, minHeight: 1080 }
	        }
	    };

	    var onVideo = function(stream) {
	    	video.stream = stream;
			video.src = window.URL.createObjectURL(stream);
	        video.play();
	        video.addEventListener('canplaythrough', videoReady, false);
	    }

	    var videoReady = function() {
	    	callback(video, 'webcam');
	    }

        var video = document.createElement('video');
    	video.autoplay = true;

		navigator.getUserMedia(options, onVideo, function(e) { 
			console.error('> SQR.Loader - getUserMedia error ', e);
		});
    },

    /**
	 *	@method loadVideo
	 *	@memberof SQR.Loader
	 *
     *	@description Preload a video so that it can be used as a texture (typically)
     */
    loadVideo: function(path, callback) {
    	var videoReady = function() {
	    	callback(video, path);
	    }

    	var video = document.createElement('video');
    	video.autoplay = true;
    	video.addEventListener('canplaythrough', videoReady, false);


    	var p = path;

    	if(!video.canPlayType('video/mp4')) {
    		p = p.replace('mp4', 'webm');
    	}

    	video.src = p;
    },

    /**
	 *	@method loadAssets
	 *	@memberof SQR.Loader
	 *
     *	@description Load multiple assets of type:
     *  <ul>
     *		<li>text, including GLSL code</li>
     *		<li>JSON, including model, geometry, scene. etc...</li>
     *		<li>image (jpg, gif, png), video (mp4, webm)</li>
     *		<li>webcam (it will initiate the webcam,
     *		ask user for permisions, and return a ready to use stream)</li>
     *	</ul>
	 *	
	 *	Each file will be availabke from the asset object passed to the callback
	 *	under it's name, ex. assets['normal2color.glsl']
	 *	It's also possible ot specify an alias. Instead of a String, 
	 *	use an Array, where [0] is the path, and [1] is the alias.
     *
     *	@example
SQR.Loader.loadAssets([
	['some-image.jpg', 'image'],
	['some-video.mp4', 'video'],
	['a-shader.glsl', 'shader'],
	'another-shader.glsl',
	'webcam' // special case, but useful :)
], function(assets) {
	var image = assets['image'];
});
	 *
	 * 	@param {object} paths - list of file paths (with optinal aliases) to load, as in example below.
	 *	@param {function} callback - called when all the files are loaded. 
	 *	The assets are passed as argument as in the example below.
	 *	@param {function} progressCallback - called each time when on of the files is loaded
     */
	loadAssets: function(paths, callback, progressCallback, options) {

		options = options || {};

		var toLoad = paths.length;
		var assets = {};

		if(toLoad == 0) {
			if(progressCallback) progressCallback(1, 1);
			callback();
			return;
		}

		var aliases = {}, includes = {};

		var onShader = function(asset, p) {
			SQR.GLSLInclude = SQR.GLSLInclude || {};
			SQR.GLSLInclude[aliases[p]] = asset;
			onAsset(asset, p);
		}

		var onAsset = function(asset, p) {
			assets[aliases[p]] = asset;
			toLoad--;

			if(progressCallback) {
				progressCallback(toLoad, paths.length);
			}

			if(toLoad == 0) {
				callback(assets);
			}
		}
		
		for(var i = 0; i < toLoad; i++) {
			var p = paths[i];

			var hasAlias = typeof(p) != 'string';
			var file = hasAlias ? p[0] : p;
			var alias = hasAlias ? p[1] : p;
			var fileType = file.substring(file.lastIndexOf('.') + 1);

			aliases[file] = alias;
			
			switch(fileType) {
				case 'glsl':
					SQR.Loader.loadText(file, onShader);
					break;
				case 'png':
				case 'jpg':
				case 'gif':
					SQR.Loader.loadImage(file, onAsset);
					break;
				case 'json':
				case 'js':
					SQR.Loader.loadJSON(file, onAsset);
					break;
				case 'mp4':
				case 'webm':
					SQR.Loader.loadVideo(file, onAsset);
					break;
				case 'webcam':
					SQR.Loader.loadWebcam(onAsset);
					break;
			}
		}
	}
};








/* --- --- [common/Pointer3d.js] --- --- */

SQR.Pointer3d = function(options) {

	options = options || {};

	var mx = -2, my = 0;
	var ray = new SQR.Ray();
	var hitObjects = [];

	document.addEventListener('mousemove', function(e) {
		mx = e.pageX / window.innerWidth * 2 - 1;
		my = e.pageY / window.innerHeight * 2 - 1;
	});

	var sortHitObjects = function(a, b) {
		if(a.collider.__hit < b.collider.__hit) { return -1; }
		if(a.collider.__hit > b.collider.__hit) { return  1; }
		return 0;
	}

	return {

		all: options.all || false,

		ray: ray,

		onTransform: function(t) {

			if(!t.collider || mx == -2) return;

			var h = SQR.Intersection.rayTest(ray, t);

			if(options.all) {
				t.collider.hit = h;
			} else {
				t.collider.hit = false;
				t.collider.__hit = h;
			}

			if(h) hitObjects.push(t);
		},

		onAfterRender: function() {
			if(mx == -2) return;

			if(!options.all && hitObjects.length > 0) {
				hitObjects.sort(sortHitObjects);
				hitObjects[0].collider.hit = hitObjects[0].collider.__hit;
			}
		},

		fromMousePosition: function(camera, projection, mp) {
			var m = SQR.Ray._mt;

			var lx = mp ? mp.x : mx;
			var ly = mp ? mp.y : my;

			ray.origin.set(lx, ly * -1, 0);
			m.copyFrom(projection).inverse();
			m.transformVector(ray.origin);
			camera.globalMatrix.transformVector(ray.origin);
			ray.direction.sub(ray.origin, camera.globalPosition).norm();
			hitObjects.length = 0;
			return ray;
		}
	}
};

/* --- --- [common/Ray.js] --- --- */

/**
 * @class Ray
 * @memberof SQR
 * 
 * @description A Ray has an origin and a direction. It is for ray casting, mostly to calculate the ray from the mouse and detect 3d rollovers.
 *
 * @params {SQR.V3} origin - origin of the ray
 * @params {SQR.V3} direction - direction of the ray
 *
 */
SQR.Ray = function(o, d) {
	this.origin = o || new SQR.V3();
	this.direction = d || new SQR.V3();
	
	this.localOrigin = new SQR.V3();
	this.localDirection = new SQR.V3();

	if(!SQR.Ray._mt) {
		SQR.Ray._mt = new SQR.Matrix44();
		SQR.Ray._nt = new SQR.Matrix33();
	}
}

SQR.Ray.prototype.makeLocal = function(t) {

	var m = SQR.Ray._mt;
	var n = SQR.Ray._nt;

	m.copyFrom(t.globalMatrix).inverse();
	m.transformVector(this.origin, this.localOrigin);

	n.copyFrom(t.normalMatrix).transpose();
	n.transformVector(this.direction, this.localDirection);
}












/* --- --- [common/Renderer.js] --- --- */

/**
 *	@class Renderer
 *	@memberof SQR
 *
 *	@description Represents the rendering engine
 */
SQR.Renderer = function(c, options, onError) {

	var context;

	context = c && c.setAsCurrent ? c : SQR.Context(c, options, onError);

	var r = {
		currentTime: 0,
		deltaTime: 0,
		autoClear: true,
		context: context
	};
	
	var renderObjects = [], transparentObjects = [];
	var startTime, time;

	var updateTransform = function(t, camera, options) {

		if(!t.active) return;

		if(!t.__transformed) {
			t.transformWorld();
			t.__transformed = false;
		} 

		t.transformView(camera ? camera.inverseWorldMatrix : null);

		if(t.clip) t.clip.update(t, time, r.deltaTime);
		if(options.pointer3d) options.pointer3d.onTransform(t);
		
		if (t.numChildren > 0) {
			for (var i = 0; i < t.numChildren; i++) {
				updateTransform(t.children[i], camera, options);
			}
		}

		if(t.buffer && t.shader) {
			if(t.transparent) transparentObjects.push(t);
			else renderObjects.push(t);
		}
		
	}

	var lastBuffer, lastShader, shaderChanged, bufferChanged;
	var defOpts = {};
	var camrig = [];

	var setCommonUniforms = function(camera, lastShader) {
		if(camera) lastShader.setUniform('uEyePosition', camera.globalPosition);

		var p = (camera && camera.projection) ? camera.projection : r.projection;
		if(p) lastShader.setUniform('uProjection', p).setUniform('uNear', p.near).setUniform('uFar', p.far);

		lastShader.setUniform('uTime', time);
	}

	r.clearColor = function(c, g, b, a) {
		// c is a SQR.Color and we can ignore the rest
		if(c.r != null) {
			if(c.a == undefined) c.a = 1;
			context.gl.clearColor(c.r, c.g, c.b, c.a);
		} else {
			if(a == undefined) a = 1;
			context.gl.clearColor(c, g, b, a);
		}

		context.gl.clear(SQR.gl.COLOR_BUFFER_BIT);
		return r;
	}

	r.render = function(root, camera, options) {
		context.setAsCurrent();
		r.tick();
		r.beforeDraw(camera, options);
		r.update(root, camera, options);
		r.draw(null, camera, options);
		r.afterDraw(options);
	}


	r.tick = function() {
		if(!startTime) startTime = new Date().getTime();
		time = new Date().getTime() - startTime;
		r.deltaTime = time - r.currentTime;
		r.currentTime = time;
		return r;
	}

	r.beforeDraw = function(camera, options) {
		options = options || defOpts;
		if(options.pointer3d) {
			var p = (camera && camera.projection) ? camera.projection : r.projection;
			options.pointer3d.fromMousePosition(camera || root, p);
		}
		return r;
	}

	r.update = function(root, camera, options) {
		options = options || defOpts;

		renderObjects.length = 0;
		transparentObjects.length = 0;
		camrig.length = 0;

		if(camera) {

			var a = camera;
			while(a) {
				camrig.unshift(a);
				a = a.parent;
			}

			for(var i = 0, l = camrig.length; i < l; i++) {
				camrig[i].transformWorld();
				camrig[i].__transformed = true;
			};

			camera.computeInverseMatrix();
		}

		updateTransform(root, camera, options);
		return r;
	}	

	r.draw = function(root, camera, options) {
		var gl = SQR.gl;
		options = options || defOpts;

		if(r.autoClear) context.clear();

		gl.enable(gl.DEPTH_TEST);
		gl.depthMask(true);
		gl.disable(gl.STENCIL_TEST);
		gl.frontFace(gl.CW);
		
		if(options.customGLSetup) {
			options.customGLSetup(gl);
		}

		if(root && root.buffer && root.shader) {
			renderObjects.push(root);
		}

		renderObjects = renderObjects.concat(transparentObjects);

		var objectsToRender = renderObjects.length, ro, 
			lastBuffer = null, 
			lastShader = null,
			transparentRendering = false;
		

		var hasReplacementShader = options && options.replacementShader;

		if(hasReplacementShader) {
			lastShader = options.replacementShader.use().updateTextures();
			setCommonUniforms(camera, lastShader);
		}

		for(var i = 0; i < objectsToRender; i++) {

			shaderChanged = false, bufferChanged = false;

			var ro = renderObjects[i];

			if(ro.transparent) {
				if(!transparentRendering) {
					gl.enable(gl.BLEND);
					transparentRendering = true;
				}
				gl.blendFunc(ro.srcFactor, ro.dstFactor);
			}

			if(lastBuffer != ro.buffer) {
				lastBuffer = ro.buffer;
				lastBuffer.bind();
				bufferChanged = true;
			}

			if((lastShader != ro.shader) && !hasReplacementShader) {
				lastShader = ro.shader.use().updateTextures();
				setCommonUniforms(camera, lastShader);
				shaderChanged = true;
			}

			if(shaderChanged || bufferChanged) {
				lastShader.attribPointers(lastBuffer);
			}

			ro.draw(options);
		}

		gl.disable(gl.BLEND);
		return r;
	}

	r.afterDraw = function(options) {
		options = options || defOpts;
		if(options.pointer3d) options.pointer3d.onAfterRender();
		return r;
	}


	r.renderToScreen = function() {
		var gl = SQR.gl;
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	}

	// Default the clear color to black 
	r.clearColor(0, 0, 0, 1);

	return r;

}

/* --- --- [common/Shader.js] --- --- */

/**
 *	@class Shader
 *	@memberof SQR
 *
 *	@description Represents a GLSL shader. The shader class takes the source GLSL code,
 *	compiles it and extracts all the attributes and uniforms. It also exposes
 *	methods to set the uniform values of this shader.
 *
 *	Please read the {@tutorial basic-setup} tutorial to see how to use a shader  
 *	and the {@tutorial understanding-shaders} tutorial for an in depth discussion on shaders.
 *
 *
 *	@param {string} source - the GLSL source code formatted 
 *	in a way to include both vertex and fragment shaders.
 *
 *	@param {object} options - additional options, not required. Supported options in the code sample below.
 *
 *	@example
{
	// Do not compile 
	// (yes, there is such option, but 99.99% of the time this is not necessary)
	doNotCompile: true,

	// Preprocesor directives. 
	// This object will create 
	// the following directives, attached to both
	// vertex and fragment shaders:
	// #define COLOR_ONLY
	// #define COLOR 1.0 0.0 0.0
	directives: [
	    { name: 'COLOR_ONLY' },
	    { name: 'COLOR', value: '1.0, 0.0, 0.0' }
	]
}
 */
SQR.Shader = function(source, options) {

	var s = {}, program, gl;
	var attributes = {}, attrList = [];
	var uniforms = {}, uniformList = [], uniformTextures = [];

	var parseGLSL = function(s) {

		if(!s) throw "> SQR.Shader.parseGLSL - Shader source code missing";

		var pp = "", pv = options ? options.directives : null;

		if(pv && pv instanceof Array) {
			for(var i = 0; i < pv.length; i++) {
				pp += "#define " + pv[i].name;
				if(pv[i].value) pp += " " + pv[i].value;
				pp += "\n";
			}
		} 

		var vertex = pp, fragment = pp;
		var isVertex = true;

		var ls = s.split("\n");

		for(var i = 0; i < ls.length; i++) {
			var l = ls[i];

			if (l.indexOf("//#include") > -1) {
				var p = l.substring(11), inc;

				if(SQR.GLSL && SQR.GLSL[p]) {
					inc = SQR.GLSL[p];
				} else if(SQR.GLSLInclude && SQR.GLSLInclude[p]) {
					inc = SQR.GLSLInclude[p];
				} else if(options && options.includes) {
					inc = options.includes[p];
				}

				if(!inc) throw "> SQR.Shader.parseGLSL - Include not found: " + p;
				ls[i] = inc;
			}
		}

		var ls = ls.join('\n').split('\n');

		for(var i = 0; i < ls.length; i++) {
			var l = ls[i];
			if(l.indexOf("//#") > -1) {
				if (l.indexOf("//#fragment") > -1) {
					isVertex = false;
				} else if (l.indexOf("//#vertex") > -1) {
					isVertex = true;
				}  
			} else {
				if(l.indexOf("//") > -1) l = l.substring(0, l.indexOf("//"));

				if(l.match(/^([\s\t]*)$/)) continue;

				if(isVertex) {
					vertex += l + "\n";
				} else {
					fragment += l + "\n";
				}
			}
		}

		return { vertex: vertex, fragment: fragment };
	};

	s.compile = function() {
		var sc = parseGLSL(source);
		var gl = SQR.gl;
		var vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, sc.vertex);
        gl.compileShader(vs);
         
        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, sc.fragment);
        gl.compileShader(fs);
         
        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) 
        	throw "> SQR.Shader. Vertex shader compile error: " + gl.getShaderInfoLog(vs);

        if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) 
        	throw "> SQR.Shader. Fragment shader compile error: " + gl.getShaderInfoLog(fs);

        if(!gl.getProgramParameter(program, gl.LINK_STATUS)) 
        	throw "> SQR.Shader. Shader linking error: " + gl.getProgramInfoLog(program);

        return s;
	}

	s.inspect = function() {
		var gl = SQR.gl;
	    var numAttr = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

	    for (var i = 0; i < numAttr; i++) {
	        var a = gl.getActiveAttrib(program, i);
	        a.location = gl.getAttribLocation(program, a.name);
	        attributes[a.name] = a;
	        attrList.push(a);
	    }

	    var numUni = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), id = 0;

	    for (var i = 0; i < numUni; i++) {
	        var u = gl.getActiveUniform(program, i);
	        

	        if(u.type == gl.SAMPLER_2D || u.type == gl.SAMPLER_CUBE) {
	        	u.texId = id++;
	        	uniformTextures.push(u);
	        }

	        // Special case for arrays
	        if(u.name.indexOf('[') > -1) {
	        	var n = u.name.substring(0, u.name.indexOf('['));

	        	for(var j = 1; j < u.size; j++) {
	        		var ni = n + '[' + j + ']';
	        		var ui = {
	        			name: ni,
	        			location: gl.getUniformLocation(program, ni),
	        			type: u.type
	        		}

	        		uniforms[ui.name] = ui;
	        		uniformList.push(ui);
	        	}
	        }

	        u.location = gl.getUniformLocation(program, u.name);

	        uniforms[u.name] = u;
	        uniformList.push(u);
	    }

	    return s;
	}

	var stringType = 'string';

	s.getUniform = function(name) {
		return uniforms[name];
	}

	/**
	 *	@method hasUniform
	 *	@memberof SQR.Shader.prototype
	 *
	 *	@returns {Object} true if the shader has a uniform that has this name, null otherwise. The object returned has 3 properties: name, location, type.	
	 */
	s.hasUniform = function(name) {
		return uniforms[name] != null;
	}

	/**
	 *	@method setUniform
	 *	@memberof SQR.Shader.prototype
	 *
	 *	@description using setUniform is recommended for uniforms that do not change much or unifors that have the same
	 *	value for all the objects rendered with this shader. If you need to as uniforms that are different per object 
	 *	(ex. a 100 balls rendered with the same shader, but each with a different color) then it is better to use the 
	 *	<code>uniforms</code> object attached to each instance od <code>SQR.Transform</code>. 
	 *	Please refer to the {@tutorial understanding-shaders} for more info.
	 *
	 *	@param {string} uniform The name of the uniform. 
	 *	By convection all uniforms in SQR start with a lowercas u and the a capitalized/camelcase name follows.
	 *	Example of good uniform names: <code>uIntensity, uLightColor</code>. Not good: <code>uintensity, color</code>.
	 *
	 *	@param value the value of the uniform to set. It will expect a different object depending on the type of the uniform, 
	 *	but there are a few rules as shown in the example below.
	 *
	 *	@example
var sh = SQR.Shader(glslCodeString); 
// glslCodeString = the code loaded from a file or wherever you get it from

// ALWAYS DO THIS FIRST!
sh.use();

// for floats/ints just a number is ok
sh.setUniform('uSpeed', 2); 

// ... but a one element array will do too
sh.setUniform('uIntensity', [0.2]); 

// for vectors, regular Array or Float32Array is ok
sh.setUniform('uDirection', [0.2, 0.5, 0.3]);

// for matrices, pass in the data property of any Matrix class
sh.setUniform('uBoneMatrix', boneMatrix.data);

// textures expect an instance of SQR.Texture or SQR.Cubemap
sh.setUniform('uNormalMap', SQR.Texture('assets/normalMap.jpg'));

// in all the above cases any object that has a method called 'toUniform' works too
// SQR.V2, SQR.V3 and SQR.Color have that, so:
sh.setUniform('uCenter', new SQR.V3(12, 45, 33));
sh.setUniform('uColor', SQR.Color().fromHex('#ff8000'));

// or, assuming that light is an SQR.Transform:
sh.setUniform('uLighPosition', light.position)

	 */
	s.setUniform = function(uniform, value) {
		var gl = SQR.gl;
		var n = (typeof uniform == stringType) ? uniforms[uniform] : uniform;
		var v = value;

		if(!n) {

			var f = uniforms[uniform + '[0]'];

			if(f) {
				for(var i = 0; i < f.size; i++) {
					if(value[i]) s.setUniform(uniform + '[' + i + ']', value[i]);
				}
				return;
			}

			if(SQR.WARN_UNIFORM_NOT_PRESENT) {
				console.warn("> SQR.Shader attempt to set uniform that does not exist: " + uniform);
				console.trace();
			}
			return s;
		}

		if(v && v.toUniform) v = v.toUniform(n.type);

		switch (n.type) {
			case gl.BYTE:
				gl.uniform1i(n.location, v);
				break;
			case gl.UNSIGNED_BYTE:
				gl.uniform1i(n.location, v);
				break;
			case gl.SHORT:
				gl.uniform1i(n.location, v);
				break;
			case gl.UNSIGNED_SHORT:
				gl.uniform1i(n.location, v);
				break;
			case gl.INT:
				gl.uniform1i(n.location, v);
				break;
			case gl.INT_VEC2:
				gl.uniform2iv(n.location, v);
				break;
			case gl.INT_VEC3:
				gl.uniform3iv(n.location, v);
				break;
			case gl.INT_VEC4:
				gl.uniform4iv(n.location, v);
				break;
			case gl.UNSIGNED_INT:
				gl.uniform1i(n.location, v);
				break;
			case gl.FLOAT:
				gl.uniform1f(n.location, v);
				break;
			case gl.FLOAT_VEC2:
				gl.uniform2fv(n.location, v);
				break;
			case gl.FLOAT_VEC3:
				gl.uniform3fv(n.location, v);
				break;
			case gl.FLOAT_VEC4:
				gl.uniform4fv(n.location, v);
				break;
			case gl.BOOL:
				gl.uniform1i(n.location, v);
				break;
			case gl.BOOL_VEC2:
				gl.uniform2iv(n.location, v);
				break;
			case gl.BOOL_VEC3:
				gl.uniform3iv(n.location, v);
				break;
			case gl.BOOL_VEC4:
				gl.uniform4iv(n.location, v);
				break;
			case gl.FLOAT_MAT2:
				gl.uniformMatrix2fv(n.location, false, v.data || v);
				break;
			case gl.FLOAT_MAT3:
				gl.uniformMatrix3fv(n.location, false, v.data || v);
				break;
			case gl.FLOAT_MAT4:
				gl.uniformMatrix4fv(n.location, false, v.data || v);
				break;
			case gl.SAMPLER_2D:
				setTexture(n, v);
				break;
			case gl.SAMPLER_CUBE:
				setTextureCube(n, v);
				break;
			default:
				console.warn("> SQR.Shader > WARNING! Unknown uniform type ( 0x" + n.type.toString(16) + " )");
				break;
		}

		return s;
	}

	var setTexture = function(uniform, texture) {
		var gl = SQR.gl, id = uniform.texId;
		uniform.texref = texture;
	    gl.activeTexture(gl.TEXTURE0 + id); // 33984

	    if(texture) {
			gl.bindTexture(gl.TEXTURE_2D, texture.tex || texture);
			if(texture.isAnimated) texture.update();
		} else {
			gl.bindTexture(gl.TEXTURE_2D, null);
		}

		gl.uniform1i(uniform.location, id);
	}

	var setTextureCube = function(uniform, texture) {
		var gl = SQR.gl, id = uniform.texId;
		uniform.texref = texture;
	    gl.activeTexture(gl.TEXTURE0 + id);
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture.tex || texture);
		gl.uniform1i(uniform.location, id);
	}

	s.updateTextures = function() {
		var gl = SQR.gl;
		for(var i = 0, tl = uniformTextures.length; i < tl; i++) {
			var t = uniformTextures[i];
			if(t.texref) s.setUniform(t, t.texref);
		}
		return s;
	}

	/**
	 *	@method use
	 *	@memberof SQR.Shader.prototype
	 *
	 *	@description Sets this shader as the current program in GL. This function needs to be called before any uniforms are set.
	 */
	s.use = function() {
		SQR.gl.useProgram(program);
		return s;
	}

	s.attribPointers = function(geo) {
		var gl = SQR.gl, al = attrList.length;
		geo = geo.buffer || geo;
		for(var i = 0; i < al; i++) {
			var a = attrList[i];
		 	var ga = geo.attributes[a.name];
		 	if(!ga) throw "> SQR.Shader expects attribute " + a.name + " but geometry doesn't provide it";
		 	if(!a.enabled) gl.enableVertexAttribArray(a.location);
			gl.vertexAttribPointer(a.location, ga.size, gl.FLOAT, false, geo.strideByteSize, ga.byteOffset);
			a.enabled = true;
		}
		return s;
	}


	if(!options || !options.doNotCompile) {
		s.compile();
		s.inspect();
	}

	return s;

}

/* --- --- [common/Texture.js] --- --- */

/**
 *  @class Texture
 *  @memberof SQR
 *
 *  @description Represents a WebGL texture created from an Image, Video or Canvas element.
 */
SQR.Texture = function(_source, _options) {

	var t = {};
	var gl = SQR.gl;
	var source, options = _options || {};

	t.setSource = function(_source, _options) {
		
		if(!(_source instanceof HTMLVideoElement || _source instanceof Image || _source instanceof HTMLCanvasElement)) {
			console.error('Invalid source: ' + _source);
			throw 'SQR.Texture > provided source is not a valid source for texture';
		}

		source = _source;
		options = _options || options;
		
		var wrapS = options.wrapS || options.wrap;
		var wrapT = options.wrapT || options.wrap;

		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flip !== undefined ? options.flip : true);
		gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha !== undefined ? options.premultiplyAlpha : false);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);

		var mif, mgf;

		if(isPowerOfTwo()) {
			if(options.mipmap) gl.generateMipmap(gl.TEXTURE_2D);
			mif = options.mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;
			mgf = gl.LINEAR;
			// if(!wrapS) wrapS = gl.REPEAT;
			// if(!wrapT) wrapT = gl.REPEAT;
		} else {
			if(options.mipmap) console.warn('Only power-of-2 texture can use mipmaps\n', _source);
			mif = mgf = gl.LINEAR;
			// if(!wrapS) wrapS = gl.CLAMP_TO_EDGE;
			// if(!wrapT) wrapT = gl.CLAMP_TO_EDGE;
		}

		if(!wrapS) wrapS = gl.CLAMP_TO_EDGE;
		if(!wrapT) wrapT = gl.CLAMP_TO_EDGE;

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.magFilter || options.filter || mgf);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.minFilter || options.filter || mif);

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
		gl.bindTexture(gl.TEXTURE_2D, null);

		t.isAnimated = (options && options.isAnimated) || (_source instanceof HTMLVideoElement);
		return t;
	}

	var isPowerOfTwo = function() {
		var x = source.width, y = source.height;
		return x > 0 && y > 0 && (x & (x - 1)) == 0 && (y & (y - 1)) == 0;
	}

	t.getSource = function() {
		return source;
	}

	t.update = function() {
		var gl = SQR.gl;
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
		return t;
	}

	t.destroy = function() {
		gl.deleteTexture(t.tex);
	}

	var texture = gl.createTexture();
	t.tex = texture;

	if(_source) {
		t.setSource(_source, _options);
	}

	return t;

}

/* --- --- [common/Transform.js] --- --- */

/**
 *  @class Transform
 *  @memberof SQR
 *
 *  @description A transform is a basic building block for 3D scenes made with squareroot.js
 * 
 *  @param name {string} the name of the transform.
 */
SQR.Transform = function(name, uid) {

	if(!(this instanceof SQR.Transform)) return new SQR.Transform(name, uid);

	var t = this;

	t._transformState = 0;

	t.uid = uid;

	/**
	 *  @var {string} name - a unique name of this transform, useful for debugging
	 *  @memberof SQR.Transform.prototype
	 *  @default `sqr.transform.` + a counter (ex. `sqr.transform.29)
	 */
	t.name = name || 'sqr.transform.' + SQR.TransformCount++;

	/** 
	 *  @var {boolean} active - is set to false, the transform and 
	 *  all it's children will not be rendered.
	 *  @memberof SQR.Transform.prototype
	 *  @default false
	 */
	t.active = true;

	/**
	 *  @var {boolean} directMatrixMode - if set to true, position, rotation/quaternion and scale will be ignored
	 *  @memberof SQR.Transform.prototype
	 *
	 *  @description When set to true matrix value inside @this.matrix can be manipulated directly.
	 *
	 *  @default false
	 */
	t.directMatrixMode = false;
	

	/** 
	 *  @var {SQR.Matrix44} matrix - object-to-parent transformation matrix
	 *  @memberof SQR.Transform.prototype
	 */
	t.matrix = new SQR.Matrix44();
	
	/** 
	 *  @var {SQR.V3} position - the position of this transform relative to it's parent
	 *  @memberof SQR.Transform.prototype
	 */
	t.position = new SQR.V3();

	/** 
	 *  @readonly 
	 *  @var {SQR.V3} globalPosition - the global position of this transform (set automatically)
	 *  @memberof SQR.Transform.prototype
	 */
	t.globalPosition = new SQR.V3();

	/** 
	 *  @readonly 
	 *  @var {SQR.V3} forward - the forward vector 
	 *  @memberof SQR.Transform.prototype
	 */
	t.forward = new SQR.V3();

	/**
	 *  @var {SQR.Quaternion} quaternion - A Quaternion that describes the rotation of the transform, 
	 *  only active if `useQuaternion` is set to true.
	 *  @memberof SQR.Transform.prototype
	 */
	t.quaternion = new SQR.Quaternion();

	/**
	 *  @var {SQR.V3} rotation - A 3D vector the describes the rotation of the transform in Euler angles, 
	 *  disabled if `useQuaternion` is set to true.
	 *  @memberof SQR.Transform.prototype
	 */
	t.rotation = new SQR.V3();

	/**
	 *  @var {SQR.V3} scale - the scale of the object on x, y and z axis
	 *  @memberof SQR.Transform.prototype
	 */
	t.scale = new SQR.V3(1, 1, 1);

	/**
	 *  @var {SQR.Quaternion} useQuaternion - if set to true, 
	 *  will use `quaternion` for rotation instead of the Euler angles in `rotation`
	 *  @memberof SQR.Transform.prototype
	 *  @default false
	 */
	t.useQuaternion = false;

	/**
	 *  @var {boolean} isStatic
	 *  @description Any object can have two different positioning modes: dynamic or static.
	 *  If this value is set to false (dynamic) the matrices 
	 *  for this object will be recalculated at each frame.<br>
	 *  If this value is set to true (static) the matrices for 
	 *  this object will be recalculated only once.
	 *  @memberof SQR.Transform.prototype
	 *  @default false
	 */
	t.isStatic = false;

	
	t.normalMatrix = new SQR.Matrix33();
	t.globalMatrix = new SQR.Matrix44();
	t.viewMatrix = new SQR.Matrix44();
	t.inverseWorldMatrix;

	t.boneMatrix = new SQR.Matrix44();
	t.poseMatrix = new SQR.Matrix44();
	t.inversePoseMatrix = new SQR.Matrix44();

	t.lookAt = null;

	t.transparent = false;
	t.srcFactor = null;
	t.dstFactor = null;
	t.useDepth = true;
	t.depthMask = true;
	t.lineWidth = 1;

	t.children = [], t.numChildren = 0;

}

SQR.Transform.prototype.setAsBoneRoot = function() {
	this.computePoseMatrix();
}

SQR.Transform.prototype.computePoseMatrix = function() {

	var t = this;

	t.bone = true;
	t.transformWorld();

	if(!(t.parent && t.parent.bone)) {
		t.matrix.copyTo(t.poseMatrix);
	} else {
		t.parent.poseMatrix.copyTo(t.poseMatrix);
		t.poseMatrix.multiply(t.matrix);
	}

	for(var i = 0; i < t.numChildren; i++) {
		var c = t.children[i];
		c.computePoseMatrix();
	}

	t.poseMatrix.inverse(t.inversePoseMatrix);

	return t;
}

SQR.Transform.prototype.setBlending = function(transparent, src, dst) {
	this.transparent = transparent;
	// By default blend the object on top with the object on the bottom
	this.srcFactor = src || SQR.gl.SRC_ALPHA;
	this.dstFactor = dst || SQR.gl.ONE_MINUS_SRC_ALPHA;
} 



/**
*   @method add
*   @memberof SQR.Transform.prototype
*   
*   @description Add a child transform. Accepts multiple arguments but all of them need to be of type {SQR.Transform}.
*   It doesn't do any sort of type checking so if you add non object that are not {SQR.Transform} 
*   it will result in errors when the scene is rendered.
*/
SQR.Transform.prototype.add = function() {
	var t = this;
	for (var i = 0; i < arguments.length; i++) {
		var c = arguments[i];

		if(c.parent) { c.parent.remove(c); }
		if(c.onAdd) c.onAdd(t);

		c.parent = t;
		if (t.children.indexOf(c) == -1) t.children.push(c);
	}
	t.numChildren = t.children.length;
	return t;
}

/**
 *  @method remove
 *  @memberof SQR.Transform.prototype
 *   
 *  @description Removes a child transform. Accepts multiple arguments 
 *  but all of them need to be of type {SQR.Transform}
 */
SQR.Transform.prototype.remove = function() {
	var t = this;
	for (var i = 0; i < arguments.length; i++) {
		var c = arguments[i];
		var j = t.children.indexOf(c);
		if (j == -1) continue;
		c.parent = null;
		t.children.splice(j, 1);
		if(c.onRemove) c.onRemove(t);
	}
	t.numChildren = t.children.length;
	return t;
}

/**
 *  @method removeAll
 *  @memberof SQR.Transform.prototype
 *   
 *  @description Removes all children transform.
 */
SQR.Transform.prototype.removeAll = function() {
	this.children.length = 0;
	this.numChildren = 0;
}

/**
 *  @method contains
 *  @memberof SQR.Transform.prototype
 *   
 *  @description Checks if transform is child of this transfom
 *  @param {SQR.Transform} c the transform to look for
 */
SQR.Transform.prototype.contains = function(c) {
	return this.children.indexOf(c) > -1;
}

/**
 *  @method recurse
 *  @memberof SQR.Transform.prototype
 *   
 *  @description Execute this function on all the child transforms.
 *
 *  @param {function} f the function that will be called on each child. 
 *  This function will receive the transform as argument.
 *
 *  @param {boolean} excludeSelf if set to true, the function will only be called for all 
 *  the ancestors of the Transform, not on the transform itself.
 */
SQR.Transform.prototype.recurse = function(f, excludeSelf) {
   if(!excludeSelf) f(this);
	for (var i = 0; i < this.numChildren; i++) {
		this.children[i].recurse(f);
	}
}

SQR.Transform.prototype.findByName = function(name) {
	var found;
	this.recurse(function(c) {
		if(c.name == name) {
			found = c;
			return null;
		}
	});
	return found;
}

SQR.Transform.prototype.findById = function(id) {
	var found;
	this.recurse(function(c) {
		if(c.uid && c.uid == id) {
			found = c;
			return null;
		}
	});
	return found;
}

SQR.Transform.prototype.findByPath = function(path) {
	var p = path.split('/');
	var c = this;
	while(pp = p.shift()) {
		if(!c) return;
		c = c.findByName(pp);
	}
	return c;
}

SQR.Transform.prototype.draw = function(options) {
	var t = this;

	var isReplacementShader = options && options.replacementShader;
	var shader = isReplacementShader ? options.replacementShader : t.shader;

	shader.setUniform('uMatrix', t.globalMatrix);
	shader.setUniform('uViewMatrix', t.viewMatrix);
	shader.setUniform('uNormalMatrix', t.normalMatrix);

	if(!isReplacementShader && shader.uniforms) {
		var un = Object.keys(shader.uniforms);
		for(var i = 0, l = un.length; i < l; i++) {
			shader.setUniform(un[i], shader.uniforms[un[i]]);
		}
	}

	if(!isReplacementShader && t.uniforms) {
		var un = Object.keys(t.uniforms);
		for(var i = 0, l = un.length; i < l; i++) {
			shader.setUniform(un[i], t.uniforms[un[i]]);
		}
	}

	// This works, but this is much better:
	// http://stackoverflow.com/questions/2859722/opengl-how-can-i-put-the-skybox-in-the-infinity (implement globally)
	var gl = SQR.gl;

	// gl.depthMask(t.useDepth);
	t.useDepth ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST);

	gl.depthMask(t.depthMask);

	gl.lineWidth(t.lineWidth);
	t.buffer.draw(this);
	if(t.afterDraw) t.afterDraw();
}

/**
 * Sets up the local matrix and multiplies is by the parents globalMatrix.
 * This function is called in the rendering process, do not call directly.
 */
SQR.Transform.prototype.transformWorld = function() {
	var t = this;

	if(t._transformState == 1) return;

	if(!t.directMatrixMode) {
		var p = t.position;
		var s = t.scale;
		
		if (t.useQuaternion) {
			var q = t.quaternion;
			t.matrix.setTQS(p.x, p.y, p.z, q.w, q.x, q.y, q.z, s.x, s.y, s.z);
		} else {
			var r = t.rotation;
			t.matrix.setTRS(p.x, p.y, p.z, r.x, r.y, r.z, s.x, s.y, s.z);
		}
	}

	if(t.lookAt) {
		t.matrix.lookAt(t.lookAt.position);
		// Look at erases scale so let's put that back in
		t.matrix.scale(s.x, s.y, s.z);
	}

	if (t.parent) {
		t.parent.globalMatrix.copyTo(t.globalMatrix);
		t.globalMatrix.multiply(t.matrix);

		if(t.bone) {
			t.parent.boneMatrix.copyTo(t.boneMatrix);
			t.boneMatrix.multiply(t.matrix);
		}

	} else {
		t.matrix.copyTo(t.globalMatrix);
		if(t.bone) t.matrix.copyTo(t.boneMatrix);
	}

	var g = t.globalMatrix;

	g.extractPosition(t.globalPosition);
	t.forward.set(g.data[8], g.data[9], g.data[10]);

	if(t.isStatic) t._transformState = 1;
	if(t.beforeDraw) t.beforeDraw(t);
}

/** 
 *  Used for sorting objects in the rendering function
 *  (not implemented yet)
 */
SQR.Transform.prototype.viewDepth = function() {
	return this.viewMatrix.data[14];
}

/**
 * Calculate the view matrix.
 *
 * This function is called in the rendering process, do not call directly.
 *
 * @param inverseCamMatrix {SQR.Matrix44} the inverse matrix of the camera
 */
SQR.Transform.prototype.transformView = function(inverseCamMatrix) {
	var t = this;
	if(inverseCamMatrix) {
		inverseCamMatrix.copyTo(t.viewMatrix);
		t.viewMatrix.multiply(t.globalMatrix);

		// it used to be viewMatrix instead, but this was (probably) wrong
		t.globalMatrix.inverseMat3(t.normalMatrix);

	} else {
		t.globalMatrix.copyTo(t.viewMatrix);
		t.globalMatrix.inverseMat3(t.normalMatrix);
	}
	
}

/**
 * Calculate the camera inverse matrix.
 *
 * Used only if this transform is a camera.
 *
 * This function is called in the rendering process, do not call directly.
 */
SQR.Transform.prototype.computeInverseMatrix = function() {
	var t = this;
	if(!t.inverseWorldMatrix) {
		t.inverseWorldMatrix = new SQR.Matrix44();
	}
	t.globalMatrix.inverse(t.inverseWorldMatrix);
	return t.inverseWorldMatrix;
}

SQR.Transform.prototype.computeBoneMatrix = function() {
	var t = this;
	t.boneMatrix.multiply(t.inversePoseMatrix);
	return t.boneMatrix;
}


SQR.TransformCount = 0;








/* --- --- [math/Bezier.js] --- --- */

/**
 *  @class Bezier
 *  @memberof SQR
 *
 *  @description Represents a cubic bezier curve. All paramaters can be either {@link SQR.V3} or {@link SQR.V2}.
 *
 *  @param _p0 start position
 *  @param _c0 first control point
 *  @param _c1 last control point
 *  @param _c1 end position
 *
 */
SQR.Bezier = function(_p0, _c0, _c1, _p1) {

    var that = this;

    /**
     *  @var p0 
     *  @memberof SQR.Bezier.prototype
     *  @descripton The start position, can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.p0 = _p0;

    /**
     *  @var c0 
     *  @memberof SQR.Bezier.prototype
     *  @descripton First control point. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.c0 = _c0;

    /**
     *  @var c1 
     *  @memberof SQR.Bezier.prototype
     *  @descripton Second control point. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.c1 = _c1;

    /**
     *  @var p1 
     *  @memberof SQR.Bezier.prototype
     *  @descripton End position. Can be either {@link SQR.V3} or {@link SQR.V2}.
     */
    this.p1 = _p1;

    var interpolatedValue, interpolatedVelocity, interpolatedMatrix;

    var pfunc = SQR.Interpolation.bezierPosition;
    var vfunc = SQR.Interpolation.bezierVelocity;

    /**
     *  @method velocityAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the velocity on a curve. 
     *  @param t interpolation value [0-1]
     *  @param v vector to write the value to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.velocityAt = function(t, v) {
        interpolatedVelocity = interpolatedVelocity || this.p0.clone().set();
        v = v || interpolatedVelocity;
        v.x = vfunc(t, this.p0.x, this.c0.x, this.c1.x, this.p1.x);
        v.y = vfunc(t, this.p0.y, this.c0.y, this.c1.y, this.p1.y);

        if(v.z !== null && this.p0.z !== null) {
            v.z = vfunc(t, this.p0.z, this.c0.z, this.c1.z, this.p1.z);
        }

        return v;
    }

    /**
     *  @method valueAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the position on a curve.
     *  @param t interpolation value [0-1]
     *  @param v vector to write the value to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.valueAt = function(t, v) {
        interpolatedValue = interpolatedValue || this.p0.clone().set();
        v = v || interpolatedValue;
        v.x = pfunc(t, this.p0.x, this.c0.x, this.c1.x, this.p1.x);
        v.y = pfunc(t, this.p0.y, this.c0.y, this.c1.y, this.p1.y);

        if(v.z !== null && this.p0.z !== null) {
            v.z = pfunc(t, this.p0.z, this.c0.z, this.c1.z, this.p1.z);
        }
        
        return v;
    }

    /** 
     *  @method matrixAt 
     *  @memberof SQR.Bezier.prototype
     *  @description Returns the transformation matrix that can be used to align an object to the curve at a given point.
     *  Not tested in 2D but shoud work fine.
     *  @param t interpolation value [0-1]
     *  @param m {@link SQR.Matrix44} to write the matrix to. If omitted, returns a temporary value, that will be overwritten on next call so do not store this object.
     */
    this.matrixAt = function(t, m) {
        interpolatedMatrix = interpolatedMatrix || new SQR.Matrix44();
        m = m || interpolatedMatrix;
        m.identity();

        var va = that.valueAt(t);
        var vc = that.velocityAt(t).norm();
        var vl = SQR.V3.__tv1.set().cross(vc, SQR.V3.up);//.norm();
        var vn = SQR.V3.__tv2.set().cross(vc, vl);//.norm()

        m.data[0] = vl.x, m.data[4] = vn.x, m.data[8] = vc.x;
        m.data[1] = vl.y, m.data[5] = vn.y, m.data[9] = vc.y;
        m.data[2] = vl.z, m.data[6] = vn.z, m.data[10] = vc.z;
        m.setTranslation(va.x, va.y, va.z);

        return m;
    }
}













/* --- --- [math/Color.js] --- --- */

/**
 *  @class Color
 *  @memberof SQR
 *
 *  @descrption represents an RGB color. This class works with float values, 
 *	so all the color components are in range of 0-1, not 0-255.
 *
 *	@param {Number=} r the red component of the color
 *	@param {Number=} g the green component of the color
 *	@param {Number=} b the blue component of the color
 *	@param {Number=} a the transparency (alpha) component of the color
 *
 */
SQR.Color = function(r, g, b, a) {
	if(!(this instanceof SQR.Color)) return new SQR.Color(r, g, b, a);
	
	if(typeof(r) == 'string') {
		this.setHex(r);
		this.a = (g == undefined) ? 1 : g; // if r is a hex color code, the next argument will be alpha
	} else if(r && r.r != undefined) {
		this.setRGB(r.r, r.g, r.b);

		if(r.a != undefined) this.a = r.a;
		else if(g != undefined) this.a = g;
		else this.a = 1; 

	} else {
		this.setRGB(r, g, b);
		this.a = (a == undefined) ? 1 : a;
	}
}

/**
 *	@method setRGB
 *	@memberof SQR.Color.prototype
 *
 *	@description sets the color component values.
 *
 *	@param {Number=} r the red component of the color
 *	@param {Number=} g the green component of the color
 *	@param {Number=} b the blue component of the color
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.setRGB = function(r, g, b) {
	var c = this;
	c.r = r || 0;
	c.g = g || 0;
	c.b = b || 0;
	return c;
}

/**
 *	@method setHex
 *	@memberof SQR.Color.prototype
 *
 *	@description sets the color component values from a hex string (ex. #a4d278) or number (ex. 0xa4d278) 
 *	Useful when copying color vaues from ex. Photoshop.
 *
 *	@param {string|Number} hex the hex color values as string (ex. #a4d278) or number (ex. 0xa4d278) 
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.setHex = function(hex) {

	var c = this;

	if(typeof(hex) == 'string') {
		hex = (hex.indexOf('#') == 0) ? hex.substring(1) : hex;
		hex = (hex.indexOf('0x') == -1) ? '0x' + hex : hex;
		hex = parseInt(hex);
	}

	c.r = (hex >> 16 & 255 ) / 255;
	c.g = (hex >> 8 & 255) / 255;
	c.b = (hex & 255) / 255;

	return c;
}

/**
 *	@method toCSS
 *	@memberof SQR.Color.prototype
 *
 *	@returns {string} a CSS friendly string representing the color. The format used is <code>rgb(r, g, b)</code>.
 */
SQR.Color.prototype.toCSS = function() {
	var c = this;
	var ri = (c.r * 255) | 0;
	var gi = (c.g * 255) | 0;
	var bi = (c.b * 255) | 0;
	return 'rgb(' + ri + ', ' + gi + ', ' + bi + ')';
}

/**
 *	@method setRGB
 *	@memberof SQR.Color.prototype
 *
 *	@description copies the color component values from another instance of SQR.Color
 *
 *	@param {SQR.Color} oc the color instance to copy from
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.copyFrom = function(oc) {
	var c = this;
	c.r = oc.r;
	c.g = oc.g;
	c.b = oc.b;
	return c;
}

/**
 *	@method lighten
 *	@memberof SQR.Color.prototype
 *
 *	@description <p>modfies the color values to make them darker of lighter in a more fance way than a simple multiplication. 
 *	However this is not currently implemented so for now it really does the same thing as <code>SQR.Color.mul</code>.</p>
 *
 *	<p>Here's <a href='http://stackoverflow.com/questions/141855/programmatically-lighten-a-color'>some info on how to implement this properly</a>.</p>
 */
SQR.Color.prototype.lighten = function(v) {
	return this.mul(v);
}

/**
 *	@method clone
 *	@memberof SQR.Color.prototype
 *
 *	@description creates a copy of the color instance
 *
 *	@returns {Object} a new SQR.Color instance
 */
SQR.Color.prototype.clone = function() {
	return new SQR.Color(c.r, c.g, c.b);
}

/**
 *	@method mul
 *	@memberof SQR.Color.prototype
 *
 *	@description modfies the color values to make it darker of lighter
 *
 *	@param {Number} v the amount by which to change the color (1 will leave it as it, > 1 will lightned, < 1 will darken the color)
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.mul = function(v) {
	var c = this;
	c.r = Math.min(1.0, c.r * v);
	c.g = Math.min(1.0, c.g * v);
	c.b = Math.min(1.0, c.b * v);
	return c;
}

/**
 *	@method lerp
 *	@memberof SQR.Color.prototype
 *
 *	@description performs a linear interpolation between two colors and stores the value in the color instance
 *
 *	@param {SQR.Color} a the first color to use in interpolation
 *	@param {SQR.Color} b the second color to use in interpolation
 *	@param {Number} t the interpolation value [0-1]
 *
 *	@returns {Object} reference to this SQR.Color instance, for chaining
 */
SQR.Color.prototype.lerp  = function(a, b, t) {
	var c = this;
	var m = 1 - t;
	c.r = a.r * m + b.r * t;
	c.g = a.g * m + b.g * t;
	c.b = a.b * m + b.b * t;
	return c;
}

SQR.Color.prototype.toUniform = function(type) {

	var alpha = type == SQR.gl.FLOAT_VEC4;

	var c = this;
	if(!c._array) c._array = new Float32Array(alpha ? 4 : 3);
	c._array[0] = c.r;
	c._array[1] = c.g;
	c._array[2] = c.b; 
	if(alpha) c._array[3] = c.a;
	return c._array;
}








/* --- --- [math/Delaunay.js] --- --- */

/**
 *  
 *	@class Delaunay
 *  @memberof SQR
 *
 *  @description based on:<br> 
 *  
 *  {@link http://paulbourke.net/papers/triangulate/}<br>
 *  {@link http://www.travellermap.com/tmp/delaunay.htm} (original code)<br> 
 *  {@link https://github.com/ironwallaby/delaunay/blob/master/delaunay.js}<br> 
 *  {@link http://www.amazon.com/Computational-Geometry-Applications-Mark-Berg/dp/3642096816}
*/
SQR.Delaunay = (function() {

	var delaunay = {};

	var Edge = function(v0, v1) {
		this.v0 = v0;
		this.v1 = v1;
	}

	Edge.prototype.equals = function(other) {
		return (this.v0 === other.v0 && this.v1 === other.v1);
	};

	Edge.prototype.inverse = function() {
		return new Edge(this.v1, this.v0);
	};

	var createSuperTriangle = function(vertices) {
		// NOTE: There's a bit of a heuristic here. If the bounding triangle 
		// is too large and you see overflow/underflow errors. If it is too small 
		// you end up with a non-convex hull.

		var minx, miny, maxx, maxy;
		vertices.forEach(function(vertex) {
			if (minx === undefined || vertex.x < minx) { minx = vertex.x; }
			if (miny === undefined || vertex.y < miny) { miny = vertex.y; }
			if (maxx === undefined || vertex.x > maxx) { maxx = vertex.x; }
			if (maxy === undefined || vertex.y > maxy) { maxy = vertex.y; }
		});

		var dx = (maxx - minx) * 10;
		var dy = (maxy - miny) * 10;

		var stv0 = vertices[0].clone().set(minx - dx, miny - dy * 3);
		var stv1 = vertices[0].clone().set(minx - dx, maxy + dy);
		var stv2 = vertices[0].clone().set(maxx + dx * 3, maxy + dy);

		return new SQR.Triangle(stv0, stv1, stv2);
	}

	function addVertex(vertex, triangles) {
		var edges = [];

		triangles = triangles.filter(function(triangle) {
			if (triangle.vertexInCircumcircle(vertex)) {
				edges.push(new Edge(triangle.v0, triangle.v1));
				edges.push(new Edge(triangle.v1, triangle.v2));
				edges.push(new Edge(triangle.v2, triangle.v0));
				return false;
			}

			return true;
		});

		edges = uniqueEdges(edges);

		edges.forEach(function(edge) {
			triangles.push(new SQR.Triangle(edge.v0, edge.v1, vertex));
		});

		return triangles;
	}

	var uniqueEdges = function(edges) {
		var uniqueEdges = [];

		for (var i = 0; i < edges.length; ++i) {
			var edge1 = edges[i];
			var unique = true;

			for (var j = 0; j < edges.length; ++j) {
				if (i === j) continue;
				var edge2 = edges[j];
				if (edge1.equals(edge2) || edge1.inverse().equals(edge2)) {
					unique = false;
					break;
				}
			}

			if (unique) uniqueEdges.push(edge1);
		}

		return uniqueEdges;
	}

	/**
	 *	@method triangulate
	 *	@memberof SQR.Delaunay
	 *
	 *	@description Performs Delaunay triangulation.
	 *
	 *	@param vertices - a list of 2d vertices. 
	 *	Can be {@link SQR.V2}, {@link SQR.V3} or any object that has `x` and `y` properties. 
	 *	In case of a 3d vector, the `z` component is ignored.
	 *	@returns a list of {@link SQR.Triangles}
	 */
	delaunay.triangulate = function(vertices) {
		var triangles = [];

		var st = createSuperTriangle(vertices);

		triangles.push(st);

		vertices.forEach(function(vertex) {
			// NOTE: This is O(n^2) - can be optimized by sorting vertices
			// along the x-axis and only considering triangles that have 
			// potentially overlapping circumcircles
			triangles = addVertex(vertex, triangles);
		});

		// Remove triangles that shared edges with "supertriangle"
		triangles = triangles.filter(function(triangle) {
			return !(triangle.v0 == st.v0 || triangle.v0 == st.v1 || triangle.v0 == st.v2 ||
			triangle.v1 == st.v0 || triangle.v1 == st.v1 || triangle.v1 == st.v2 ||
			triangle.v2 == st.v0 || triangle.v2 == st.v1 || triangle.v2 == st.v2);
		});

		return triangles;
	}

	return delaunay;

})();

/* --- --- [math/Interpolation.js] --- --- */

/**
 *  @namespace Interpolation
 *  @memberof SQR
 *
 *  @description A collection of interpolation functions.
 */
SQR.Interpolation = {

    /**
     *  Returns the position on a curve for a position (per axis)
     *  @param {Number} t interpolation value [0-1]
     *  @param {Number} p0 start position
     *  @param {Number} c0 first control point
     *  @param {Number} c1 second control point
     *  @param {Number} p1 end position
     */
    bezierPosition: function(t, p0, c0, c1, p1) {
        return p0 * (1 - t) * (1 - t) * (1 - t) +
            c0 * 3 * t * (1 - t) * (1 - t) +
            c1 * 3 * t * t * (1 - t) +
            p1 * t * t * t;
    },

    /**
     *  Returns the velocity on the curve for a position (per axis)
     *  @param {Number} t interpolation value [0-1]
     *  @param {Number} p0 start position
     *  @param {Number} c0 first control point
     *  @param {Number} c1 second control point
     *  @param {Number} p1 end position
     */
    bezierVelocity: function(t, p0, c0, c1, p1) {
        return (3 * c0 - 3 * p0)
            + 2 * (3 * p0 - 6 * c0 + 3 * c1) * t
            + 3 * (-p0 + 3 * c0 - 3 * c1 + p1) * t * t;
    },

    /**
     *  Linear interpolation a between two values
     *  @param {Number} e0 start value
     *  @param {Number} e1 end value
     *  @param {Number} t interpolation value [0-1]
     */
    linear: function(e0, e1, t) {
        if(t <= e0) return e0;
        if(t >= e1) return e1;

        t = (t - e0) / (e1 - e0);

        return e0 + (e1 - e0) * t;
    },
    
    /**
     *  Smoothstep interpolation a between two values
     *  @param {Number} t interpolation value [0-1]
     */
    smoothStep: function(t) {
        return (3 * t * t - 2 * t * t * t);
    },

    /**
     *  Quadratic ease in based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadIn: function (t) {
        return t * t;
    },

    /**
     *  Quadratic ease out based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadOut: function (t) {
        return t * (2 - t);
    },

    /**
     *  Quadratic ease in-out based on Penner equations
     *  @param {Number} t interpolation value [0-1]
     */
    quadInOut: function (t) {
        if (( t *= 2 ) < 1)
            return 0.5 * t * t;
        else
            return -0.5 * ( --t * ( t - 2 ) - 1 );
    }

};

/* --- --- [math/Intersection.js] --- --- */

/**
 * @namespace Intersection
 * @memberof SQR
 * 
 * @description Utility to perform intersection tests of rays against colliders. It is a static singleton, no need to instantiate. Just use: SQR.Intersection.rayTest(...)
 */
SQR.Intersection = {};

/**
 * Performs an intersection test of a ray against a transform that has a collider. J3D supports three types of colliders: sphere, box and mesh. This method will check what type of collider the transform has and call the apropriate method to make the intersection tests.
 *
 * WARNING. For meshes that have lots of polys, the ray/mesh intersection test can be very slow! It's better to wrap it into a box or sphere collider or have a simpler version of the mesh to make intersection tests against.
 *
 * @param {SQR.Ray} r an instance of J3D.Ray
 * @param {SQR.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a collider the method returns false.
 */
SQR.Intersection.rayTest = function(r, t) {

	if (!t.collider) {
		console.log("Intersection test failed. " + t.name + " has no collider.");
		return false;
	}

	if (!SQR.Intersection.__tv1) {
		SQR.Intersection.__tv1 = new SQR.V3();
		SQR.Intersection.__tv2 = new SQR.V3();
		SQR.Intersection.__tv3 = new SQR.V3();
		SQR.Intersection.__tv4 = new SQR.V3();
		SQR.Intersection.__tv5 = new SQR.V3();
		SQR.Intersection.__tv6 = new SQR.V3();
		SQR.Intersection.__tv7 = new SQR.V3();
	}

	switch (t.collider.type) {
		case SQR.Collider.SPHERE:
			return SQR.Intersection.raySphere(r, t);
		case SQR.Collider.BOX:
			return SQR.Intersection.rayBox(r, t);
		case SQR.Collider.MESH:
			return SQR.Intersection.rayMesh(r, t);
		default:
			console.log(t.collider);
			throw "> SQR.Intersection > unknown collider type on " + t.name;
			return false;
	}
}

/**
 * Performs an intersection test of a ray against a transform that has a mesh collider.
 *
 * WARNING. For meshes that have lots of polys, the ray/mesh intersection test can be very slow! It's better to wrap it into a box or sphere collider or have a simpler version of the mesh to make intersection tests against.
 *
 * @param {J3D.Ray} r an instance of J3D.Ray
 * @param {J3D.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a geometry the method returns false.
 */
SQR.Intersection.rayMesh = function(r, t) {

	if (t.collider.box) {
		if (!SQR.Intersection.rayBox(r, t)) {
			return false;
		}
	} else {
		r.makeLocal(t);
	}

	var v = t.buffer.getDataArray();
	var d = t.buffer.getIndexArray();
	var op = t.buffer.attributes['aPosition'].offset;

	var c = false;

	var p0 = SQR.Intersection.__tv1;
	var p1 = SQR.Intersection.__tv2;
	var p2 = SQR.Intersection.__tv3;
	

	for (var i = 0; i < d.length; i += 3) {
		var i0 = d[i + 0] * t.buffer.strideSize + op;
		var i1 = d[i + 1] * t.buffer.strideSize + op;
		var i2 = d[i + 2] * t.buffer.strideSize + op;

		p0.set(v[ i0 ], v[ i0 + 1 ], v[ i0 + 2 ]);
		p1.set(v[ i1 ], v[ i1 + 1 ], v[ i1 + 2 ]);
		p2.set(v[ i2 ], v[ i2 + 1 ], v[ i2 + 2 ]);

		c = c || SQR.Intersection.rayTriangle(r, p0, p1, p2);
		if (c) break;
	}

	return c;
}

/**
 * Performs an intersection test of a ray against a single triangle.
 * You should not have to call this method directly, unless you have specific needs, like ex. doing intersection tests for particles.
 */
SQR.Intersection.rayTriangle = function(r, p0, p1, p2, n) {

	var p = SQR.Intersection.__tv4;
	var n = SQR.Intersection.__tv5;

	var t1 = SQR.Intersection.__tv6;
	var t2 = SQR.Intersection.__tv7;

	t1.sub(p0, p1);
	t2.sub(p2, p0);

	n.cross(t1, t2).norm();

	var dot = SQR.V3.dot(n, r.localDirection);
	if (!( dot < 0 )) {
		return false;
	}

	var d = SQR.V3.dot(n, p0);
	var t = d - SQR.V3.dot(n, r.localOrigin);

	if (!( t <= 0 )) {
		return false;
	}

	t = t / dot;

	p.copyFrom(r.localDirection);
	p = p.norm().mul(t);
	p.add(r.localOrigin);

	var u0, u1, u2, v0, v1, v2;

	if (Math.abs(n.x) > Math.abs(n.y)) {

		if (Math.abs(n.x) > Math.abs(n.z)) {

			u0 = p.y - p0.y;
			u1 = p1.y - p0.y;
			u2 = p2.y - p0.y;

			v0 = p.z - p0.z;
			v1 = p1.z - p0.z;
			v2 = p2.z - p0.z;

		} else {

			u0 = p.x - p0.x;
			u1 = p1.x - p0.x;
			u2 = p2.x - p0.x;

			v0 = p.y - p0.y;
			v1 = p1.y - p0.y;
			v2 = p2.y - p0.y;

		}

	} else {

		if (Math.abs(n.y) > Math.abs(n.z)) {

			u0 = p.x - p0.x;
			u1 = p1.x - p0.x;
			u2 = p2.x - p0.x;

			v0 = p.z - p0.z;
			v1 = p1.z - p0.z;
			v2 = p2.z - p0.z;

		} else {

			u0 = p.x - p0.x;
			u1 = p1.x - p0.x;
			u2 = p2.x - p0.x;

			v0 = p.y - p0.y;
			v1 = p1.y - p0.y;
			v2 = p2.y - p0.y;

		}

	}

	var temp = u1 * v2 - v1 * u2;
	if (!(temp != 0)) {
		return false;
	}

	temp = 1 / temp;

	var alpha = ( u0 * v2 - v0 * u2 ) * temp;
	if (!(alpha >= 0)) {

		return false;
	}

	var beta = ( u1 * v0 - v1 * u0 ) * temp;
	if (!(beta >= 0)) {
		return false;
	}

	var gamma = 1 - alpha - beta;
	if (!(gamma >= 0)) {
		return false;
	}

	return t;

}

/**
 * Performs an intersection test of a ray against a transform that has a sphere collider.
 *
 * @param {J3D.Ray} r an instance of J3D.Ray
 * @param {J3D.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a sphere collider the method returns false.
 */
SQR.Intersection.raySphere = function(r, t) {

	var e = SQR.Intersection.__tv1;
	var radius = t.collider.radius;
	var radiusSq = radius * radius;

	r.makeLocal(t);

	e.sub(t.collider.center, r.localOrigin);
	if (e.lengthSq < radiusSq) return false;

	var a = SQR.V3.dot(e, r.localDirection);
	if (a <= 0) return false;

	var t = radiusSq - ( e.magsq() - a * a );
	if (t >= 0) return Math.abs(a) - Math.sqrt(t);

	return false;

};

/**
 * Performs an intersection test of a ray against a transform that has a box collider.
 *
 * @param {J3D.Ray} r an instance of J3D.Ray
 * @param {J3D.Transform} t a transform to test against.
 *
 * @returns True if ray intersects with the collider, false otherwise. If the transform doesn't have a box collider the method returns false.
 */
SQR.Intersection.rayBox = function(r, t) {
	
	var b = t.collider.box;

	r.makeLocal(t);

	var xt = 0, yt = 0, zt = 0;
	var xn = 0, yn = 0, zn = 0;
	var ins = true;

	if (r.localOrigin.x < b.minX) {

		xt = b.minX - r.localOrigin.x;
		//if(xt > r.localDirection.x) return return Number.MAX_VALUE;
		xt /= r.localDirection.x;
		ins = false;
		xn = -1;

	} else if (r.localOrigin.x > b.maxX) {

		xt = b.maxX - r.localOrigin.x;
		//if(xt < r.localDirection.x) return return Number.MAX_VALUE;
		xt /= r.localDirection.x;
		ins = false;
		xn = 1;

	}

	if (r.localOrigin.y < b.minY) {

		yt = b.minY - r.localOrigin.y;
		//if(yt > r.localDirection.y) return return Number.MAX_VALUE;
		yt /= r.localDirection.y;
		ins = false;
		yn = -1;

	} else if (r.localOrigin.y > b.maxY) {

		yt = b.maxY - r.localOrigin.y;
		//if(yt < r.localDirection.y) return return Number.MAX_VALUE;
		yt /= r.localDirection.y;
		ins = false;
		yn = 1;

	}

	if (r.localOrigin.z < b.minZ) {

		zt = b.minZ - r.localOrigin.z;
		//if(zt > r.direction.z) return return Number.MAX_VALUE;
		zt /= r.localDirection.z;
		ins = false;
		zn = -1;

	} else if (r.localOrigin.z > b.maxZ) {

		zt = b.maxZ - r.localOrigin.z;
		//if(zt < r.direction.z) return return Number.MAX_VALUE;
		zt /= r.localDirection.z;
		ins = false;
		zn = 1;

	}

	if (ins) return -1;

	var which = 0;
	var td = xt;

	if (yt > td) {

		which = 1;
		td = yt;

	}

	if (zt > td) {

		which = 2;
		td = zt;

	}

	switch (which) {

		case 0:

			var y = r.localOrigin.y + r.localDirection.y * td;
			if (y < b.minY || y > b.maxY) return false;
			var z = r.localOrigin.z + r.localDirection.z * td;
			if (z < b.minZ || z > b.maxZ) return false;
			//ab.normal = v3(xn, 0, 0);
			break;

		case 1:

			var x = r.localOrigin.x + r.localDirection.x * td;
			if (x < b.minX || x > b.maxX) return false;
			var z = r.localOrigin.z + r.localDirection.z * td;
			if (z < b.minZ || z > b.maxZ) return false;
			//ab.normal = v3(0, yn, 0);
			break;

		case 2:

			var x = r.localOrigin.x + r.localDirection.x * td;
			if (x < b.minX || x > b.maxX) return false;
			var y = r.localOrigin.y + r.localDirection.y * td;
			if (y < b.minY || y > b.maxY) return false;
			//ab.normal = new v3(0, 0, zn);
			break;

	}

	return td;
}

/* --- --- [math/Math.js] --- --- */

Math.clamp = function(v, s, e) {
	if(v <= s) return s;
	if(v >= e) return e;
	return v;
}

Math.clamp01 = function(v) {
	if(v <= 0) return 0;
	if(v >= 1) return 1;
	return v;
}

Math.absMin = function(a, b) {
	if(a <= -b || a >= b) return a;
	else if(a >= 0) return b;
	else return -b;
}

Math.map = function(v, s, e) {
	if(v <= s) return 0;
	if(v >= e) return 1;
	return (v - s) / (e - s);
}

/* --- --- [math/Matrix2D.js] --- --- */

/**
 *  @class Matrix2D
 *  @memberof SQR
 *
 *  @description A matrix that implements 2D affine transformations. 
 *  Most of the method return the current instance for chaining.
 *
 *  @todo Make it column major
 */
SQR.Matrix2D = function() {

    this.data = new Float32Array(9);

    var a, b, d, x, y;

    /**
     *  @method identity
     *  @memberof SQR.Matrix2D.prototype
     *  @description Resets the matrix to identity values.
     */
    this.identity = function(d) {
        d = d || this.data;
        d[0] = 1,d[3] = 0,d[6] = 0;
        d[1] = 0,d[4] = 1,d[7] = 0;
        d[2] = 0,d[5] = 0,d[8] = 1;

        return this;
    }

    /**
     *  @method transformVector
     *  @memberof SQR.Matrix2D.prototype
     *  @description Multiplies the vector by the matrix
     *  @param v vector to multiply
     *  @returns the same vector as passed in the parameter, multiplied by this matrix
     */
    this.transformVector = function(v) {
        d = this.data;
        x = v.x,y = v.y;
        v.x = d[0] * x + d[1] * y + d[2];
        v.y = d[3] * x + d[4] * y + d[5];
        return v;
    }

    /**
     *  @method setTranslation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the translation values.
     *  @param tx x translation
     *  @param ty y translation
     *  @param m the matrix to set translation to, applies to this if ommited
     */
    this.setTranslation = function(tx, ty, m) {
        d = m || this.data;
        d[0] = 1,d[3] = 0,d[6] = tx;
        d[1] = 0,d[4] = 1,d[7] = ty;
        d[2] = 0,d[5] = 0,d[8] = 1;
        return this;
    }

    /**
     *  @method getTranslation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Returns the translation value as 2d vector.
     *  @param {SQR.V2} v vector to use to return values in, if ommited a new vector object is returned
     *  @returns {SQR.V2} 2d vector with translation values
     */
    this.getTranslation = function(v) {
        d = this.data;
        v = v || new SQR.V2();
        v.x = d[2];
        v.y = d[5];
        return v;
    }

    /**
     *  @method setScale
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the scale values.
     *  @param sx x scale
     *  @param sy y scale
     *  @param m the matrix to set scale to, applies to `this` if ommited
     */
    this.setScale = function(sx, sy, m) {
        d = m || this.data;
        d[0] = sx,d[3] = 0, d[6] = 0;
        d[1] = 0, d[4] = sy,d[7] = 0;
        d[2] = 0, d[5] = 0, d[8] = 1;
        return this;
    }

    /**
     *  @method setShear
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the scale values.
     *  @param sx x shear
     *  @param sy y shear
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setShear = function(sx, sy, m) {
        d = m || this.data;
        d[0] = 1, d[3] = sx,d[6] = 0;
        d[1] = sy,d[4] = 1, d[7] = 0;
        d[2] = 0, d[5] = 0, d[8] = 1;
        return this;
    }

    /**
     *  @method setRotation
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the rotation value.
     *  @param a angle in radians
     *  @param m the matrix to set shear to, applies to `this` if ommited
     */
    this.setRotation = function(a, m) {
        d = m || this.data;
        var r0 = Math.cos(a);
        var r1 = Math.sin(a);
        d[0] = r0,d[3] = -r1,d[6] = 0;
        d[1] = r1,d[4] = r0, d[7] = 0;
        d[2] = 0, d[5] = 0,  d[8] = 1;
        return this;
    }

    /**
     *  @method setTRS
     *  @memberof SQR.Matrix2D.prototype
     *  @description Sets the translation/rotation/scale values at once.
     *  @param tx x translation
     *  @param ty y translation
     *  @param a angle in radians
     *  @param sx x scale
     *  @param sy y scale
     */
    this.setTRS = function(tx, ty, a, sx, sy) {
        d = this.data;
        var r0 = Math.cos(a);
        var r1 = Math.sin(a);
        d[0] = r0 * sx,d[3] = -r1 * sy,d[6] = tx;
        d[1] = r1 * sx,d[4] = r0 * sy, d[7] = ty;
        d[2] = 0,      d[5] = 0,       d[8] = 1;
        return this;
    }

    /** 
     *  @method translate
     *  @memberof SQR.Matrix2D.prototype
     *  @description Applies translation to matrix
     *  @param tx x translation
     *  @param ty y translation
     */
    this.translate = function(tx, ty) {
        this.identity(SQR.Matrix2D.__temp);
        this.setTranslation(tx, ty, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method rotate
     *  @memberof SQR.Matrix2D.prototype
     *  @param a angle in radians
     *  @description Applies rotation to matrix
     */
    this.rotate = function(a) {
        this.identity(SQR.Matrix2D.__temp);
        this.setRotation(a, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method scale
     *  @memberof SQR.Matrix2D.prototype
     *  @param sx x scale
     *  @param sy y scale
     *  @description Applies scale to matrix
     */
    this.scale = function(sx, sy) {
        this.identity(SQR.Matrix2D.__temp);
        this.setScale(sx, sy, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    /** 
     *  @method shear
     *  @memberof SQR.Matrix2D.prototype
     *  @param sx x shear
     *  @param sy y shear
     *  @description Applies shear to matrix
     */
    this.shear = function(sx, sy) {
        this.identity(SQR.Matrix2D.__temp);
        this.setRotation(sx, sy, SQR.Matrix2D.__temp);
        return this.multiply(SQR.Matrix2D.__temp);
    }

    var a11, a12, a13, a21, a22, a23, a31, a32, a33;
    var b11, b12, b13, b21, b22, b23, b31, b32, b33;

    /** 
     *  @method multiply
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to multiply the current matrix by
     *  @description Multiples current matrix by m and stores result in current matrix.
     */
    this.multiply = function(m) {
        a = this.data, b = m.data || m;

        a11 = a[0],a12 = a[3],a13 = a[6];
        a21 = a[1],a22 = a[4],a23 = a[7];
        a31 = a[2],a32 = a[5],a33 = a[8];

        b11 = b[0],b12 = b[3],b13 = b[6];
        b21 = b[1],b22 = b[4],b23 = b[7];
        b31 = b[2],b32 = b[5],b33 = b[8];

        a[0] = a11 * b11 + a12 * b21 + a13 * b31;
        a[3] = a11 * b12 + a12 * b22 + a13 * b32;
        a[6] = a11 * b13 + a12 * b23 + a13 * b33;

        a[1] = a21 * b11 + a22 * b21 + a23 * b31;
        a[4] = a21 * b12 + a22 * b22 + a23 * b32;
        a[7] = a21 * b13 + a22 * b23 + a23 * b33;

        //a[6] = a31 * b11 + a32 * b21 + a33 * b31;
        //a[7] = a31 * b12 + a32 * b22 + a33 * b32;
        //a[8] = a31 * b13 + a32 * b23 + a33 * b33;

        return this;
    }

    /** 
     *  @method copyTo
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to copy values to. Can be {SQR.Matrix2D} or {Float32Array}
     *  @description Copies current matrix values to m
     */
    this.copyTo = function(m) {
        a = this.data,b = m.data || m;

        b[0] = a[0],b[1] = a[1],b[2] = a[2];
        b[3] = a[3],b[4] = a[4],b[5] = a[5];
        b[6] = a[6],b[7] = a[7],b[8] = a[8];

        return m;
    }

    /** 
     *  @method copyFrom
     *  @memberof SQR.Matrix2D.prototype
     *  @param m matrix to copy values from. Can be {SQR.Matrix2D} or {Float32Array}
     *  @description Copies values from m into the current matrix
     */
    this.copyFrom = function(m) {
        a = m.data || m,b = this.data;

        b[0] = a[0],b[1] = a[1],b[2] = a[2];
        b[3] = a[3],b[4] = a[4],b[5] = a[5];
        b[6] = a[6],b[7] = a[7],b[8] = a[8];

        return this;
    }

    this.identity();
}

SQR.Matrix2D.__temp = new Float32Array(9);
















/* --- --- [math/Matrix33.js] --- --- */

/**
 *  @class Matrix33
 *  @memberof SQR
 *
 *  @description A 3x3 matrix for used to hold rotations and normal matrices
 */
SQR.Matrix33 = function() {

    this.data = new Float32Array(9);

    this.identity = function() {
        var d = this.data;
        d[0] = 1,d[3] = 0,d[6] = 0;
        d[1] = 0,d[4] = 1,d[7] = 0;
        d[2] = 0,d[5] = 0,d[8] = 1;
        return this;
    }

    this.copyTo = function(m) {
        var a = this.data, b = m.data || m;
        for (var i = 0; i < 9; i++) b[i] = a[i];
        return this;
    }

    this.copyFrom = function(m) {
        var a = this.data, b = m.data || m;
        for (var i = 0; i < 9; i++) a[i] = b[i];
        return this;
    }

    this.transformVector = function (v, pv) {
        var d = this.data;
        var x = v.x, y = v.y, z = v.z;
        pv = pv || v;

        pv.x = d[0] * x + d[3] * y + d[6] * z;
        pv.y = d[1] * x + d[4] * y + d[7] * z;
        pv.z = d[2] * x + d[5] * y + d[8] * z;

        return pv;
    }

    this.determinant = function() {
        var d = this.data;

        return d[0] * (d[4] * d[8] - d[7] * d[5]) +
               d[3] * (d[7] * d[2] - d[1] * d[8]) +
               d[6] * (d[1] * d[5] - d[4] * d[2]);
    }

    this.inverse = function(m) {
        var d = this.data;
        m = m || this.data;

        var a00 = d[0], a01 = d[1], a02 = d[2],
            a10 = d[3], a11 = d[4], a12 = d[5],
            a20 = d[6], a21 = d[7], a22 = d[8],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) {
            console.warn("Attempt to inverse a singular matrix33. ", this.data);
            return m;
        }
        
        id = 1 / d;

        m[0] = b01 * id;
        m[1] = (-a22 * a01 + a02 * a21) * id;
        m[2] = (a12 * a01 - a02 * a11) * id;
        m[3] = b11 * id;
        m[4] = (a22 * a00 - a02 * a20) * id;
        m[5] = (-a12 * a00 + a02 * a10) * id;
        m[6] = b21 * id;
        m[7] = (-a21 * a00 + a01 * a20) * id;
        m[8] = (a11 * a00 - a01 * a10) * id;

        return m;

    }

    this.transpose = function() {
        var d = this.data;

        var d0 = d[0], d3 = d[3], d6 = d[6],
            d1 = d[1], d4 = d[4], d7 = d[7],
            d2 = d[2], d5 = d[5], d8 = d[8];

        d[0] = d0;
        d[1] = d3;
        d[2] = d6;

        d[3] = d1;
        d[4] = d4;
        d[5] = d7;

        d[6] = d2;
        d[7] = d5;
        d[8] = d8;
    }

}

/* --- --- [math/Matrix44.js] --- --- */

/**
 *  @class Matrix44
 *  @memberof SQR
 *
 *  @description A multi-purpose 4x4 matrix.
 */
SQR.Matrix44 = function(data) {

	this.data = data || new Float32Array(16);

	this.identity = function(m) {
		var d = m || this.data;
		d[0] = 1,d[4] = 0,d[8] = 0,d[12] = 0;
		d[1] = 0,d[5] = 1,d[9] = 0,d[13] = 0;
		d[2] = 0,d[6] = 0,d[10] = 1,d[14] = 0;
		d[3] = 0,d[7] = 0,d[11] = 0,d[15] = 1;
		return this;
	}

	/**
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Multiplies the vector v by my this matrix and stores the result in the vector pv.
	 *
	 *  @param {SQR.V3} v - the vector to be multiplies by this matrix
	 *  @param {SQR.V3=} pv - the vector in which to store the result. If ommited, result is stored in v.
	 */
	this.transformVector = function (v, pv) {
		var d = this.data;
		var x = v.x, y = v.y, z = v.z, w = v.w;
		pv = pv || v;
		
		pv.x = d[0] * x + d[4] * y + d[8] * z + d[12] * w;
		pv.y = d[1] * x + d[5] * y + d[9] * z + d[13] * w;
		pv.z = d[2] * x + d[6] * y + d[10] * z + d[14] * w;
		// pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

		return pv;
	}

	this.rotateVector = function (v, pv) {
		var d = this.data;
		var x = v.x, y = v.y, z = v.z, w = v.w;
		pv = pv || v;
		
		pv.x = d[0] * x + d[4] * y + d[8] * z;
		pv.y = d[1] * x + d[5] * y + d[9] * z;
		pv.z = d[2] * x + d[6] * y + d[10] * z;
		// pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

		return pv;
	}

	/**
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Multiplies this matrix by m
	 *  @param {SQR.Matrix44} m - matrix to multiply this matrix by
	 */
	this.multiply = function(m) {
		var a = this.data, b = m.data || m;

		var a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11, a12, a13, a14, a15;
		var b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, b12, b13, b14, b15;

		a00 = a[0],a01 = a[1],a02 = a[2],a03 = a[3];
		a04 = a[4],a05 = a[5],a06 = a[6],a07 = a[7];
		a08 = a[8],a09 = a[9],a10 = a[10],a11 = a[11];
		a12 = a[12],a13 = a[13],a14 = a[14],a15 = a[15];

		b00 = b[0],b01 = b[1],b02 = b[2],b03 = b[3];
		b04 = b[4],b05 = b[5],b06 = b[6],b07 = b[7];
		b08 = b[8],b09 = b[9],b10 = b[10],b11 = b[11];
		b12 = b[12],b13 = b[13],b14 = b[14],b15 = b[15];

		a[0] = a00 * b00 + a04 * b01 + a08 * b02 + a12 * b03;
		a[1] = a01 * b00 + a05 * b01 + a09 * b02 + a13 * b03;
		a[2] = a02 * b00 + a06 * b01 + a10 * b02 + a14 * b03;
		a[3] = a03 * b00 + a07 * b01 + a11 * b02 + a15 * b03;

		a[4] = a00 * b04 + a04 * b05 + a08 * b06 + a12 * b07;
		a[5] = a01 * b04 + a05 * b05 + a09 * b06 + a13 * b07;
		a[6] = a02 * b04 + a06 * b05 + a10 * b06 + a14 * b07;
		a[7] = a03 * b04 + a07 * b05 + a11 * b06 + a15 * b07;

		a[8] = a00 * b08 + a04 * b09 + a08 * b10 + a12 * b11;
		a[9] = a01 * b08 + a05 * b09 + a09 * b10 + a13 * b11;
		a[10] = a02 * b08 + a06 * b09 + a10 * b10 + a14 * b11;
		a[11] = a03 * b08 + a07 * b09 + a11 * b10 + a15 * b11;

		a[12] = a00 * b12 + a04 * b13 + a08 * b14 + a12 * b15;
		a[13] = a01 * b12 + a05 * b13 + a09 * b14 + a13 * b15;
		a[14] = a02 * b12 + a06 * b13 + a10 * b14 + a14 * b15;
		a[15] = a03 * b12 + a07 * b13 + a11 * b14 + a15 * b15;

		return this;
	}

	/**
	 *  @method setTQS
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the translation/rotation/scale values at once. 
	 *  Similar to setTRS but the rotation is defined as a quaternion.
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz y translation
	 *  @param qw w compoment of the quaternion
	 *  @param qx x compoment of the quaternion
	 *  @param qx y compoment of the quaternion
	 *  @param qx z compoment of the quaternion
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @param m the matrix to set scale to, applies to `this` if ommited
	 */
	this.setTQS = function(tx, ty, tz, qw, qx, qy, qz, sx, sy, sz, m) {

		var d = m || this.data;
		this.identity(m);

		var sqx = qx * qx;
		var sqy = qy * qy;
		var sqz = qz * qz;

		// fliping this part changes from left handed to right handed (I think)
		if(SQR.flipMatrix) {
			d[0] = (1 - 2 * sqy - 2 * sqz) * sx;
			d[1] = (2 * qx * qy - 2 * qz * qw) * sx;
			d[2] = (2 * qx * qz + 2 * qy * qw) * sx;

			d[4] = (2 * qx * qy + 2 * qz * qw) * sy;
			d[5] = (1 - 2 * sqx - 2 * sqz) * sy;
			d[6] = (2 * qy * qz - 2 * qx * qw) * sy;

			d[8] = (2 * qx * qz - 2 * qy * qw) * sz;
			d[9] = (2 * qy * qz + 2 * qx * qw) * sz;
			d[10] = (1 - 2 * sqx - 2 * sqy) * sz;
		} else {
			d[0] = (1 - 2 * sqy - 2 * sqz) * sx;
			d[4] = (2 * qx * qy - 2 * qz * qw) * sx;
			d[8] = (2 * qx * qz + 2 * qy * qw) * sx;

			d[1] = (2 * qx * qy + 2 * qz * qw) * sy;
			d[5] = (1 - 2 * sqx - 2 * sqz) * sy;
			d[9] = (2 * qy * qz - 2 * qx * qw) * sy;

			d[2] = (2 * qx * qz - 2 * qy * qw) * sz;
			d[6] = (2 * qy * qz + 2 * qx * qw) * sz;
			d[10] = (1 - 2 * sqx - 2 * sqy) * sz;
		}

		d[12] = tx;
		d[13] = ty;
		d[14] = tz;

		return m || this;
	}

	/**
	 *  @method setTRS
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the translation/rotation/scale values at once.
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz y translation
	 *  @param rx rotation angle in radians on the x axis
	 *  @param ry rotation angle in radians on the y axis
	 *  @param rz rotation angle in radians on the z axis
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @param m the matrix to set scale to, applies to `this` if ommited
	 */
	this.setTRS = function(tx, ty, tz, rx, ry, rz, sx, sy, sz, m) {

		var d = m || this.data;
		this.identity(m);

		var six = Math.sin(rx), cox = Math.cos(rx), siy = Math.sin(ry), coy = Math.cos(ry), siz = Math.sin(rz), coz = Math.cos(rz);

		// fliping this part changes from left handed to right handed (I think)
		if(SQR.flipMatrix) {
			d[0] = (coy * coz + siy * six * siz) * sx;
			d[1] = (-coy * siz + siy * six * coz) * sx;
			d[2] = siy * cox * sx;

			d[4] = siz * cox * sy;
			d[5] = coz * cox * sy;
			d[6] = -six * sy;

			d[8] = (-siy * coz + coy * six * siz) * sz;
			d[9] = (siz * siy + coy * six * coz) * sz;
			d[10] = coy * cox * sz;
		} else {
			d[0] = (coy * coz + siy * six * siz) * sx;
			d[4] = (-coy * siz + siy * six * coz) * sx;
			d[8] = siy * cox * sx;

			d[1] = siz * cox * sy;
			d[5] = coz * cox * sy;
			d[9] = -six * sy;

			d[2] = (-siy * coz + coy * six * siz) * sz;
			d[6] = (siz * siy + coy * six * coz) * sz;
			d[10] = coy * cox * sz;
		}

		d[12] = tx;
		d[13] = ty;
		d[14] = tz;

		return m || this;
	}

	/**
	 *  @method setScale
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the scale values.
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @param m the matrix to set scale to, applies to `this` if ommited
	 */
	this.setScale = function(sx, sy, sz, m) {
		var d = m || this.data;
		d[0] = sx, d[5] = sy, d[10] = sz;
		return m || this;
	}

	/**
	 *  @method setTranslation
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the translation values.
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz z translation
	 *  @param m the matrix to set translation to, applies to `this` if ommited
	 */
	this.setTranslation = function(tx, ty, tz, m) {
		var d = m || this.data;
		d[12] = tx, d[13] = ty, d[14] = tz;
		return m || this;
	}

	/**
	 *  @method setRotation
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Sets the rotation value.
	 *  @param rx angle in radians of the rotation on x axis
	 *  @param ry angle in radians of the rotation on y axis
	 *  @param rz angle in radians of the rotation on z axis
	 *  @param m the matrix to set rotation to, applies to `this` if ommited
	 */
	this.setRotation = function(rx, ry, rz, m) {
		var d = m || this.data;
		var six = Math.sin(rx), cox = Math.cos(rx), 
			siy = Math.sin(ry), coy = Math.cos(ry), 
			siz = Math.sin(rz), coz = Math.cos(rz);

		d[0] = coy * coz + siy * six * siz;
		d[1] = -coy * siz + siy * six * coz;
		d[2] = siy * cox;

		d[4] = siz * cox;
		d[5] = coz * cox;
		d[6] = -six;

		d[8] = -siy * coz + coy * six * siz;
		d[9] = siz * siy + coy * six * coz;
		d[10] = coy * cox;

		return m || this;
	}

	/** 
	 *  @method translate
	 *  @memberof SQR.Matrix44.prototype
	 *  @description Applies translation to matrix
	 *  @param tx x translation
	 *  @param ty y translation
	 *  @param tz z translation
	 */
	this.translate = function(tx, ty, tz) {
		this.identity(SQR.Matrix44.__temp);
		this.setTranslation(tx, ty, tz, SQR.Matrix44.__temp);
		return this.multiply(SQR.Matrix44.__temp);
	}

	/** 
	 *  @method rotate
	 *  @memberof SQR.Matrix44.prototype
	 *  @param rx angle in radians of the rotation on x axis
	 *  @param ry angle in radians of the rotation on y axis
	 *  @param rz angle in radians of the rotation on z axis
	 *  @description Applies rotation to matrix
	 */
	this.rotate = function(rx, ry, rz) {
		this.identity(SQR.Matrix44.__temp);
		this.setRotation(rx, ry, rz, SQR.Matrix44.__temp);
		return this.multiply(SQR.Matrix44.__temp);
	}

	/** 
	 *  @method scale
	 *  @memberof SQR.Matrix44.prototype
	 *  @param sx x scale
	 *  @param sy y scale
	 *  @param sz z scale
	 *  @description Applies scale to matrix
	 */
	this.scale = function(sx, sy, sz) {
		this.identity(SQR.Matrix44.__temp);
		this.setScale(sx, sy, sz, SQR.Matrix44.__temp);
		return this.multiply(SQR.Matrix44.__temp);
	}

	/** 
	 *  @method copyTo
	 *  @memberof SQR.Matrix44.prototype
	 *  Copies the values from this matrix into m
	 *
	 *  @param {SQR.Matrix44|Float32Array} m - the matrix or 16-compoment array to copy the values to
	 */
	this.copyTo = function(m) {
		var a = this.data, b = m.data || m;
		for (var i = 0; i < 16; i++) b[i] = a[i];
		return this;
	}

	this.copyFrom = function(m) {
		var a = this.data, b = m.data || m;
		for (var i = 0; i < 16; i++) a[i] = b[i];
		return this;
	}

	/** 
	 *  @method copyRotationTo
	 *  @memberof SQR.Matrix44.prototype
	 *  Copies only the rotation/scale portion of the matrix into m to the current matrix
	 *
	 *  @param {SQR.Matrix44|Float32Array} m - the matrix or 16-compoment array to copy the values to
	 */
	this.copyRotationTo = function(m) {
		var a = this.data, b = m.data || m;

		b[0] = a[0];
		b[1] = a[1];
		b[2] = a[2];

		b[3] = a[4];
		b[4] = a[5];
		b[5] = a[6];

		b[6] = a[8];
		b[7] = a[9];
		b[8] = a[10];

		return m;
	}

	/** 
	 *  @method extractPosition
	 *  @memberof SQR.Matrix44.prototype
	 *  Sets v to the translation vakue of this matrix. Useful for extracting position of an element
	 *  based on it's transformation matrix, ex. this is how the the global position of a {@link SQR.Transform} 
	 *  is obtained.
	 *
	 *  @param {SQR.V3} v - the vector to copy the translation values to
	 */
	this.extractPosition = function(v) {
		var d = this.data;
		v.set(d[12], d[13], d[14]);
		return v;
	}

	this.determinant = function() {
		var d = this.data;

		return d[0] * (d[5] * d[10] - d[9] * d[6]) +
			d[4] * (d[9] * d[2] - d[1] * d[10]) +
			d[8] * (d[1] * d[6] - d[5] * d[2]);
	}

	this.inverse = function(m) {
		var a = this.data;
		var d = (m) ? m.data || m : this.data;

		var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
			a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
			a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
			a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

			b00 = a00 * a11 - a01 * a10,
			b01 = a00 * a12 - a02 * a10,
			b02 = a00 * a13 - a03 * a10,
			b03 = a01 * a12 - a02 * a11,
			b04 = a01 * a13 - a03 * a11,
			b05 = a02 * a13 - a03 * a12,
			b06 = a20 * a31 - a21 * a30,
			b07 = a20 * a32 - a22 * a30,
			b08 = a20 * a33 - a23 * a30,
			b09 = a21 * a32 - a22 * a31,
			b10 = a21 * a33 - a23 * a31,
			b11 = a22 * a33 - a23 * a32,

			// Calculate the determinant
			det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		if (!det) { 
			return null; 
		}
		det = 1.0 / det;

		d[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		d[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		d[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		d[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
		d[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		d[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		d[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		d[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
		d[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
		d[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
		d[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
		d[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
		d[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
		d[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
		d[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
		d[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

		return m;
	};

	
	this.inverseMat3 = function(m) {
		// adapted from gl-Matrix.js
		var d = this.data;
		var a = m.data;
		var det = this.determinant();

		if (Math.abs(det) < 0.0001) {
			console.warn("> SQR.Matrix44 - Attempt to inverse a singular matrix44. ", this.data);
			console.trace();
			return m;
		}

		var d0 = d[0], d4 = d[4], d8 = d[8],   d12 = d[12],
			d1 = d[1], d5 = d[5], d9 = d[9],   d13 = d[13],
			d2 = d[2], d6 = d[6], d10 = d[10], d14 = d[14];

		det = 1 / det;

		// To make a NormalMatrix - needs to be transposed
		a[0] = (d5 * d10 - d9 * d6) * det;
		a[1] = (d8 * d6 - d4 * d10) * det;
		a[2] = (d4 * d9 - d8 * d5) * det;

		a[3] = (d9 * d2 - d1 * d10) * det;
		a[4] = (d0 * d10 - d8 * d2) * det;
		a[5] = (d8 * d1 - d0 * d9) * det;

		a[6] = (d1 * d6 - d5 * d2) * det;
		a[7] = (d4 * d2 - d0 * d6) * det;
		a[8] = (d0 * d5 - d4 * d1) * det;
		
		// To make a NormalMatrix - doesn't need to be transposed
		// a[0] = (d5 * d10 - d9 * d6) * det;
		// a[3] = (d8 * d6 - d4 * d10) * det;
		// a[6] = (d4 * d9 - d8 * d5) * det;

		// a[1] = (d9 * d2 - d1 * d10) * det;
		// a[4] = (d0 * d10 - d8 * d2) * det;
		// a[7] = (d8 * d1 - d0 * d9) * det;

		// a[2] = (d1 * d6 - d5 * d2) * det;
		// a[5] = (d4 * d2 - d0 * d6) * det;
		// a[8] = (d0 * d5 - d4 * d1) * det;

		

		return m;
	}

	this.transpose = function(m) {
		var d = this.data;
		var a = (m) ? m.data || m : this.data;

		var d0 = d[0], d4 = d[4], d8 = d[8],
			d1 = d[1], d5 = d[5], d9 = d[9],
			d2 = d[2], d6 = d[6], d10 = d[10];

		a[0] = d0;
		a[1] = d4;
		a[2] = d8;

		a[4] = d1;
		a[5] = d5;
		a[6] = d9;

		a[8] = d2;
		a[9] = d6;
		a[10] = d10;
	}

	this.lookAt = function (target, up) {
		var d = this.data;
		var x = SQR.V3.__tv1;
		var y = SQR.V3.__tv2;
		var z = SQR.V3.__tv3;

		up = up || SQR.V3.up;

		// console.log(target, up);

		z.set(d[12], d[13], d[14]);
		z.sub(z, target).norm();
		if (z.magsq() === 0) z.z = 1;

		x.cross(up, z).norm();
		if (x.magsq() === 0) {
			z.x += 0.0001;
			x.cross(up, z).norm();
		}

		y.cross(z, x);

		d[0] = x.x, d[4] = y.x, d[8] = z.x;
		d[1] = x.y, d[5] = y.y, d[9] = z.y;
		d[2] = x.z, d[6] = y.z, d[10] = z.z;

		return this;
	}

	if(!data) this.identity();
}

SQR.Matrix44.__temp = new Float32Array(16);












/* --- --- [math/PerlinNoise.js] --- --- */

/**
 *  @class PerlinNoise
 *  @memberof SQR
 *
 *  @description <p>A speed-improved perlin and simplex noise algorithms for 2D.</p>
 *
 *	<p>Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 *	Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 *	Better rank ordering method by Stefan Gustavson in 2012.
 *	Converted to Javascript by Joseph Gentle.</p>
 *
 *	<p>Version 2012-03-09</p>
 *
 *	<p>This code was placed in the public domain by its original author,
 *	Stefan Gustavson. You may use it as you see fit, but attribution is appreciated.</p>
 *
 *	<p>This code below is copied from <a href='https://github.com/josephg/noisejs/blob/master/perlin.js'>perlin.js</a> and only slightly chnaged to  adapt for SQR API.</p>
 *	
 */
SQR.PerlinNoise = (function(){

	var module = {};

	function Grad(x, y, z) {
		this.x = x; this.y = y; this.z = z;
	}
	
	Grad.prototype.dot2 = function(x, y) {
		return this.x*x + this.y*y;
	};

	Grad.prototype.dot3 = function(x, y, z) {
		return this.x*x + this.y*y + this.z*z;
	};

	var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
							 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
							 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

	var p = [151,160,137,91,90,15,
	131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
	190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
	88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
	77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
	102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
	135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
	5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
	223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
	129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
	251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
	49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
	// To remove the need for index wrapping, double the permutation table length
	var perm = new Array(512);
	var gradP = new Array(512);

	// This isn't a very good seeding function, but it works ok. It supports 2^16
	// different seed values. Write something better if you need more seeds.
	module.seed = function(seed) {
		if(seed > 0 && seed < 1) {
			// Scale the seed out
			seed *= 65536;
		}

		seed = Math.floor(seed);
		if(seed < 256) {
			seed |= seed << 8;
		}

		for(var i = 0; i < 256; i++) {
			var v;
			if (i & 1) {
				v = p[i] ^ (seed & 255);
			} else {
				v = p[i] ^ ((seed>>8) & 255);
			}

			perm[i] = perm[i + 256] = v;
			gradP[i] = gradP[i + 256] = grad3[v % 12];
		}
	};

	module.seed(0);

	/*
	for(var i=0; i<256; i++) {
		perm[i] = perm[i + 256] = p[i];
		gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
	}*/

	// Skewing and unskewing factors for 2, 3, and 4 dimensions
	var F2 = 0.5*(Math.sqrt(3)-1);
	var G2 = (3-Math.sqrt(3))/6;

	var F3 = 1/3;
	var G3 = 1/6;

	/** 
	 *	@method perlin2
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.simplex2 = function(xin, yin) {
		var n0, n1, n2; // Noise contributions from the three corners
		// Skew the input space to determine which simplex cell we're in
		var s = (xin+yin)*F2; // Hairy factor for 2D
		var i = Math.floor(xin+s);
		var j = Math.floor(yin+s);
		var t = (i+j)*G2;
		var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
		var y0 = yin-j+t;
		// For the 2D case, the simplex shape is an equilateral triangle.
		// Determine which simplex we are in.
		var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
		if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
			i1=1; j1=0;
		} else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
			i1=0; j1=1;
		}
		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6
		var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		var y1 = y0 - j1 + G2;
		var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
		var y2 = y0 - 1 + 2 * G2;
		// Work out the hashed gradient indices of the three simplex corners
		i &= 255;
		j &= 255;
		var gi0 = gradP[i+perm[j]];
		var gi1 = gradP[i+i1+perm[j+j1]];
		var gi2 = gradP[i+1+perm[j+1]];
		// Calculate the contribution from the three corners
		var t0 = 0.5 - x0*x0-y0*y0;
		if(t0<0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
		}
		var t1 = 0.5 - x1*x1-y1*y1;
		if(t1<0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * gi1.dot2(x1, y1);
		}
		var t2 = 0.5 - x2*x2-y2*y2;
		if(t2<0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * gi2.dot2(x2, y2);
		}
		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70 * (n0 + n1 + n2);
	};

	/** 
	 *	@method simplex3
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *	@param {Number} z
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.simplex3 = function(xin, yin, zin) {
		var n0, n1, n2, n3; // Noise contributions from the four corners

		// Skew the input space to determine which simplex cell we're in
		var s = (xin+yin+zin)*F3; // Hairy factor for 2D
		var i = Math.floor(xin+s);
		var j = Math.floor(yin+s);
		var k = Math.floor(zin+s);

		var t = (i+j+k)*G3;
		var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
		var y0 = yin-j+t;
		var z0 = zin-k+t;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
		var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
		if(x0 >= y0) {
			if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
			else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
			else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
		} else {
			if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
			else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
			else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
		}
		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		var x1 = x0 - i1 + G3; // Offsets for second corner
		var y1 = y0 - j1 + G3;
		var z1 = z0 - k1 + G3;

		var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
		var y2 = y0 - j2 + 2 * G3;
		var z2 = z0 - k2 + 2 * G3;

		var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
		var y3 = y0 - 1 + 3 * G3;
		var z3 = z0 - 1 + 3 * G3;

		// Work out the hashed gradient indices of the four simplex corners
		i &= 255;
		j &= 255;
		k &= 255;
		var gi0 = gradP[i+   perm[j+   perm[k   ]]];
		var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
		var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
		var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

		// Calculate the contribution from the four corners
		var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
		if(t0<0) {
			n0 = 0;
		} else {
			t0 *= t0;
			n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
		}
		var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
		if(t1<0) {
			n1 = 0;
		} else {
			t1 *= t1;
			n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
		}
		var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
		if(t2<0) {
			n2 = 0;
		} else {
			t2 *= t2;
			n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
		}
		var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
		if(t3<0) {
			n3 = 0;
		} else {
			t3 *= t3;
			n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
		}
		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 32 * (n0 + n1 + n2 + n3);

	};

	// ##### Perlin noise stuff

	function fade(t) {
		return t*t*t*(t*(t*6-15)+10);
	}

	function lerp(a, b, t) {
		return (1-t)*a + t*b;
	}

	/** 
	 *	@method perlin2
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.perlin2 = function(x, y) {
		// Find unit grid cell containing point
		var X = Math.floor(x), Y = Math.floor(y);
		// Get relative xy coordinates of point within that cell
		x = x - X; y = y - Y;
		// Wrap the integer cells at 255 (smaller integer period can be introduced here)
		X = X & 255; Y = Y & 255;

		// Calculate noise contributions from each of the four corners
		var n00 = gradP[X+perm[Y]].dot2(x, y);
		var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
		var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
		var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

		// Compute the fade curve value for x
		var u = fade(x);

		// Interpolate the four results
		return lerp(
				lerp(n00, n10, u),
				lerp(n01, n11, u),
			 fade(y));
	};

	/** 
	 *	@method perlin3
	 *	@memberof SQR.PerlinNoise
	 *
	 *	@param {Number} x
	 *	@param {Number} y
	 *	@param {Number} z
	 *
	 *	@returns {Number} the noise value in -1 to 1 range
	 */
	module.perlin3 = function(x, y, z) {
		// Find unit grid cell containing point
		var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
		// Get relative xyz coordinates of point within that cell
		x = x - X; y = y - Y; z = z - Z;
		// Wrap the integer cells at 255 (smaller integer period can be introduced here)
		X = X & 255; Y = Y & 255; Z = Z & 255;

		// Calculate noise contributions from each of the eight corners
		var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
		var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
		var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
		var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
		var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
		var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
		var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
		var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

		// Compute the fade curve value for x, y, z
		var u = fade(x);
		var v = fade(y);
		var w = fade(z);

		// Interpolate
		return lerp(
				lerp(
					lerp(n000, n100, u),
					lerp(n001, n101, u), w),
				lerp(
					lerp(n010, n110, u),
					lerp(n011, n111, u), w),
			 v);
	};

	return module;

})();






/* --- --- [math/ProjectionMatrix.js] --- --- */

/**
 *  @class ProjectionMatrix
 *  @memberof SQR
 *
 *  @description The 4x4 matrix is a specialized 4x4 matrix used for perspective and orthographic projection.
 */
SQR.ProjectionMatrix = function() {
	if (typeof Float32Array == 'undefined') Float32Array = Array;
	this.data = new Float32Array(16);

	this.copyTo = function(m) {
		var a = this.data, b = m.data || m;
		for (var i = 0; i < 16; i++) b[i] = a[i];
		return m;
	}

	this.identity();
}


SQR.ProjectionMatrix.getBoundsAtDistance = function(fov, distance, width, height) {
	width = width || window.innerWidth;
	height = height || window.innerHeight;
	var aspect = width/height;
	var t = Math.tan(fov / 180 * Math.PI / 2);
	var h = distance * t;
	var w = h * aspect;
	return { w : w, h : h };
};

/**
 *  Resets the matrix to identity
 */
SQR.ProjectionMatrix.prototype.identity = function() {
	var m = this.data;
	m[0] = 1,m[1] = 0,m[2] = 0,m[3] = 0;
	m[4] = 0,m[5] = 1,m[6] = 0,m[7] = 0;
	m[8] = 0,m[9] = 0,m[10] = 1,m[11] = 0;
	m[12] = 0,m[13] = 0,m[14] = 0,m[15] = 1;
	return this;
}

/**
 *  Returns an orthographic projection matrix that is set in screen coordinates.
 */
SQR.ProjectionMatrix.prototype.screenPixels2d = function() {
	this.orthographic(window.innerWidth, 0, window.innerHeight, 0, -1, 1000);
	return this;
}

/**
 *  Returns an orthographic projection matrix.
 */
SQR.ProjectionMatrix.prototype.orthographic = function(left, right, top, bottom, near, far) {

	var m = this.data;

	 /**
	 *  @property the near clipping
	 *  @readonly
	 */
	this.near = near;

	/**
	 *  @property the far clipping
	 *  @readonly
	 */
	this.far = far;
	
	var w = right - left;
	var h = top - bottom;
	var p = far - near;

	var x = ( right + left ) / w;
	var y = ( top + bottom ) / h;
	var z = ( far + near ) / p;

	m[0] = 2 / w;    m[4] = 0;        m[8] = 0;        m[12] = -x;
	m[1] = 0;        m[5] = 2 / h;    m[9] = 0;        m[13] = -y;
	m[2] = 0;        m[6] = 0;        m[10] = -2/p;    m[14] = -z;
	m[3] = 0;        m[7] = 0;        m[11] = 0;       m[15] = 1;
	return this;
}

/**
 *  Returns a perspective projection matrix.
 */
SQR.ProjectionMatrix.prototype.perspective = function(fov, aspect, near, far) {

	fov = fov || 60;
	near = near || 1;
	far = far || 1000;

	var m = this.data;
	var t = near * Math.tan(fov * Math.PI / 360);
	var n = far - near;

	m[0] = near / (t * aspect);
	m[4] =  0;
	m[8] =  0;
	m[12] = 0;

	m[1] = 0;
	m[5] = near / t;
	m[9] = 0;
	m[13] = 0;

	m[2] = 0;
	m[6] = 0;
	m[10] = -(far + near) / n;
	m[14] = -(2 * far * near) / n;

	m[3] = 0;
	m[7] = 0;
	m[11] = -1;
	m[15] = 0;

	/**
	 *  @property {Number} the field ov view
	 *	@default 60
	 *  @readonly
	 */
	this.fov = fov;

	/**
	 *  @property {Number=} the near clipping plane
	 *	@default 1
	 *  @readonly
	 */
	this.near = near;

	/**
	 *  @property {Number=} the far clipping plane
	 *	@default 1000
	 *  @readonly
	 */
	this.far = far;
	

	return this;
}

/**
 *  Returns vector mautipled by this matrix
 */
SQR.ProjectionMatrix.prototype.transformVector = function(v, pv) {
	var x = v.x, y = v.y, z = v.z, w = v.w;
	var m = this.data;
	pv = pv || v;

	pv.x = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	pv.y = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	pv.z = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
//  pv.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;

	return pv;
}

/**
 *  Inverses the matrix. Useful for projecting screen coordinates back in to 3d space.
 */
/*
SQR.ProjectionMatrix.prototype.inverse = function (m) {
	var mat = this.data;
	m = m || this.data;

	var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
		a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
		a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
		a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

		b00 = a00 * a11 - a01 * a10,
		b01 = a00 * a12 - a02 * a10,
		b02 = a00 * a13 - a03 * a10,
		b03 = a01 * a12 - a02 * a11,
		b04 = a01 * a13 - a03 * a11,
		b05 = a02 * a13 - a03 * a12,
		b06 = a20 * a31 - a21 * a30,
		b07 = a20 * a32 - a22 * a30,
		b08 = a20 * a33 - a23 * a30,
		b09 = a21 * a32 - a22 * a31,
		b10 = a21 * a33 - a23 * a31,
		b11 = a22 * a33 - a23 * a32,

		d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
		invDet;

	// Calculate the determinant
	if (!d) {
		return null;
	}
	invDet = 1 / d;

	m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
	m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
	m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
	m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;

	m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
	m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
	m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
	m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;

	m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
	m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
	m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
	m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;

	m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
	m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
	m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
	m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

	return m;
};

*/

/* --- --- [math/Quaternion.js] --- --- */

/**
 *  @class Quaternion
 *  @memberof SQR
 *
 *  @description Represents a quaternion with optionally setting the values directly.
 *
 *  Just as a reminder, given an angle `a` and an axis `x,y,z` 
 *  this is what the quaternion values are:
 *  @example
var q = new SQR.Quaternion();
var s = Math.sin(a / 2);
q.x = x * s;
q.y = y * s;
q.z = z * s;
q.w = Math.cos(a / 2);
 */
SQR.Quaternion = function(x, y, z, w) {
    this.set(w, x, y, z);
}

/**
 *  Set value of the Quaternion directly.
 */
SQR.Quaternion.prototype.set = function(x, y, z, w) {
    this.w = w || 1;
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    return this;
}

SQR.Quaternion.prototype.copyTo = function(p) {
    p.x = this.x;
    p.y = this.y;
    p.z = this.z;
    p.w = this.w;
    return this;
}

/**
 *  Copy the values from another quaternion.
 *  @param q the quaternion to copy values from
 */
SQR.Quaternion.prototype.copyFrom = function(q) {
    if(q instanceof Array) {
        this.x = q[0];
        this.y = q[1];
        this.z = q[2];
        this.w = q[3];
    } else {
        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
        this.w = q.w;
    }
    return this;
}

/**
 *  Resets the quaternion values to identity.
 */
SQR.Quaternion.prototype.identity = function() {
    this.set();
    return this;
}

/**
 * Multiplies rq (or this if no rq) by q
 * @param q
 * @param rq if not defined this is multiplied by q
 */
SQR.Quaternion.prototype.mul = function(q, rq) {
    rq = rq || this;

    var w = (rq.w * q.w - rq.x * q.x - rq.y * q.y - rq.z * q.z);
    var x = (rq.w * q.x + rq.x * q.w + rq.y * q.z - rq.z * q.y);
    var y = (rq.w * q.y - rq.x * q.z + rq.y * q.w + rq.z * q.x);
    var z = (rq.w * q.z + rq.x * q.y - rq.y * q.x + rq.z * q.w);

    rq.set(x, y, z, w);

    rq.normalize();

    return rq;
}

SQR.Quaternion.prototype.dot = function(q) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
}

/**
 *  Sets the quaternion to point in the given direction.
 *  @param _dir the direction to look at
 *  @param _up the up vector
 */
SQR.Quaternion.prototype.lookAt = function(_dir, _up) {

    var dir = SQR.Quaternion.__tv1;
    var right = SQR.Quaternion.__tv2;
    var up = SQR.Quaternion.__tv3;

    _dir.copyTo(dir);
    _up.copyTo(up);

    dir.norm();

    // If direction is back, the returned quaternion is flipped. Not sure why, but that fixes it.
    if(dir.z == -1) {
        dir.x = 0.0001;
        dir.norm();
    }

    // Probably should do the orthonormalization but not sure how that works :)
    // tangent.sub(up, forward.mul(SQR.V3.dot(forward, up))).norm();
    right.cross(up, dir);
    up.cross(dir, right);

    this.w = Math.sqrt(1 + right.x + up.y + dir.z) * 0.5;
    var rc = 4 * this.w;
    this.x = (dir.y - up.z) / rc;
    this.y = (right.z - dir.x) / rc;
    this.z = (up.x - right.y) / rc;

    this.normalize();

    return this;
}

/**
 *  Creates a quaternion out of an angle axis representation.
 *  @param a angle in radians
 *  @param x x component of the axis
 *  @param y y component of the axis
 *  @param z z component of the axis
 */
SQR.Quaternion.prototype.fromAngleAxis = function(a, x, y, z) {
    var s = Math.sin(a / 2);
    this.x = x * s;
    this.y = y * s;
    this.z = z * s;
    this.w = Math.cos(a / 2);
    return this;
}

/**
 *  Returns the magniture of the quaternion.
 */
SQR.Quaternion.prototype.mag = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
}

/**
 *  Normalizes the quaternion.
 */
SQR.Quaternion.prototype.normalize = function() {
    var n = this.mag();
    this.x /= n;
    this.y /= n;
    this.z /= n;
    this.w /= n;
    return this;
}


/**
 *  Inverses the quaternion.
 */
SQR.Quaternion.prototype.neg = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
}

/**
 *  That method doesn't do anything. 
 *  Check {SQR.Matrix44.TQS()} to see how to turn a 
 *  Quanternion into a matrix representation.
 *
 *  @todo Implement (or not... not sure how much this is needed)
 */
SQR.Quaternion.prototype.toMatrix = function(m) {
    throw "SQR.Quaternion.toMatrix() is not implemented. Check SQR.Matrix44.TQS()"; 
}


// This one is from three.js (used for reference )
// SQR.Quaternion.slerp2 = function(qa, qb, t, qr) {

//     qr = qr || new SQR.Quaternion();


//     if ( t === 0 ) return qr.copyFrom(qa);
//     if ( t === 1 ) return qr.copyFrom(qb);

//     var x = qa.x, y = qa.y, z = qa.z, w = qa.w;

//     // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
//     var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

//     if (cosHalfTheta < 0) {
//         qr.w = - qb.w;
//         qr.x = - qb.x;
//         qr.y = - qb.y;
//         qr.z = - qb.z;
//         cosHalfTheta = - cosHalfTheta;
//     } else {
//         qr.copyFrom( qb );
//     }

//     if (cosHalfTheta >= 1.0) {
//         qr.w = w;
//         qr.x = x;
//         qr.y = y;
//         qr.z = z;
//         return qr;
//     }

//     var halfTheta = Math.acos( cosHalfTheta );
//     var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

//     if (Math.abs( sinHalfTheta ) < 0.001) {
//         qr.w = 0.5 * (w + qr.w);
//         qr.x = 0.5 * (x + qr.x);
//         qr.y = 0.5 * (y + qr.y);
//         qr.z = 0.5 * (z + qr.z);
//         return qr;
//     }

//     var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
//     ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

//     qr.w = (w * ratioA + qr.w * ratioB);
//     qr.x = (x * ratioA + qr.x * ratioB);
//     qr.y = (y * ratioA + qr.y * ratioB);
//     qr.z = (z * ratioA + qr.z * ratioB);

//     return qr;

// }

/**
 *  Returns a spherical linear interpolation between two quaternions.
 *  @param qa first quaternion
 *  @param qb second quaternion
 *  @param t interpolation value [0-1]
 *  @param qr the quaterion to store the results in and return. If omitted results are returned in a new quaternion object.
 */
SQR.Quaternion.slerp = function(qa, qb, t, qr) {
    qr = qr || new SQR.Quaternion();

    if (t === 0) return qr.copyFrom(qa);
    if (t === 1) return qr.copyFrom(qb);

    // Try taking the dot product of your two quaternions (i.e., the 4-D dot product), 
    // and if the dot product is negative, replace your quaterions q1 and q2 with -q1 and q2 before performing Slerp.
    // http://stackoverflow.com/questions/2886606/flipping-issue-when-interpolating-rotations-using-quaternions

    // (This is not working for me)


    var cha = SQR.Quaternion.dot(qa, qb);

    if(cha < 0) {
        qa.neg();
        cha = SQR.Quaternion.dot(qa, qb);
    }

    var ha = Math.acos(cha);
    var sha = Math.sqrt(1 - cha * cha);
    var ra = Math.sin((1 - t) * ha) / sha;
    var rb = Math.sin(t * ha) / sha;

    if (Math.abs(cha) >= 1) {
        // If angle is 0 (i.e cos(a) = 1) just
        // return the first quaternion
        ra = 1;
        rb = 0;
    } else if (Math.abs(sha) < 0.001) {
        // If angle is 180 deg (i.e. sin(a) = 0) there is
        // an infinite amount of possible rotations between those 2
        ra = 0.5;
        rb = 0.5;
    }

    qr.w = (qa.w * ra + qb.w * rb);
    qr.x = (qa.x * ra + qb.x * rb);
    qr.y = (qa.y * ra + qb.y * rb);
    qr.z = (qa.z * ra + qb.z * rb);
    return qr;
}

SQR.Quaternion.dot = function(qa, qb) {
    return qa.x * qb.x + qa.y * qb.y + qa.z * qb.z + qa.w * qb.w;
}

SQR.Quaternion.prototype.slerp = function(qa, qb, t) {
    SQR.Quaternion.slerp(qa, qb, t, this);
    return this;
}

SQR.Quaternion.__tv1 = new SQR.Quaternion();
SQR.Quaternion.__tv2 = new SQR.Quaternion();
SQR.Quaternion.__tv3 = new SQR.Quaternion();
















/* --- --- [math/Random.js] --- --- */

/*

This is the code from https://github.com/davidbau/seedrandom
with minor modifications.

Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
		width = 256,        // each RC4 output is 0 <= x < 256
		chunks = 6,         // at least six RC4 outputs for each double
		digits = 52,        // there are 52 significant digits in a double
		rngname = 'random', // rngname: name for Math.random and Math.seedrandom
		startdenom = math.pow(width, chunks),
		significance = math.pow(2, digits),
		overflow = significance * 2,
		mask = width - 1,
		nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
	var key = [];
	options = (options == true) ? { entropy: true } : (options || {});

	// Flatten the seed string or build one from local entropy if needed.
	var shortseed = mixkey(flatten(
		options.entropy ? [seed, tostring(pool)] :
		(seed == null) ? autoseed() : seed, 3), key);

	// Use the seed to initialize an ARC4 generator.
	var arc4 = new ARC4(key);

	// This function returns a random double in [0, 1) that contains
	// randomness in every bit of the mantissa of the IEEE 754 value.
	var prng = function() {
		var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
				d = startdenom,                 //   and denominator d = 2 ^ 48.
				x = 0;                          //   and no 'extra last byte'.
		while (n < significance) {          // Fill up all significant digits by
			n = (n + x) * width;              //   shifting numerator and
			d *= width;                       //   denominator and generating a
			x = arc4.g(1);                    //   new least-significant-byte.
		}
		while (n >= overflow) {             // To avoid rounding up, before adding
			n /= 2;                           //   last byte, shift everything
			d /= 2;                           //   right using integer math until
			x >>>= 1;                         //   we have exactly the desired bits.
		}
		return (n + x) / d;                 // Form the number within [0, 1).
	};

	prng.int32 = function() { return arc4.g(4) | 0; }
	prng.quick = function() { return arc4.g(4) / 0x100000000; }
	prng.double = prng;

	// Mix the randomness into accumulated entropy.
	mixkey(tostring(arc4.S), pool);

	// Calling convention: what to return as a function of prng, seed, is_math.
	return (options.pass || callback ||
			function(prng, seed, is_math_call, state) {
				if (state) {
					// Load the arc4 state from the given state if it has an S array.
					if (state.S) { copy(state, arc4); }
					// Only provide the .state method if requested via options.state.
					prng.state = function() { return copy(arc4, {}); }
				}

				// If called as a method of Math (Math.seedrandom()), mutate
				// Math.random because that is how seedrandom.js has worked since v1.0.
				if (is_math_call) { math[rngname] = prng; return seed; }

				// Otherwise, it is a newer calling convention, so return the
				// prng directly.
				else return prng;
			})(
	prng,
	shortseed,
	'global' in options ? options.global : (this == math),
	options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
	var t, keylen = key.length,
			me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

	// The empty key [] is treated as [0].
	if (!keylen) { key = [keylen++]; }

	// Set up S using the standard key scheduling algorithm.
	while (i < width) {
		s[i] = i++;
	}
	for (i = 0; i < width; i++) {
		s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
		s[j] = t;
	}

	// The "g" method returns the next (count) outputs as one number.
	(me.g = function(count) {
		// Using instance members instead of closure state nearly doubles speed.
		var t, r = 0,
				i = me.i, j = me.j, s = me.S;
		while (count--) {
			t = s[i = mask & (i + 1)];
			r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
		}
		me.i = i; me.j = j;
		return r;
		// For robust unpredictability, the function call below automatically
		// discards an initial batch of values.  This is called RC4-drop[256].
		// See http://google.com/search?q=rsa+fluhrer+response&btnI
	})(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
	t.i = f.i;
	t.j = f.j;
	t.S = f.S.slice();
	return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
	var result = [], typ = (typeof obj), prop;
	if (depth && typ == 'object') {
		for (prop in obj) {
			try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
		}
	}
	return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
	var stringseed = seed + '', smear, j = 0;
	while (j < stringseed.length) {
		key[mask & j] =
			mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
	}
	return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
	try {
		if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
		var out = new Uint8Array(width);
		(global.crypto || global.msCrypto).getRandomValues(out);
		return tostring(out);
	} catch (e) {
		var browser = global.navigator,
				plugins = browser && browser.plugins;
		return [+new Date, global, plugins, global.screen, tostring(pool)];
	}
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
	return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
	module.exports = seedrandom;
	// When in node.js, try using crypto package for autoseeding.
	try {
		nodecrypto = require('crypto');
	} catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
	define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
	[],     // pool: entropy pool starts empty
	Math    // math: package containing random, pow, and seedrandom
);

/* --- --- [math/Spline.js] --- --- */

/**
 *  @class Spline
 *  @memberof SQR
 *
 *  @description Represents a spline composed of multiple cubic beziers
 */
SQR.Spline = function() {

	// Bezier paths generated from segments/controlPoints in create() 
	var paths = [];

	// Points from the input source defining the path of the spline
	var segments = [];

	// Each segment has two control points (the "hands" coming out fo paths)
	var controlPoints = [];

	var s = {};

	var _tv1, _tv2;

	var getcontrolPoints = function(point, previous, next, c1, c2, smoothness) {
		var vab = _tv1.sub(point, previous).neg();
		var vcb = _tv2.sub(point, next);
		var d = (smoothness > 1) ? smoothness : smoothness * Math.min(vab.mag(), vcb.mag());
		c1.set().add(vab, vcb).norm().mul(d);
		c2.copyFrom(c1).neg();
		c1.add(c1, point);
		c2.add(c2, point);
	}

	s.addSegment = function(p) {
		var v;

		if(p.x !== undefined) {
			v = p;
		} else {
			var a = arguments, l = a.length;
			if(l == 2) v = new SQR.V2(a[0], a[1]);
			else if(l == 3) v = new SQR.V3(a[0], a[1], a[2]);
		}

		segments.push(v);
		controlPoints.push(v.clone(), v.clone());

		if(!_tv1) {
			_tv1 = segments[0].clone();
			_tv2 = segments[0].clone();
		}

		return s;
	}

	s.create = function(smoothness, close) {

		if(segments.length < 2) return segments;

		smoothness = (smoothness !== null) ? smoothness : 0.5;
		paths.length = 0;
		var firstPoint, firstControlPoint;

		var sg = segments, cp = controlPoints, sl = segments.length;
		
		for(var i = 0; i < sl; i++) {
			var si = sg[i];
			var c1 = cp[i * 2].set();
			var c2 = cp[i * 2 + 1].set();

			var a = (i == 0) ? sg[sl-1] : sg[i-1];
			var b = (i == sl-1) ? sg[0] : sg[i+1];

			getcontrolPoints(si, a, b, c1, c2, smoothness);
			cp.push(c1, c2);
		}

		for(var i = 0; i < sl-1; i++) {
			var a = sg[i];
			var b = (i == sl-1) ? sg[0] : sg[i+1];

			var c1 = (i == 0 && !close) ? a : cp[i * 2 + 1];
			var c2 = (i == sl-2 && !close) ? b : cp[i * 2 + 2];

			var c = new SQR.Bezier(a, c1, c2, b);
			paths.push(c);
		}

		if(close) {
			var c = new SQR.Bezier(sg[sl-1], cp[(sl-1)*2+1], cp[0], sg[0]);
			paths.push(c);
		}

		s.smoothness = smoothness;
		s.close = s.close;

		return s;
	}

	s.valueAt = function(t, v) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0].valueAt(tf % 1, v);
	}

	s.bezierAt = function(t) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0];
	}

	s.velocityAt = function(t, v) {
		if(t == 1) t = 0.999999;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0].velocityAt(tf % 1, v);
	}

	s.matrixAt = function(t, m) {
		if(t == 0) t = SQR.EPSILON;
		if(t == 1) t = 1 - SQR.EPSILON;
		t = t % 1;
		var tf = t * paths.length;
		return paths[tf | 0].matrixAt(tf % 1, m);
	}

	Object.defineProperty(s, 'segments', {
		get: function() { 
			return segments; 
		}
	});

	Object.defineProperty(s, 'paths', {
		get: function() { 
			return paths; 
		}
	});

	return s;

}

/* --- --- [math/Triangle.js] --- --- */

/**
 *  @class Triangle
 *  @memberof SQR
 *
 *  @description Represents a triangle composed on 3 vectors. 
 *	Vectors can be of any size, though some of it methods only work with 2-dimensional vectors.
 *
 *	@param v1 Vector {@link SQR.V2} or {@link SQR.V3}
 *
 *	@property {SQR.V2} centroid - the centroid, undef until `calculateCentroid` is called.
 *	@property {Number} circumRadius - the  radius of the 
 *		circum-circle, undef until `calculateCircumCircle` is called.
 *	@property {SQR.V2} circumCenter - the center of the cirsum-circle, 
 *		undef until `calculateCircumCircle` is called.
 *	
 */
SQR.Triangle = function(v0, v1, v2) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

	/**
	 *	Calculates the centroid for this triangle. Only works with 2d coordinates for now.
	 *	The resulting centroid is stored in the `centroid` property.
	 *
	 *	@memberof SQR.Triangle.prototype
	 *	@method calculateCentroid
	 */
	this.calculateCentroid = function() {
		this.centroid = new SQR.V2();
		this.centroid.x = (this.v0.x + this.v1.x + this.v2.x) / 3;
		this.centroid.y = (this.v0.y + this.v1.y + this.v2.y) / 3;
	}

	/**
	 *	Calculates circumcircle, only works with 2d coordinates.
	 *	<br><br>
	 *	Based on 
	 *	{@link http://jwilson.coe.uga.edu/emat6680/dunbar/assignment4/assignment4_kd.htm this}
	 *	and
	 *	{@link http://www.exaflop.org/docs/cgafaq/cga1.html this}.
	 *
	 *	@memberof SQR.Triangle.prototype
	 *	@method calculateCircumCircle
	 */
	this.calculateCircumCircle = function() {
		var A = this.v1.x - this.v0.x;
		var B = this.v1.y - this.v0.y;
		var C = this.v2.x - this.v0.x;
		var D = this.v2.y - this.v0.y;

		var E = A * (this.v0.x + this.v1.x) + B * (this.v0.y + this.v1.y);
		var F = C * (this.v0.x + this.v2.x) + D * (this.v0.y + this.v2.y);

		var G = 2.0 * (A * (this.v2.y - this.v1.y) - B * (this.v2.x - this.v1.x));

		var dx, dy;

		if (Math.abs(G) < SQR.EPSILON) {
			// Collinear - find extremes and use the midpoint
			var minx = Math.min(this.v0.x, this.v1.x, this.v2.x);
			var miny = Math.min(this.v0.y, this.v1.y, this.v2.y);
			var maxx = Math.max(this.v0.x, this.v1.x, this.v2.x);
			var maxy = Math.max(this.v0.y, this.v1.y, this.v2.y);

			this.circumCenter = new SQR.V2((minx + maxx) / 2, (miny + maxy) / 2);

			dx = this.circumCenter.x - minx;
			dy = this.circumCenter.y - miny;
		} else {
			var cx = (D * E - B * F) / G;
			var cy = (A * F - C * E) / G;

			this.circumCenter = new SQR.V2(cx, cy);

			dx = this.circumCenter.x - this.v0.x;
			dy = this.circumCenter.y - this.v0.y;
		}

		this.circumRadiusSq = dx * dx + dy * dy;
		this.circumRadius = Math.sqrt(this.circumRadiusSq);
	}

	/**
	 *	Test whether the point v is inside the triangles circumcircle. 
	 *	If circum-circle was not calculated, calculateCircumCircle will be called first
	 *	@memberof SQR.Triangle.prototype
	 *	@method vertexInCircumcircle
	 *	@param {SQR.V2} v - vertex to be checked
	 *	@returns {boolean} true is vertex is in circumcircle
	 */
	this.vertexInCircumcircle = function(v) {

		if(!this.circumCenter) this.calculateCircumCircle();

		var dx = this.circumCenter.x - v.x;
		var dy = this.circumCenter.y - v.y;
		var sq = dx * dx + dy * dy;
		return (sq <= this.circumRadiusSq);

	}

	this.get = function(i) {
		if(i == 0) return this.v0;
		if(i == 1) return this.v1;
		if(i == 2) return this.v2;
	}

};

/* --- --- [math/Vector2.js] --- --- */

/**
 *  @class V2
 *  @memberof SQR
 *
 *  @description A 2-dimensional vector
 *
 */
SQR.V2 = function(x, y) {
	this.set(x, y);
	this.size = 2;
}

SQR.V2.prototype.set = function(x, y) {
	this.x = x || 0;
	this.y = y || 0;
	return this;
}

SQR.V2.prototype.copyTo = function(p) {
	p.x = this.x;
	p.y = this.y;
	return p;
}

SQR.V2.prototype.copyFrom = function(p) {
	if(p instanceof Array) {
		this.x = p[0];
		this.y = p[1];
	} else {
		this.x = p.x;
		this.y = p.y;
	}
	return this;
}

SQR.V2.prototype.clone = function() {
	return new SQR.V2(this.x, this.y);
}

SQR.V2.prototype.magsq = function() {
	return this.x * this.x + this.y * this.y;
};

SQR.V2.prototype.mag = function() {
	return Math.sqrt(this.magsq());
};

SQR.V2.prototype.isZero = function() {
	return this.x == 0 && this.y == 0;
};

SQR.V2.prototype.mul = function(s) {
	this.x *= s;
	this.y *= s;
	return this;
}

SQR.V2.prototype.neg = function() {
	this.x = -this.x;
	this.y = -this.y;
	return this;
}

SQR.V2.prototype.norm = function() {
	var m = 1 / this.mag();
	this.set(this.x * m, this.y * m);
	return this;
}

/**
 * a.add(a, b).add(a, c) -> a + b + c
 *
 * @param a
 * @param b
 */
SQR.V2.prototype.add = function(a, b) {
	b = b || this;
	this.x = a.x + b.x;
	this.y = a.y + b.y;
	return this;
}

/**
 * a.sub(b, a) ->  a = from a to b
 *
 * @param a
 * @param b
 */
SQR.V2.prototype.sub = function(a, b) {
	b = b || this;
	this.x = a.x - b.x;
	this.y = a.y - b.y;
	return this;
}

SQR.V2.prototype.lerp = function(a, b, t) {
	this.x = a.x + (b.x - a.x) * t;
	this.y = a.y + (b.y - a.y) * t;
	return this;
}

SQR.V2.dot = function(a, b) {
	return (a.x * b.x + a.y * b.y)
}

SQR.V2.prototype.perp = function() {
	this.set(this.y, -this.x);
	return this;
}

SQR.V2.prototype.toUniform = function() {
	return this.toArray();
}

SQR.V2.prototype.toArray = function() {
	if(!this.array) this.array = new Float32Array(2);
	this.array[0] = this.x;
	this.array[1] = this.y;
	return this.array;
}

/* --- --- [math/Vector3.js] --- --- */

/**
 *  @class V3
 *  @memberof SQR
 *
 *  @descrption A 3-dimensional vector
 *
 */
SQR.V3 = function(x, y, z) {
	this.set(x, y, z)
	this.size = 3;
	SQR.V3.instances++;
}

/**
 *  Sets the vector compoment to values. Note that this class has actually 4 not 3 compoments.
 *  @param x - the value of the x compoment
 *  @param y - the value of the y compoment
 *  @param z - the value of the z compoment
 *  @param w - the value of the homogeneous coordinate, defaults to 1 
 *      and leave it that way unless you really know what ypu are doing.
 */ 
SQR.V3.prototype.set = function(x, y, z, w) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = w || 1;
	return this;
}

/**
 *  Copies values from this vector into the p vector
 *
 *  @param {SQR.V2|SQR.V3} p - vector to copy the values to
 */
SQR.V3.prototype.copyTo = function(p) {
	p.x = this.x;
	p.y = this.y;
	if(p.z != undefined) p.z = this.z;
	return p;
}

/**
 *  Copies values from vector p into this vector
 *
 *  @param {SQR.V2|SQR.V3} p - vector to copy the values from
 */
SQR.V3.prototype.copyFrom = function(p) {
	if(p instanceof Array) {
		this.x = p[0];
		this.y = p[1];
		this.z = p[2] || 0; // in case p is SQR.V2
	} else {
		this.x = p.x;
		this.y = p.y;
		this.z = p.z || 0; // in case p is SQR.V2
	}
	return this;
}

/**
 *  Creates and returns a copy of this vector. 
 *  Be careful with this method, because it creates a new object. 
 *  Calling this function repeatedly in a rendering loop can have an adverce impact on performance.
 *
 *  @returns {SQR.V3} a new vector that is a copy of this vector
 */
SQR.V3.prototype.clone = function() {
	return new SQR.V3(this.x, this.y, this.z);
}

/** 
 *  Returns the squared length of this vector. This can be useful to optimize some calculations, since
 *  the actual length requires a squareroot operation (`Math.sqrt()`) 
 *  which can be slow if used on many vectors.
 */
SQR.V3.prototype.magsq = function() {
	return this.x * this.x + this.y * this.y + this.z * this.z;
};

/**
 *  Return the length (magnitude) of this vector
 *  @returns {Number} the length of this vector
 */
SQR.V3.prototype.mag = function() {
	return Math.sqrt(this.magsq());
};

/**
 *  Shorthand to check if this vector is a zero vector 
 *  (i.e. all compoments are very small or equal to 0) The values are compared against SQR.EPSILON
 */
SQR.V3.prototype.isZero = function() {
	return Math.abs(this.x) < SQR.EPSILON &&  Math.abs(this.y) < SQR.EPSILON && Math.abs(this.z) < SQR.EPSILON;
};

/**
 *  Multiples this vector by a scalar. 
 *  This function can be used in conjunction with {@link SQR.V3#norm} 
 *  to set the vector to a given length `v.norm().mul(10)1 yields a vector of length 10.
 *
 *  @param {Number} s - the value to multiply the the vector by.
 */
SQR.V3.prototype.mul = function(s) {
	this.x *= s;
	this.y *= s;
	this.z *= s;
	return this;
}

/**
 *  Negates this vector.
 */
SQR.V3.prototype.neg = function() {
	this.x = -this.x;
	this.y = -this.y;
	this.z = -this.z;
	return this;
}

/**
 *  Normalizes this vector, i.e. sets its length (magnitude) to 1.
 */
SQR.V3.prototype.norm = function() {
	var m = 1 / this.mag();
	this.set(this.x * m, this.y * m, this.z * m);
	return this;
}

/**
 *  Sets this vector to the sum of a and b. 
 *
 *  @example
a.add(b, c); // a = b + c
a.add(a, b); // a += b
a.add(b);    // alt a += b
a.add(a, b).add(a, c); // = a + b + c
 *
 *  @param {SQR.V3} a
 *  @param {SQR.V3=} b - if omitted the current vector is used, which basically means that a is added to current vector.
 */
SQR.V3.prototype.add = function(a, b) {
	b = b || this;
	this.x = a.x + b.x;
	this.y = a.y + b.y;
	this.z = a.z + b.z;
	return this;
}

/**
 * a.sub(b, a) ->  a = from a to b
 *
 * @param a
 * @param b
 */
SQR.V3.prototype.sub = function(a, b) {
	this.x = a.x - b.x;
	this.y = a.y - b.y;
	this.z = a.z - b.z;
	return this;
}

SQR.V3.prototype.lerp = function(a, b, t) {
	this.x = a.x + (b.x - a.x) * t;
	this.y = a.y + (b.y - a.y) * t;
	this.z = a.z + (b.z - a.z) * t;
	return this;
}

SQR.V3.prototype.random = function() {
	this.x = Math.random() * 2 - 1;
	this.y = Math.random() * 2 - 1;
	this.z = Math.random() * 2 - 1;
	return this;
}

/**
 *  Returns the dot product of a nd b (`a . b`).
 *  @returns {Number} result of a . b
 */
SQR.V3.dot = function(a, b) {
	return a.x * b.x + a.y * b.y + a.z * b.z;
}

/**
 *  Sets this vector to the result of a cross-product of a and b (`a x b`).
 */
SQR.V3.prototype.cross = function(a, b) {
	var x = a.y * b.z - a.z * b.y;
	var y = a.z * b.x - a.x * b.z;
	var z = a.x * b.y - a.y * b.x;
	this.set(x, y, z, this.w);
	return this;
}

/**
 *  @private
 *  @description Alias for toArray
 *
 *  @returns {Float32Array} array - the array holding the values of this vector
 */
SQR.V3.prototype.toUniform = function() {
	return this.toArray();
}

/**
 *  @private
 *  @description Lazily creates a Float32Array and stores 
 *  the components of this vector in the array.
 *  This is mostly used when the value of this vector is 
 *  passed as uniform to a shader
 *  (this function is called internally by the renderer).
 *
 *  @returns {Float32Array} array - the array holding the values of this vector
 */
SQR.V3.prototype.toArray = function() {
	if(!this.array) this.array = new Float32Array(3);
	this.array[0] = this.x;
	this.array[1] = this.y;
	this.array[2] = this.z; 
	return this.array;
}

SQR.V3.prototype.toString = function toString() {
  return x;
}

/**
 *  Assuming the vector was projected using the {@link SQR.ProjectionMatrix}, use this
 *  to calculate it's screen space. (useful for software rendering, ex. on canvas 2d)
 *
 *  @param {Number=} w - the width of the screen (defaults to `window.innerWidth`) 
 *  @param {Number=} h - the height of the screen (defaults to `window.innerHeight`) 
 */
SQR.V3.prototype.toScreenSpace = function(w, h) {
	w = w || window.innerWidth;
	h = h || window.innerHeight;
	this.x = (this.x / this.z) * w/2 + w/2;
	this.y = (this.y / this.z) * h/2 + h/2;

	// TODO: make sure this is ok to be here in any case
	this.y = h - this.y;
}

/**
 *  Use this for caculating per-vertex normals. 
 *  A normal from each contributing face can be added here. 
 *  When all the normals are added, a vector that is the sum of them all 
 *  is available as `this.normal` property. The pre-vertex normal can be caluculated
 *  by normalizing this vector.
 */
SQR.V3.prototype.addNormal = function(_n) {

	if(!this.normal) {
		this.normal = new SQR.V3();
	}

	this.normal.add(this.normal, _n);
}

/** 
 *  This is used to reset the normal to 0,0,0.
 */
SQR.V3.prototype.resetNormal = function(_n) {
	if(this.normal) this.normal.set();
}


/**
 *  @const
 *  @memberof SQR.V3
 *  @description A constant the defines the up vector. 
 *  WARNING: be extremly careful not to modify the values of this vector, because this will cause some
 *  matrix functions, like {@link SQR.Matrix44#lookAt} to not fuction properly.
 */
SQR.V3.up = new SQR.V3(0,1,0);

/**
 *  @const
 *  @memberof SQR.V3
 *  @description A constant the defines the forward vector. 
 *  WARNING: be extremly careful not to modify the values of this vector, because this will cause some
 *  matrix functions to not fuction properly.
 */
SQR.V3.forward = new SQR.V3(0,0,1);

SQR.V3.__tv1 = new SQR.V3();
SQR.V3.__tv2 = new SQR.V3();
SQR.V3.__tv3 = new SQR.V3();

SQR.V3.instances = 0;

/* --- --- [two/CanvasRenderer.js] --- --- */

/**
 *  @class CanvasRenderer
 *  @memberof SQR
 *
 *  @description Part of a minimal Canvas 2d rendering engine. The paremeter is a canvas element or a selector (ex. #gl-canvas) 
 *	can be passed to this function. If omitted a new canvas element will be created
 *	and it will be available as the canvas property of the object.
 *
 *	@param {HTMLCanvasElement} the underlying canvas element
 *	@property {HTMLCanvasElement} the underlying canvas element
 */
SQR.CanvasRenderer = function(canvas) {

	var r = {}, clearColor = null;

	var BADCTX = "> SQR.Context - Invalid canvas reference.";

	if(!canvas) canvas = document.createElement('canvas');
	if(!(canvas instanceof HTMLElement)) canvas = document.querySelector(canvas);
	if(!canvas.getContext) throw BADCTX;

	var ctx = canvas.getContext('2d');

	// Dash line shim
	if(!ctx.setLineDash) ctx.setLineDash = function() {};

	r.canvas = canvas;
	r.context = ctx;

	/** 
	 *	Set the size of the underlying canvas element.
	 *	@method setSize
	 *	@memberof SQR.CanvasRenderer.prototype
	 *	@param {Number} w - the width of the canvas
	 *	@param {Number} h - the height of the canvas
	 *	@param {Number} r - the resolution (aka pixel ratio)
	 */
	r.setSize = function(w, h, r) {
		r = r || 1;
		canvas.width = w * r;
		canvas.height = h * r;
		canvas.style.width = w + 'px';
		canvas.style.height = h + 'px';
		return r;
	}

	r.setClearColor = function(c) {
		clearColor = c;
		return r;
	}

	/**
	 *	Render the transform tree
	 *	@method render
	 *	@memberof SQR.CanvasRenderer.prototype
	 *	@param {SQR.Transform2d} root - the root transform to render
	 */
	r.render = function(root) {
		if(clearColor) {
			
			if(clearColor.indexOf('rgba') > -1) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
			}

			ctx.fillStyle = clearColor;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
		} else {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
		}
		

		if(root) root.draw(ctx);
	}

	return r;
}

/* --- --- [two/Transform2d.js] --- --- */

/**
 *  @class Transform2d
 *  @memberof SQR
 *
 *  @description Similar to {SQR.Transform} but specialized to work with 2d rendeirng on a 2d canvas element.
 *  
 */
SQR.Transform2d = function(name) {

	var t = {};

	t.name = name || 'sqr.transform.' + SQR.Transform2dCount++;

    /** 
     *  @var {SQR.V3} position - the position of this transform relative to it's parent.
     *  It's a 3d vector, because z is used for depth indexing.
     *  @memberof SQR.Transform2d.prototype
     */
	t.position = new SQR.V3(0, 0, 0);

    /**
     *  @var {SQR.V3} rotation - the rotation of the transform in radians
     *  @memberof SQR.Transform2d.prototype
     */
	t.rotation = 0;

    /**
     *  @var {SQR.V2} scale - the scale of the object on x and y axis
     *  @memberof SQR.Transform2d.prototype
     */
	t.scale = new SQR.V2(1, 1);

    /**
     *  @var {Number} alpha - the transparency of this element. 
     *  @memberof SQR.Transform2d.prototype
     *  0 = transparent, 1 = opaque, default 1
     */
    t.alpha = 1;

	t.children = [], t.numChildren = 0;

   /**
    *   @method add
    *   @memberof SQR.Transform2d.prototype
    *   
    *   @description Add a child transform. Accepts multiple arguments but all of them need to be of type {SQR.Transform2D}.
    *   It doesn't do any sort of type checking so if you add non object that are not {SQR.Transform2D} 
    *   it will result in errors when the scene is rendered.
    */
    t.add = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            c.parent = t;
            if (t.children.indexOf(c) == -1) t.children.push(c);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method remove
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Removes a child transform. Accepts multiple arguments 
     *  but all of them need to be of type {SQR.Transform2D}
     */
    t.remove = function() {
        for (var i = 0; i < arguments.length; i++) {
            var c = arguments[i];
            var j = t.children.indexOf(c);
            if (j == -1) return false;
            c.parent = null;
            t.children.splice(j, 1);
        }
        t.numChildren = t.children.length;
        return t;
    }

    /**
     *  @method removeAll
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Removes all children transform.
     */
    t.removeAll = function() {
        t.children.length = 0;
        t.numChildren = 0;
    }

    /**
     *  @method contains
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Checks if transform is child of this transfom
     *  @param {SQR.Transform2D} c the transform to look for
     */
    t.contains = function(c) {
        return t.children.indexOf(c) > -1;
    }

    /**
     *  @method recurse
     *  @memberof SQR.Transform2d.prototype
     *   
     *  @description Execute this function on all the child transforms including this current one.
     *
     *  @param {function} f the function that will be called on each child. 
     *  This function will receive the transform as argument.
     *
     *  @param {boolean} excludeSelf if set to true, the function will only be called for all 
     *  the ancestors of the Transform.
     */
    t.recurse = function(f, excludeSelf) {
       if(!excludeSelf) f(t);
        for (var i = 0; i < t.numChildren; i++) {
            t.children[i].recurse(f);
        }
    }

    t.draw = function(context) {
        var c = context;

    	c.save();
    	c.translate(t.position.x, t.position.y);
    	c.rotate(t.rotation);

        c.scale(t.scale.x, t.scale.y);

    	// First draw the children, then self, so that alpha/scale do not affect children
        // * Not sure why scale should not affect children, so moving this before drawing children (check again)

    	for(var i = 0; i < t.numChildren; i++) t.children[i].draw(c);

        if(t.alpha < 1) c.globalAlpha = t.alpha;
        // c.scale(t.scale.x, t.scale.y);
        if(t.shape) t.shape(c, t);

    	c.restore();
	}

	return t;
}

SQR.Transform2dCount = 0;









/* --- --- [primitives/Cube.js] --- --- */

/**
 *  @method createCube
 *  @memberof SQR.Primitives
 *
 *  @description Creates a simple cube geometry, 1 quad per side, with UVs, non-indexed
 *
 *	@param {Number} w - width of the cube
 *	@param {Number} h - height of the cube
 *	@param {Number} d - depth of the cube
 *
 *	@returns {SQR.Buffer}
 */
SQR.Primitives.createCube = function(w, h, d, options) {

	w = w || 1;
	h = h || 1;
	d = d || 1;
	options = options || {};

	var m = new SQR.Mesh();


	var 
		v0 = m.V(w * -0.5,   h *  0.5,   d *  0.5), // Top left
		v1 = m.V(w *  0.5,   h *  0.5,   d *  0.5), // Top right 
		v2 = m.V(w * -0.5,   h * -0.5,   d *  0.5), // Bottom left 
		v3 = m.V(w *  0.5,   h * -0.5,   d *  0.5), // Bottom right

		v4 = m.V(w * -0.5,   h *  0.5,   d * -0.5), // Top left
		v5 = m.V(w *  0.5,   h *  0.5,   d * -0.5), // Top right
		v6 = m.V(w * -0.5,   h * -0.5,   d * -0.5), // Bottom left
		v7 = m.V(w *  0.5,   h * -0.5,   d * -0.5), // Bottom right

		u0 = m.T(0, 1),
		u1 = m.T(1, 1),
		u2 = m.T(0, 0),
		u3 = m.T(1, 0);

	
	m.F(v0, v1, v2, v3).T(u0, u1, u2, u3);
	m.F(v5, v4, v7, v6).T(u0, u1, u2, u3);
	m.F(v4, v0, v6, v2).T(u0, u1, u2, u3);
	m.F(v1, v5, v3, v7).T(u0, u1, u2, u3);
	m.F(v4, v5, v0, v1).T(u0, u1, u2, u3);
	m.F(v2, v3, v6, v7).T(u0, u1, u2, u3);

	m.calculateNormals(options.smooth);
	if(options.flip) m.flip();

	return m.update();


	// var V2 = this.V2, V3 = this.V3, F = this.F(options);

	// w = w || 1;
	// h = h || 1;
	// d = d || 1;

	// var geo = SQR.Buffer().layout(SQR.v3n3u2(), 36);
	
	// var 
	// 	v0 = V3(w * -0.5,   h *  0.5,   d *  0.5), // Top left
	// 	v1 = V3(w *  0.5,   h *  0.5,   d *  0.5), // Top right 
	// 	v2 = V3(w * -0.5,   h * -0.5,   d *  0.5), // Bottom left 
	// 	v3 = V3(w *  0.5,   h * -0.5,   d *  0.5), // Bottom right

	// 	v4 = V3(w * -0.5,   h *  0.5,   d * -0.5), // Top left
	// 	v5 = V3(w *  0.5,   h *  0.5,   d * -0.5), // Top right
	// 	v6 = V3(w * -0.5,   h * -0.5,   d * -0.5), // Bottom left
	// 	v7 = V3(w *  0.5,   h * -0.5,   d * -0.5), // Bottom right

	// 	u0 = V2(0, 1),
	// 	u1 = V2(1, 1),
	// 	u2 = V2(0, 0),
	// 	u3 = V2(1, 0);

	// F(v0, v1, v2, v3).uv(u0, u1, u2, u3);
	// F(v5, v4, v7, v6).uv(u0, u1, u2, u3);
	// F(v4, v0, v6, v2).uv(u0, u1, u2, u3);
	// F(v1, v5, v3, v7).uv(u0, u1, u2, u3);
	// F(v4, v5, v0, v1).uv(u0, u1, u2, u3);
	// F(v2, v3, v6, v7).uv(u0, u1, u2, u3);
	// F.toBuffer(geo);
	// return geo.update();
}

/*
SQR.Primitives.createSkybox = function(options) {

	options = options || {};
	options.size = options.size || 5;
	options.useDepth = (options.useDepth === undefined) ? false : options.useDepth;

	if(!options.glsl && SQR.GLSL) {
		if(options.use2dTextures) 
			options.glsl = SQR.GLSL['shaders/skybox-2d.glsl'];
		else 
			options.glsl = SQR.GLSL['shaders/skybox-cube.glsl'];
	}

	if(!options.glsl) throw "Missing shader code. Pass GLSL string as 2nd argument or include sqr-glsl.js to use the default one.";

	var skybox = new SQR.Transform();
	var shader = SQR.Shader(options.glsl);

	if(options.use2dTextures) {

		var planeOptions = { zUp: true };
		var s = options.size;
		var buffer = SQR.Primitives.createPlane(s, s, 1, 1, 0, 0, planeOptions);

		var side = function(name) {
			var f = new SQR.Transform(name);
			f.shader = shader;
			f.useDepth = options.useDepth;
			f.buffer = buffer;
			return f;
		}

		var front = side('front', planeOptions);
		front.position.z = s * -0.5;

		var back = side('back', planeOptions);
		back.position.z = s * 0.5;
		back.rotation.y = Math.PI;

		var left = side('left', planeOptions);
		left.position.x = s * -0.5;
		left.rotation.y = Math.PI * -0.5;

		var right = side('right', planeOptions);
		right.position.x = s * 0.5;
		right.rotation.y = Math.PI * 0.5;

		var up = side('up');
		up.position.y = s * 0.5;

		var down = side('down');
		down.position.y = s * -0.5;
		down.rotation.x = Math.PI;

		skybox.add(front, back, left, right, up, down);

		skybox.setTexture = function(f) {
			if(!f) return;

			console.log(f);

			front.uniforms = { uTexture: SQR.Texture(f.front) };
			back.uniforms = { uTexture: SQR.Texture(f.back) };
			left.uniforms = { uTexture: SQR.Texture(f.left) };
			right.uniforms = { uTexture: SQR.Texture(f.right) };
			up.uniforms = { uTexture: SQR.Texture(f.up) };
			down.uniforms = { uTexture: SQR.Texture(f.down) };
		}

	} else {

		var s = options.size;

		skybox.buffer = SQR.Primitives.createCube(s, s, s, { reverseNormals: true });
		skybox.shader = shader;
		skybox.useDepth = options.useDepth;

		skybox.setTexture = function(f) {
			if(!f) return;
			skybox.cubemap = SQR.Cubemap(f);
			skybox.shader.use().setUniform('uCubemap', skybox.cubemap);
		}
	} 

	if(options.faces) skybox.setTexture(options.faces);

	return skybox;
}
*/
























/* --- --- [primitives/Cylinder.js] --- --- */

/**
 *  @method createCylinder
 *  @memberof SQR.Primitives
 *
 *  @description Creates a cylinder with UVs, non-indexed
 *
 *  @param {Number} height - height of the cylinder
 *  @param {Number} radius - radius of the cylinder
 *  @param {Number} segments - number of segments along the cylinder
 *  @param {Object} options - additional options
 *
 *  @todo document the options
 *
 *  @returns {SQR.Buffer}
 */
SQR.Primitives.createCylinder = function(height, radius, segments, options) {

    options = options || {};

    var topVectors, bottomVectors, topUV, bottomUV;
    var topMiddle, bottomMiddle;

    var faces = [], vertices = [], normals = [], texcoords = [];

    var addFace = function(v1, v2, v3, v4, t1, t2, t3, t4) {
        var f = new SQR.Face().setPosition(v1, v2, v3, v4).setUV(t1, t2, t3, t4);
        faces.push(f);
    }

    topVectors = [];
    bottomVectors = [];
    topUV = [];
    bottomUV = [];

    for(var i = 0; i < segments; i++) {

        var t = new SQR.V3(), b = new SQR.V3();
        var tuv = new SQR.V2(), buv = new SQR.V2();

        var cos = Math.cos(i / segments * SQR.TWOPI) * radius;
        var sin = Math.sin(i / segments * SQR.TWOPI) * radius;

        if(options.vertical) {
            t.set(sin, height * -0.5, cos);
            b.set(sin, height *  0.5, cos);
        } else {
            t.set(height * -0.5, cos, sin);
            b.set(height *  0.5, cos, sin);
        }

        tuv.set(i/segments, 0);
        buv.set(i/segments, 1);

        if(!options.noCaps) {
            if(options.vertical) {
                topMiddle = new SQR.V3(0, height * -0.5, 0);
                bottomMiddle = new SQR.V3(0, height *  0.5, 0);
            } else {
                topMiddle = new SQR.V3(height * -0.5, 0, 0);
                bottomMiddle = new SQR.V3(height *  0.5, 0, 0);
            }
        }

        topVectors.push(t);
        bottomVectors.push(b);

        topUV.push(tuv);
        bottomUV.push(buv);

        if(options.insideFaces) {
            t._inside = t.clone();
            b._inside = b.clone();
        }
    }

    for(var i = 0; i < segments; i++) {
        
        var t0 = topVectors[i];
        var b0 = bottomVectors[i];
        var t0uv = topUV[i];
        var b0uv = bottomUV[i];

        var n = (i + 1) % segments;

        var t1 = topVectors[n];
        var b1 = bottomVectors[n];
        var t1uv = topUV[n];
        var b1uv = bottomUV[n];

        options.heightSegments = options.heightSegments || options.hs || 0;

        if(!options.heightSegments) {

            addFace(t0, b0, t1, b1, t0uv, b0uv, t1uv, b1uv);           

            if(options.noCaps && options.insideFaces) {
                addFace(t0._inside, t1._inside, b0._inside, b1._inside, t0uv, b0uv, t1uv, b1uv);
            }
        } else {
            var t0b0 = new SQR.V3().sub(b0, t0);
            var t1b1 = new SQR.V3().sub(b1, t1);

            var t0l = new SQR.V3().copyFrom(t0);
            var t1l = new SQR.V3().copyFrom(t1);

            var t0c = new SQR.V3();
            var t1c = new SQR.V3();

            var n = options.heightSegments;

            for(var hs = 0; hs < n + 1; hs++) {
                t0c.copyFrom(t0b0).mul(1/n * hs).add(t0, t0c);
                t1c.copyFrom(t1b1).mul(1/n * hs).add(t1, t1c);

                addFace(t0l.clone(), t0c.clone(), t1l.clone(), t1c.clone(), t0uv, b0uv, t1uv, b1uv);  

                t0l.copyFrom(t0c);
                t1l.copyFrom(t1c);
            }
        }

        if(!options.noCaps) {
            addFace(t0, t1, topMiddle, null, b0uv, b1uv, t1uv);
            addFace(b1, b0, bottomMiddle, null, b1uv, b0uv, t1uv);
        }         
    }

    var l = options.layout || {'aPosition': 3, 'aNormal': 3, 'aUV': 2 };

    var geo = SQR.Buffer()
        .layout( l, faces.length * 6);

    var c = 0, t;
    faces.forEach(function(t) {
        c += t.calculateNormal().toBuffer(geo, c);
    });

    return geo;
    
}

/* --- --- [primitives/Extrude.js] --- --- */

/*

       b(0,0,0)
          /\
         /__\
a(-1,2,0)    c(1,2,0)


spline(c1, c2, c3)

sc[
	a.1
	b.2
	c.3
]

sc [
	a.4
	b.5
	c.6
]

for each sc transform by curve matrix

f(sc[1].a, sc[2].b, sc[1].b)
f(sc[1].a, sc[2].a, sc[2].b)

f(sc[1].b, sc[2].c, sc[1].c)
f(sc[1].b, sc[2].b, sc[2].c)

f(sc[1].c, sc[2].a, sc[1].a)
f(sc[1].c, sc[2].c, sc[2].a)


set all sc to aPosition + aOrder
for each face set indices to indices

*/
SQR.Extrude = function() {

	var e = {};

	e.buffer = SQR.Buffer();

	var shape, shapeSize, path, resolution, range, start, end, cap;
	var vertices = [], faces = [];

	/**
	 *	_shape - array of SQR.V2 defining the profile shape
	 *	_path - SQR.Curve along which the extrude takes place
	 *	_resolution - how many times the shape will be repeated along the path. Less than 2 doesnt make sense, default is 10
	 *	_layout - the layout of the buffer to create, default SRQ.v3n3() i.e. a 3D vertex + 3D normal
	 */
	e.setPaths = function(_shape, _path, _resolution, _layout) {
		shape = _shape;
		shapeSize = _shape.length;
		path = _path;
		resolution = _resolution || 10;
		setVertices(_layout);
		return e;
	}

	e.makeCaps = function() {
		// TODO: implement
		return e;
	}

	var setVertices = function(layout) {
		vertices.length = 0;
		faces.length = 0;
		layout = layout || SQR.v3n3();

		for(var i = 0; i < resolution; i++) {
			for(var j = 0; j < shapeSize; j++) {
				var v = new SQR.V3();
				vertices.push(v);
			}
		}

		for(var i = 0; i < resolution - 1; i++) {
			for(var j = 0; j < shapeSize; j++) {
				// f(sc[1].a, sc[2].b, sc[1].b)
				// f(sc[1].a, sc[2].a, sc[2].b)
				var _1a = i * shapeSize + j;
				var _1b = (j < shapeSize - 1) ? _1a + 1 : i * shapeSize;
				var _2a = (i + 1) * shapeSize + j;
				var _2b = (j < shapeSize - 1) ? _2a + 1 : (i + 1) * shapeSize;

				var f1 = new SQR.Face().setPosition(vertices[_1a], vertices[_2b], vertices[_1b]);
				var f2 = new SQR.Face().setPosition(vertices[_1a], vertices[_2a], vertices[_2b]);

				faces.push(f1, f2);
			}
		}

		e.buffer.layout(layout, faces.length * 3);
	}

	var update = function(scalingFunc, ampFunc) {

		for(var i = 0; i < resolution; i++) {

			var tg = (i / (resolution - 1));
			var t = start + tg * range;
			var m = path.matrixAt(t);

			for(var j = 0; j < shapeSize; j++) {
				var v = vertices[i * shapeSize + j];
				v.copyFrom(shape[j]);
				if(scalingFunc) scalingFunc(tg, v, e);
				m.transformVector(v);
				if(ampFunc) ampFunc(tg, v, e);
			}
		}

		var c = 0;
		for(var i = 0, fl = faces.length; i < fl; i++) {
			c += faces[i].calculateNormal().toBuffer(e.buffer, c, false, true);
		}
	}

	e.update = function(_start, _end, _scalingFunc, _ampFunc) {
		start = _start || 0;
		end = _end || 1;
		range = (end - start);	
		update(_scalingFunc, _ampFunc);
		e.buffer.update();
		return e;
	}

	return e;
}




















/* --- --- [primitives/Face.js] --- --- */

/**
 *  @description Face is a triangle or a quad.
 *  If the face is a quad, both triangles composin the quad,
 *  shader the same normal - thanks to this flat shaded materials have quads shaded
 *  the same way which is nicer than havong each triangle have a slightly different normal.
 *
 *  Currently it supports the following attributes: aPosition, aNormal, aUV and aColor. 
 *	Should support aTangent and aBinormal soon too.
 *
 *  @class Face
 *  @memberof SQR
 *
 */
SQR.Face = function() {
	if(!(this instanceof SQR.Face)) return new SQR.Face();
}

/**
 *  Set the vertex positions. For vertices a, b, c, and d is creates a quad as in the example below.
 *
 *  @method setPosition
 *  @memberof SQR.Face.prototype
 *
 *  @param {SQR.V3} a - the first vertex position
 *  @param {SQR.V3} b - the second vertex position
 *  @param {SQR.V3} c - the thrid vertex position
 *  @param {SQR.V3=} d - the optional fourth vertex position
 *
 *  @example
//
// a - b
// | / |
// c - d  
// 
// resulting triangles: `abc, cbd`
// 
 */
SQR.Face.prototype.setPosition = function(a, b, c, d) {
	var t = this;
	t.a = a || new SQR.V3(); 
	t.b = b || new SQR.V3(); 
	t.c = c || new SQR.V3();
	t.d = d;
	return t;
}

SQR.Face.prototype.setIndex = function(va, ia, ib, ic, id) {
	var t = this;
	t.indexed = true;
	t.ia = ia;
	t.ib = ib;
	t.ic = ic;
	t.id = id;
	t.vertexArray = va;
	return t;
}

SQR.Face.prototype.flip = function() {
	var t = this;
	var tmp = t.b;
	t.b = t.c;
	t.c = tmp;
}

/**
 *  Set the normal shared by all the vertices
 *  @method setNormal
 *  @memberof SQR.Face.prototype 
 */
SQR.Face.prototype.setNormal = function(n) {
	this.normal = n;
	return this;
}

/**
 *  Set the texture coordinates for each vertex
 *
 *  @method setUV
 *  @memberof SQR.Face.prototype 
 *
 *  @param {SQR.V2} a - the first vertex texture coordinate
 *  @param {SQR.V2} b - the second vertex texture coordinate
 *  @param {SQR.V2} c - the thrid vertex texture coordinate
 *  @param {SQR.V2=} d - the optional fourth vertex texture coordinate
 */
SQR.Face.prototype.setUV = function(uva, uvb, uvc, uvd) {
	var t = this;
	t.uva = uva;
	t.uvb = uvb;
	t.uvc = uvc;
	t.uvd = uvd;
	return t;
}

/** 
 *  Set the vertex color for each vertex
 *  <br><br>
 *  <strong>WARNING! Colors are not passed to the buffer currently (will be added in the future).</strong>
 *
 *  @method setColor
 *  @memberof SQR.Face.prototype 
 *
 *  @param {SQR.V2} a - the first vertex color
 *  @param {SQR.V2} b - the second vertex color
 *  @param {SQR.V2} c - the thrid vertex color
 *  @param {SQR.V2=} d - the optional fourth vertex color
 */
SQR.Face.prototype.setColor = function(ca, cb, cc, cd) {
	var t = this;
	t.ca = ca;
	t.cb = cb;
	t.cc = cc;
	t.cd = cd;
	return t;
}

/**
 *  Calculte the normal for this face. Regardless of whether there are 3 or 4 vertices
 *  the normal is calculated for the frst 3 of them an applied to the entire face.
 *  @method calculateNormal
 *  @memberof SQR.Face.prototype
 */
SQR.Face.prototype.calculateNormal = function() {
	var t = this;
	var t1 = SQR.V3.__tv1;
	var t2 = SQR.V3.__tv2;
	var va = t.vertexArray;
	t.normal = t.normal || new SQR.V3();

	if(t.indexed) {
		t1.sub(va[t.ia], va[t.ib]);
		if(t1.isZero()) t1.sub(va[t.ia], va[t.id]);
		t2.sub(va[t.ic], va[t.ia]);
	} else {
		t1.sub(t.a, t.b);
		if(t1.isZero()) t1.sub(t.a, t.d);
		t2.sub(t.c, t.a);
	}


	t.normal.cross(t1, t2);

	return t;
}

SQR.Face.prototype.v = SQR.Face.prototype.setPosition;
SQR.Face.prototype.i = SQR.Face.prototype.setIndex;
SQR.Face.prototype.n = SQR.Face.prototype.setNormal;
SQR.Face.prototype.uv = SQR.Face.prototype.setUV;
SQR.Face.prototype.cl = SQR.Face.prototype.setColor;
SQR.Face.prototype.cn = SQR.Face.prototype.calculateNormal;

SQR.Face.prototype.addNormalToVertices = function() {
	var t = this;
	var va = t.vertexArray;

	var a = t.indexed ? va[t.ia] : t.a;
	var b = t.indexed ? va[t.ib] : t.b;
	var c = t.indexed ? va[t.ic] : t.c;
	var d = t.indexed ? va[t.id] : t.d;

	a.addNormal(t.normal);
	b.addNormal(t.normal);
	c.addNormal(t.normal);
	if(d) d.addNormal(t.normal);
	return t;
}

SQR.Face.prototype.toBuffer = function(geo, position, perVertextNormal, preNormalizeNormal) {
	var t = this;
	var ap = 'aPosition', an = 'aNormal', au = 'aUV';
	var c = position;

	if(geo.attributes[ap]) {
		geo.set(ap, c+0, t.a).set(ap, c+1, t.b).set(ap, c+2, t.c);
		if(t.d) geo.set(ap, c+3, t.c).set(ap, c+4, t.b).set(ap, c+5, t.d);
	}

	if(geo.attributes[an] && (t.normal || perVertextNormal)) {
		var v = perVertextNormal, n = t.normal;

		if(preNormalizeNormal && !v) t.normal.norm();

		geo.set(an, c+0, v ? t.a.normal : n)
		   .set(an, c+1, v ? t.b.normal : n)
		   .set(an, c+2, v ? t.c.normal : n);

		if(t.d) {
			geo.set(an, c+3, v ? t.c.normal : n)
			   .set(an, c+4, v ? t.b.normal : n)
			   .set(an, c+5, v ? t.d.normal : n);
		}
	}

	if(geo.attributes[au] && t.uva) {
		geo.set(au, c+0, t.uva).set(au, c+1, t.uvb).set(au, c+2, t.uvc);
		if(t.d) geo.set(au, c+3, t.uvc).set(au, c+4, t.uvb).set(au, c+5, t.uvd);
	}

	return t.d ? 6 : 3;
}

/* --- --- [primitives/Icosphere.js] --- --- */

SQR.Primitives.createIcosphere = function(radius, subdivisions, options) {

    var faces = [], vectors = [];
    var vertices = [], normals = [], colors = [], texcoords = [];
    var cache = [], cacheIndex = 0;

    options = options || {};

    var levels = [
        [1, 0, 0, 1],
        [0, 1, 0, 2],
        [0, 0, 1, 3],
        [1, 1, 0, 4],
        [0, 1, 1, 5]
    ];

    var addVertex = function(v) {
        vectors.push(v);
    }

    var texTmp = new SQR.V3();
    var up = new SQR.V3(0, 1, 0);
    var forward = new SQR.V3(0, 0, 1);

    var getTexCoord = function(v) {
        var tx, ty;
        texTmp.copyFrom(v);
        texTmp.norm();
        tx = 1.0 - (0.5 + Math.atan2(texTmp.z, texTmp.x) / SQR.TWOPI);
        ty = 1.0 - (0.5 - Math.asin(texTmp.y) / Math.PI);
        return new SQR.V2(tx, ty);
    }

    var addFace = function(a, b, c, ca, cb, cc) {
        var ta = getTexCoord(a);
        var tb = getTexCoord(b);
        var tc = getTexCoord(c);
        var f = new SQR.Face().setPosition(a, b, c).setUV(ta, tb, tc).setColor(ca, cb, cc);
        faces.push(f);
    }

    // > http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html

    var checkSubdivisionCache = function(v1, v2) {
        var l = vectors.length;

        for(var i = 0; i < l; i++) {
            var vc = vectors[i];

            var lr = vc.__v1 == v1 && vc.__v2 == v2;
            var rl = vc.__v2 == v1 && vc.__v1 == v2;

            if(lr || rl) return vc;
        }

        var v = new SQR.V3();
        v.sub(v1, v2).mul(0.5).add(v, v2).norm().mul(radius);

        v.__v1 = v1;
        v.__v2 = v2;
        vectors.push(v);

        v.normal = v.clone();

        return v;
    }

    var subdivide = function() {

        // console.log("--- subdivide");

        cache[cacheIndex] = {};
        var c = cache[cacheIndex];

        c.faces = faces;
        c.vectors = vectors;
        faces = [];
        // vectors = [];

        var numTris = c.faces.length;

        for(var i = 0; i < numTris; i++) {
            var vs = c.faces[i];

            var ab = checkSubdivisionCache(vs.a, vs.b);
            var ac = checkSubdivisionCache(vs.a, vs.c);
            var bc = checkSubdivisionCache(vs.b, vs.c);

            var color = levels[cacheIndex+1];

            addFace(vs.a, ab, ac,       vs.ca, color, color);
            addFace(vs.b, bc, ab,       vs.cb, color, color);
            addFace(vs.c, ac, bc,       vs.cc, color, color);
            addFace(ab, bc, ac,         color, color, color);
        }

        cacheIndex++;
    }


    var r = radius ;

    var t = (1.0 + Math.sqrt(5.0)) * 0.5 * r;

    var av = function(x, y, z) {
        var v = new SQR.V3(x, y, z).norm();
        v.normal = v.clone();
        if(options.reverseNormals) v.normal.neg();
        v.mul(radius);
        vectors.push(v);
    }

    var af = function(a, c, b) {
        var color = levels[0];
        addFace(vectors[a], vectors[b], vectors[c], color, color, color);
    }
    
    av(-r,  t,  0);
    av( r,  t,  0);
    av(-r, -t,  0);
    av( r, -t,  0);

    av( 0, -r,  t);
    av( 0,  r,  t);
    av( 0, -r, -t);
    av( 0,  r, -t);

    av( t,  0, -r);
    av( t,  0,  r);
    av(-t,  0, -r);
    av(-t,  0,  r);

    // 5 faces around point 0
    af(0, 11, 5);
    af(0, 5, 1);
    af(0, 1, 7);
    af(0, 7, 10);
    af(0, 10, 11);

    // 5 adjacent faces
    af(1, 5, 9);
    af(5, 11, 4);
    af(11, 10, 2);
    af(10, 7, 6);
    af(7, 1, 8);

    // 5 faces around point 3
    af(3, 9, 4);
    af(3, 4, 2);
    af(3, 2, 6);
    af(3, 6, 8);
    af(3, 8, 9);

    // 5 adjacent faces
    af(4, 9, 5);
    af(2, 4, 11);
    af(6, 2, 10);
    af(8, 6, 7);
    af(9, 8, 1);

    while(subdivisions-- > 0) subdivide();

    var geo = SQR.Buffer()
        .layout( {'aPosition': 3, 'aNormal': 3, 'aUV': 2 }, faces.length * 3);

    var c = 0, t;
    faces.forEach(function(t) {
        if(options.flatShading) t.calculateNormal();
        c += t.toBuffer(geo, c, !options.flatShading);
    });

    return geo;
}

/* --- --- [primitives/Mesh.js] --- --- */

/**
 *  @namespace Mesh
 *  @memberof SQR
 *
 *  @description <p>A higher level wrapper for buffers designed 
 *	to make management of 3d solid objects easier.</p>
 */

/*
 *	<h3>Some theory about meshesh</h3>
 *
 *	<p>A buffer is an array composed of an abritrary number of attributes. Their names and size can express anything 
 *	- somtimes position, but also angle, radius, size, speed, velocity, mass... you name it. It will all work ok as long as there 
 *	we write a shader that can interpret those attributes and translate them into a vertex position. 
 *	This is great for for particle systems and other fancy shapes.</p>
 *
 *	<p>However, there are cases where we simply need to draw a mesh that is a solid object.
 *	These meshes are not as diverse in their structure. They typically all have the same set of attributes. 
 *	These inlude:</p>
 *
 *	<ol>
 *		<li>aPosition - the 3d position of the vertex</li>
 *		<li>aNormal - the normal of the vertex</li>
 *		<li>aUV - the texture coordinate of the vertex</li>
 *		<li>aUV2 - secondary texture coordinate of the vertex (for lightmapping or whatever)</li>
 *		<li>aTangent - the tangent of the vertex for normal mapping</li>
 *		<li>aBinormal - the binomal of the vertex for normal mapping 
 *			(not sure if this is actually useful, maybe can be computer in the shader?)</li>
 *		<li>aWeight - the bone weights</li>
 *		<li>aIndex - the bone indices</li>
 *		<li>aColor - the vertex color</li>
 *	</ol>
 *
 *	<p>Now, a lot of meshes will come from the Unity exporter and they will have some or all of the above attributes. With things like
 *	boneWieght and boneIndices it would be insane to try to create them in code (I tried).
 *	So most cases it is best to take the exported data, push it into a buffer and not have a Mesh at all. Expect in two cases:
 *	</p>
 *
 *	<ul>
 *		<li>The mesh is supposed to be animated per-vertex in Javascript (not in shader)</li>
 *		<li>The mesh lacks normal, tangent or binormal data and these need to be calculated before rendering</li>
 *	</ul>
 *
 *	<p>So moving vertex positions around and recalculating normals (or tangents and binormals, which is similar) are the two 
 *	most important features that the Mesh class should deal with. It's worth noting that after the vertices positions are moved, 
 *	recalculating the normals is the necessary next step in most cases anyway - so the two are tied together. Attributes such as UVs
 *	will almost never be animated (I can't think of a scenario where this would make sense). A color attribute can be animated, but usually
 *	this one is very rarely used.</p>
 *
 *	<p>Meshes are often indexed but it's not as staightforward as it may seem. Indexing vertex positions is simple and elegant, but often 
 *	we need to have one vertex position to have more than one different texture coordinates because every face the vertex is attached 
 *	to will have it's own texture mapping. Same goes for normals - if we need to have 100% flat shading, every face needs to have it's 
 *	own vertices and not share it with any other face.</p>
 *
 *	<p>This can get pretty involved to figure out ex. how to break the vertices based on the angle between the faces. We could implement it 
 *	some day, but given that Unity handles this already it seems a bit overkill. Instead we can opt for calculating averaged normals for 
 *	each vertex that is shared by more than one face for meshes imported from Unity.</p>
 *
 *	<p>Another category are realtime primitives (cubes, spheres, planes) and other realtime generated meshes. This is where the Mesh
 *	class is going to be most useful. The idea here is to be able to create faces (tris or quads) based on vertex position and 
 *	add other attributes - either manually or by some kind of computation.</p>
 *
 *	<p>When it comes to adding attributes based on some algorithm - in most cases it means it will be derived from vertex positions.
 *	The most basic example is of course calculating normals, but other good example is calculating texture coordinates based on some
 *	mapping system (cubic, spherical etc...) or vertex color also based on some sort of mapping.</p>
 *
 *	<p>Manually adding attributes in code seems impractical. For example it is far easier to perform a custom texture mapping in a
 *	3d software such as C4D than to try to add the mapping in code. So let's just forget about it and focus on what code is 
 *	good at - computation.</p>
 *
 *	<p>Let's examine 3 simple cases and 2 more complex ones.</p>
 *
 *	<p>Case 1: a plane. A plane is trivial. The normals are all the same and all point up from the surface of the plane. The UV mapping
 *	is trivial as well - each vertex UV coordinate is based on it's porportional position in the plane and the entire plane is mapped to
 *	texture coords going from 0 to 1 on both u and c axes. This kind of mesh could actually be indexed on the buffer level and draw using 
 *	drawElements.</p>
 *
 *	<p>Case 2: a sphere. Sphere is also pretty simple - normals are basically normalized vertex positions and UV mapping is derived from 
 *	the latitude and longitude of each vertex. Typically the vertex positions themselves are calculated from angle during the creation of
 *	the mesh.</p>
 *
 *	<p>Case 3: a cube. A cube is composed of six planes, so same rules apply. Actuall the entire cube creation code can consist of creating
 *	six planes and merging them together.</p>
 *
 *	<p>Case 4: a plane with a height map or vertex animation (cloth, water, terrain). It starts with a plane that is subdivided. The UV mapping is the same.
 *	Then the vertex positions can be moved around (typically for a XZ plane, we move the Y position up and down) and normals (tangents etc)
 *	can be recalculated. Since the plane is subdivided anbd not flat we can either average normals and make it smooth or 
 *	make them flat shaded.</p>
 *
 *	<p>Case 5: pyramid, cylinder or cone, or any other primitive shape. The positions for those shapes can be generated with code and normals
 *	can be derived from these positions. However, there is no obvious way to come up with UV coordinates. Texture mapping algorithms can be helpful
 *  in this case, or, if we go with a low poly esthetic we can skip UVs entirely.</p>
 *
 *	<p>Except for Case 1, all the other meshes do not lend themselves easily to indexing. It can be done, but it will result in complex code and 
 *	we're not sure if it is worth the effort. Instead, we can load all the vertices to the buffer separately. However, it makes total sense to keep
 *	a list of vertices shared by faces but not duplicated for each face. This will make it possible to modulate their position without having the
 *	mesh break and also it will make it possible to calculate smooth normals.</p>
 *
 *	<p>This leads to the conclusion that realtime meshes should not be indexed at all on the buffer level, but reusing vertex objects on the JS side
 *	is a good idea.</p>
 *
 *	<p>PS. This about <a href='http://marcinignac.com/blog/fast-dynamic-geometry-in-webgl/'>this</a>. Honestly
 *	it sounds very resnoable, but code tests I did now do not prove that this is the best way (not to mention
 *	the resulting code complexity...)</p>
 */
SQR.Mesh = function() {

	if(!(this instanceof SQR.Mesh)) return new SQR.Mesh();

	var m = this;

	m.polys = [];
	m.vertices = [];
	m.uvs = [];
	m.size = 0;

	m.addVertex = function(x, y, z) {
		var v = new SQR.Vertex(x, y, z);
		m.vertices.push(v);
		return m.vertices.length - 1;
	};

	m.addUV = function(u, v) {
		var v = new SQR.V2(u, v);
		m.uvs.push(v);
		return m.uvs.length - 1;
	}

	m.addFace = function() {
		var p = new SQR.Poly(m);
		p.V.apply(p, arguments);
		m.polys.push(p);
		m.size += p.triangles.length;
		return p;
	};

	
	m.calculateNormals = function(s) {

		m.smooth = s;

		for(var i = 0, l = m.polys.length; i < l; i++) {
			m.polys[i].calculateNormal();
		}

		if(m.smooth) {
			for(var i = 0, l = m.vertices.length; i < l; i++) {
				if(m.vertices[i].polys) m.vertices[i].calculateNormal();
			}
		}

		return m;
	};

	m.flip = function() {
		for(var i = 0, l = m.polys.length; i < l; i++) {
			m.polys[i].flip();
		}

		return m;
	}

	m.calculateTangents = function() {
		console.log('SQR.Mesh.calculateTangents is not implemented yet!');
	};

	var createBuffer = function() {

		var p = m.polys[0];

		var s = m.size;

		var l = { aPosition: 3 };
		if(p.normal) l.aNormal = 3;
		if(p.uvs.length > 0) l.aUV = 2;

		m.buffer = SQR.Buffer().layout(l, s);
		return m.buffer;
	}

	m.update = function() {

		if(m.polys.length == 0) {
			console.warn('> SQR.Mesh.update > no polys found to create buffer from.');
			return;
		}

		var b = m.buffer || createBuffer();

		var p = b.attributes.aPosition, c = 0;

		var transport = [];
		
		for(var i = 0, ml = m.polys.length; i < ml; i++) {

			var pl = m.polys[i];

			for(var j = 0, vl = pl.triangles.length; j < vl; j++) {

				var ti = pl.triangles[j];

				var v = m.vertices[pl.vertices[ti]];

				var p = v.position;
				var n = m.smooth ? v.normal : pl.normal;
				var t = m.uvs[pl.uvs[ti]];

				transport.length = 0;
				transport.push(p.x, p.y, p.z, n.x, n.y, n.z, t.x, t.y);
				b.set(null, c, transport);

				c++;
			}
		}


		b.update();

		if(!b.mesh) b.mesh = m;

		return b;
	}

	// Aliases
	m.V = m.addVertex;
	m.F = m.addFace;
	m.T = m.addUV;
};



/**
 *	@method fromJSON
 *	@memberof SQR.Mesh
 *
 *	@param {Object | string} data - the mesh data or an object containing a named list of meshes 
 *	(which is how meshes get exported from unity by default - the names are the uuids of the object)
 *
 *	@param {string=} name - the name of the mesh in the list. 
 *	If data is a list of meshes and name is omitted, the function will pick the first mesh on the list.
 *	If data is the mesh data itself, this argument will be ignored.
 *
 *	@param {Object=} options - advanced options for mesh construction
 *
 *	@description <p>Utility to load meshes from JSON files in the 
 *	format as exported from the Unity exporter.</p>
 *
 *	<p>Parses the J3D JSON mesh data format and creates an instance SQR.Buffer out of it.</p>
 *
 *	<p>This is the best way to work with 3d models, since SQR doesn't have native support for OBJ files or Collada 
 *	(though it's perfectly possible to create an OBJ or Collada importer if you need to).</p>
 */	
SQR.Mesh.fromJSON = function(data, name, options) {

	var geo;

	options = options || {};

	if(name) {
		// data is a list of meshesh from Unity and we provide a name
		geo = data[name];
	} else if(data.vertices) {
		// data is the mesh itself
		geo = data;
	} else {
		// data is a list of meshes from Unity but we didn't provide a name

		// Unity exported mesh files can have one or more meshes. 
		// Even if there's only one mesh, it is stored as property
		// where the key is the mesh uuid. This code will attempt
		// to find the first mesh, so that on JS side we don't have to 
		// pass the uuid in the constructor
		for(var d in data) {
			geo = data[d];
			break;
		}
	}

	if(!geo) throw "> SQR.Mesh - mesh not found in data (name: " + name + ")";

	// This is to be able to work with old JSON format. Needs to go away at some point.
	var legacyAttribute = {
		aPosition: 'vertices',
		aNormal: 'normals',
		aColor: 'colors',
		aUV: 'uv1',
		aUV2: 'uv2',
		aTangent: 'tangent',
		aWeight: 'boneWeights',
		aIndex: 'boneIndices',
		indices: 'tris'
	};

	var getAttributeData = function(n) {
		var d = geo[n] || geo[legacyAttribute[n]];

		if(d && d.length > 0) {
			return d;
		} else if(d.length == 0 && n == 'aUV2') {
			return getAttributeData('aUV');
		} else {
			return null; 
		}
	}

	var layout = options.layout || data.layout || SQR.v3n3u2();
	var vs = options.vertexSize || layout.aPosition;
	var size = (geo.vertices || geo.aPosition).length / vs;

	var buffer = SQR.Buffer().layout(layout, size);

	for(var a in layout) {
		var d = getAttributeData(a);
		if(d) buffer.data(a, d);
	}

	var i = getAttributeData('indices');
	if(i) buffer.index(i);

	// SQR.Mesh(buffer);

    return buffer.update();
};


/* --- --- [primitives/Plane.js] --- --- */

/**
 *  @method createPlane
 *  @memberof SQR.Primitives
 *
 *  @description Creates a plane, by default on the X/Y plane
 *
 *  @param {Number} w - width of the plane
 *  @param {Number} h - height of the plane
 *  @param {Number} wd - number of segments along the width
 *  @param {Number} hd - number of segments along the height
 *  @param {Number} wo - horizontal offset
 *  @param {Number} ho - vertical offset
 *
 *	@param {Object} options - options for the plan construction
 *
 *  @returns {SQR.Buffer}
 */
SQR.Primitives.createPlane = function(w, h, wd, hd, wo, ho, options) {

	var options = options || {};

	var w = w * 0.5;
	var h = h * 0.5;

	var wo = wo || 0;
	var ho = ho || 0;

	var wd = wd || 1;
	var hd = hd || 1;

	var wStart = -w + wo;
	var hStart = -h + ho;

	var wb = (w * 2) / wd;
	var hb = (h * 2) / hd;

	var i, j;
	var m = new SQR.Mesh();

	for (i = 0; i < wd+1; i++) {
		for (j = 0; j < hd+1; j++) {

			var bvStart = wStart + i * wb;
			var bhStart = hStart + j * hb;

			if (!options.zUp) {
				m.V(bvStart, 0, bhStart);
			} else {
				m.V(bvStart, bhStart, 0);
			}

			m.T(i/wd, j/hd);
		}
	}

	for (i = 0; i < wd; i++) {
		for (j = 0; j < hd; j++) {

			var bvStart = wStart + i * wb;
			var bvEnd = bvStart + wb;
			var bhStart = hStart + j * hb;
			var bhEnd = bhStart + hb;

			var a = (i+0) * (hd+1) + j;
			var b = (i+1) * (hd+1) + j;

			m.F(a, a+1, b, b+1).T(a, a+1, b, b+1);
		}
	}

	m.calculateNormals(options.smooth);
	if(options.flip) m.flip();

	return m.update();
}


 /*
 *  @method create2DQuad
 *  @memberof SQR.Primitives
 *
 *  @description Creates a 2d quad
 *
 *  @param {Number} x - x position of the quad
 *  @param {Number} y - y position of the quad
 *  @param {Number} w - width of the quad
 *  @param {Number} h - height of the quad
 *
 *  @returns {SQR.Buffer}
 */
// SQR.Primitives.create2DQuad = function(x, y, w, h) {
// 	return SQR.Buffer()
// 		.layout(SQR.v2u2(), 6)
// 		.data('aPosition',   x, y+h,   x+w, y,     x+w, y+h,    x+w, y,    x, y+h,    x, y)
// 		.data('aUV',         0, 0,     1,   1,     1,   0,      1,   1,    0, 0,      0, 1)
// 		.update();
// }

















/* --- --- [primitives/Poly.js] --- --- */

SQR.Poly = function(mesh) {

	var p = this;
	p.mesh = mesh;
	p.triangles = [];
	
}

SQR.Poly.prototype.addVertices = function() {
	var p = this;

	p.size = arguments.length;

	if(p.size < 3) {
		throw '> SQR.Poly.addVertices > A poly needs at least 3 vertices.';
	}

	p.vertices = [];

	for(var i = 0; i < p.size; i++) {
		var id = arguments[i];
		p.mesh.vertices[id].addPoly(p);
		p.vertices.push(id);
	}

	// Attempt to form triangles for classic cases of tris and quads
	// Above 4 vertices however, user needs to provide own mapping but populating p.triangles
	if(p.size >= 3) p.triangles.push(0, 1, 2);
	if(p.size >= 4) p.triangles.push(2, 1, 3);

	return p;
}

SQR.Poly.prototype.addUV = function(a, b, c, d) {
	var p = this;
	p.uvs = [a, b, c];
	if(d) p.uvs.push(d);
	return p;
}

SQR.Poly.prototype.flip = function() {
	var p = this;
	var v = this.vertices;
	var u = this.uvs;
	
	var tmp = v[1];
	v[1] = v[2];
	v[2] = tmp;

	if(u) {
		tmp = u[1];	
		u[1] = u[2];
		u[2] = tmp;
	}

	if(v.normal) v.normal.neg();
	else if(p.normal) p.normal.neg();
	else console.log('> SQR.Poly.flip > please consider calculating normal first, then flipping');
}

SQR.Poly.prototype.calculateNormal = function() {

	var p = this;
	var v = this.vertices;
	var va = p.mesh.vertices;

	var t1 = SQR.V3.__tv1;
	var t2 = SQR.V3.__tv2;
	p.normal = p.normal || new SQR.V3();

	t1.sub(va[v[0]].position, va[v[1]].position);
	if(t1.isZero() && p.size > 3) t1.sub(va[v[0]].position, va[v[3]].position);
	t2.sub(va[v[2]].position, va[v[0]].position);

	p.normal.cross(t1, t2).norm();

	return p;
}

// Aliases
SQR.Poly.prototype.V = SQR.Poly.prototype.addVertices;
SQR.Poly.prototype.T = SQR.Poly.prototype.addUV;













/* --- --- [primitives/PostEffect.js] --- --- */

/**
 *  @function createPostEffect
 *  @memberof SQR.Primitives
 *
 *  @description Creates a post-processing effect (such as SAO or depth-of-field). It creates
 *	an instance of SQR.Transform with a full screen quad buffer and the shader build from the provided source.
 *	Please read the {@tutorial post-effects} tutorial to see how it works. 
 *
 *	@param {string} shaderSource - the source of the shader for this post effect
 *	@param {Object=} shaderOptions - options for the shader. Same as in the {@link SQR.Shader} constructor
 *
 *	@returns {SQR.Transform} a transform representing this post effect
 */
SQR.Primitives.createPostEffect = function(shaderSource, shaderOptions, fullScreenQuad) {

    // SQR.fullScreenQuad = SQR.fullScreenQuad || SQR.Buffer()
   fullScreenQuad = fullScreenQuad || SQR.Buffer()
        .layout(SQR.v2u2(), 6)
        .data('aPosition', -1, 1,   1, 1,   1, -1,   -1, 1,   1, -1,   -1, -1)
        .data('aUV',        0, 1,   1, 1,   1,  0,    0, 1,   1,  0,    0,  0)
        .update();

    var pe = new SQR.Transform('post-effect');

    // pe.buffer = SQR.fullScreenQuad;
    pe.buffer = fullScreenQuad;
    
    if(shaderSource) pe.shader = SQR.Shader(shaderSource, shaderOptions);

    return pe;
}


// SQR.Primitives.createImage = function(img, mode, shaderSource, shaderOptions) {

// 	if(!shaderSource && !SQR.GLSL) throw '> SQR.Primitives.createImage > sqr-glsl.js package is required to use this feature.';
//     shaderSource = shaderSource || SQR.GLSL['post/image.glsl'];

// 	var pe = new SQR.Transform();

//     pe.buffer = SQR.Buffer()
//         .layout(SQR.v2u2(), 6)
//         .data('aPosition', -1, 1,   1, 1,   1, -1,   -1, 1,   1, -1,   -1, -1)
//         .data('aUV',        0, 1,   1, 1,   1,  0,    0, 1,   1,  0,    0,  0)
//         .update();

//     var image = img;
//     var texture = SQR.Texture(image);
//     pe.shader = SQR.Shader(shaderSource, shaderOptions);

//     pe.setImage = function(img) {
//         image = img;
//         texture.setSource(img).update();
//         pe.shader.use().setUniform('uTexture', texture);
//     }

//     pe.setImage(image);

//     pe.size = function(w, h) {

//         var xl = -1, yt = 1, xr = 1, yb = -1;
//         var iw = image.width, ih = image.height;

//         var fw = iw / ih * h;
//         var fh = ih / iw * w;

//         if(mode == 'fit') {
//             if(fw > w) {
//                 yb = -(fh / h);
//                 yt =  (fh / h);
//             }

//             if(fh > h) {
//                 xl = -(fw / w);
//                 xr =  (fw / w);
//             }
//         } else if(mode == 'cover') {    
//             if(fw > w) {
//                 xl = -(fw / w);
//                 xr =  (fw / w);
//             }

//             if(fh > h) {
//                 yb = -(fh / h);
//                 yt =  (fh / h);
//             }
//         }

//         pe.buffer.data('aPosition', 
//             xl, yt,
//             xr, yt,
//             xr, yb,

//             xl, yt,
//             xr, yb,
//             xl, yb
//         ).update();

//         return pe;
//     }

// 	return pe;
// }










/* --- --- [primitives/SceneParser.js] --- --- */

/**
 *  @namespace SceneParser
 *  @memberof SQR
 *
 *  @description Utility to load scenes from J3D/Unity exported JSON files.
 *
 */
SQR.SceneParser = (function() {

	// var skinnedMeshLayout = function() { return { aPosition: 3, aNormal: 3, aUV: 2, aWeight: 4, aIndex: 4 } };

	var arrayToObject = function(a, v) {
		v.x = a[0];
		v.y = a[1];
		v.z = a[2];
		if(v.w) v.w = a[3];
	}

	return {

		/**
		 *	@method fromJSON
		 *	@memberof SQR.SceneParser
		 *
		 *	@description Parses the J3D JSON scene data format and creates a SQR.Buffer out of it.
		 *
		 *	@param {Object} assets The assets loaded with SQR.Loader or otherwise. 
		 *	This method will expect to find all the 3 exported files in there, named 'scene', 'mesh' and 'anim'. 
		 *	Alternatively a prefix can be provided in the seconds, options argument.
		 *
		 *	@param {Object} options Options on how to parse the scene.
		 */	
		parse: function(assets, options) {

			options = options || {};

			var prefix = options.prefix || '';
			var scene = assets[prefix + 'scene'];
			var meshes = assets[prefix + 'mesh'];
			var anim = assets[prefix + 'anim'];

			if(options.context) {
				var bc = scene.background;
				options.context.clearColor(bc.r, bc.g, bc.b);
			};

			var getDefaultShader = (function() {
				var d;
				return function() {
					if(!d) d = options.shader.setUniform ? options.shader : SQR.Shader(options.shader);
					return d;
				}
			})();

			// If this is a scene coming from unity we need to flip the matrix
			// TODO: this doesn't play well with the WebVR thing btw....
			SQR.flipMatrix = (options && options.flipMatrix) ? options.flipMatrix : false;

			var buffers = {}, bufferByName = {};
			var skinnedMeshes = [];
			var animations = {};

			for(var n in meshes) {
				var md = meshes[n];

				var layout = SQR.v3n3u2();

				if(md.boneWeights) {
					 layout.aWeight = 4;
					 layout.aIndex = 4;
				}

				if(md.uv2) {
					layout.aUV2 = 2;
				}

				var b = SQR.Mesh.fromJSON(md, null, { layout: layout });
				buffers[n] = b;
				bufferByName[md.name] = b;
			}

			for(var m in scene.materials) {
				var mat = scene.materials[m];
				mat.color = SQR.Color().setRGB(mat.color.r, mat.color.g, mat.color.b);
			}

			var root = new SQR.Transform();
			var camera;
			var ts = scene.transforms;

			ts.forEach(function(td) {
				var t = new SQR.Transform(td.name, td.uid);
				t.useQuaternion = true;
				arrayToObject(td.position, t.position);
				arrayToObject(td.rotation, t.quaternion);
				if(td.scale) arrayToObject(td.scale, t.scale);

				t.data = td;
				if(td.bones) skinnedMeshes.push(t);

				if(td.camera) {
					camera = t;
					var cd = scene.cameras[td.camera];

					// var resize = function() {
						var w = window.innerWidth, h = window.innerHeight, aspect = w/h;
						camera.projection = new SQR.ProjectionMatrix().perspective(cd.fov, aspect, cd.near, cd.far);
					// }

					// window.addEventListener('resize', resize);
					// resize();
				}

				if(td.lightmapTileOffset) {
					t.uniforms = t.uniforms || {};
					t.uniforms.uLightmapTileOffset = td.lightmapTileOffset;
				}

				if(td.mesh) {
					t.buffer = buffers[td.meshId];
					
				}

				if(td.collider) {
					var c;
					switch(td.collider.type) {
						case 'sphere':
							c = SQR.Collider.Sphere();
							c.radius = td.collider.radius;
							arrayToObject(td.collider.center, c.center);
							
							break;
						case 'box':
							c = SQR.Collider.Box();
							var cn = td.collider.center, si = td.collider.size;
							c.box = {
								maxX: cn[0] + si[0]/2, minX: cn[0] - si[0]/2,
								maxY: cn[1] + si[1]/2, minY: cn[1] - si[1]/2,
								maxZ: cn[2] + si[2]/2, minZ: cn[2] - si[2]/2,
							};
							break;
						case 'mesh':
							c = SQR.Collider.Mesh(buffers[td.meshId]);
							break;
					}
					t.collider = c;
				}

				
				if(td.renderer) {

					// we will deal with skinned meshes below
					if(!td.bones) t.shader = getDefaultShader();

					t.uniforms = t.uniforms || {};
					t.uniforms.uColor = scene.materials[td.renderer].color;
					
				}

				if(td.parent) {
					root.findById(td.parent).add(t);
				} else {
					root.add(t);
				}
			});

			skinnedMeshes.forEach(function(s) {
				var bs = s.data.bones, bst = [], numBones = bs.length;
				
				bs.forEach(function(id) {
					bst.push(root.findById(id));
				});

				bst[0].setAsBoneRoot();

				var boneMatrices = [];

				s.shader = SQR.Shader(options.shader, {
					directives: [
						{ name: 'NUM_BONES', value: numBones },
						{ name: 'BONE_PER_VERTEX', value: 4 }
					]
				});

				s.beforeDraw = function() {

					for(var i = 0; i < numBones; i++) {
						boneMatrices[i] = bst[i].computeBoneMatrix();
					}

					s.shader.use().setUniform('uBones', boneMatrices);
				}
			});

			for(var id in anim) {

				var data = anim[id];

				animations[id] = {
					duration: data.length,
					transforms: {}
				};

				for(var c in data.curves) {

					animations[id].transforms[c] = {
						properties: {}
					};

					for(var p in data.curves[c]) {
						var keyframes = [];
						var d = data.curves[c][p];

						if(options.linearAnimation) {
							for(var i = 0; i < d.keys.length; i += 4) {
								var a = d.keys[i + 0];
								var b = d.keys[i + 1];
								keyframes.push(new SQR.V2(a, b));								
							}
						} else {
							for(var i = 0; i < d.keys.length - 4; i += 4) {
								var k1t = d.keys[i+0];
								var k1v = d.keys[i+1];
								var k1o = d.keys[i+3];

								var k2t = d.keys[i+4];
								var k2v = d.keys[i+5];
								var k2i = d.keys[i+6];
								
								var start = new SQR.V2(k1t, k1v);
								var end = new SQR.V2(k2t, k2v);

								var dt = (end.x - start.x) / 3.0;
								var st = new SQR.V2( dt,  dt * k1o).add(start);
								var et = new SQR.V2(-dt, -dt * k2i).add(end);

								keyframes.push(new SQR.Bezier(start, st, et, end));
							}
						}

						animations[id].transforms[c].properties[p] = keyframes;
					}
				}
			}

			root.recurse(function(t) {
				if(t.data && t.data.animationId) {
					var id = t.data.animationId;
					var data = animations[id];

					// Aniation file is missing or was not exported, abort.
					if(!data) return;

					t.animation = SQR.Animation(data.duration);

					for(var cn in data.transforms) {
						var c = t.findByPath(cn);
						c.clip = SQR.Clip(data.duration);
						t.animation.addClip(c.clip);

						for(var p in data.transforms[cn].properties) {
							c.clip.addProperty(p, data.transforms[cn].properties[p]);
						}
					}

					if(options.autoPlay) t.animation.play();
				};
			}, true);

			return {
				root: root, camera: camera, buffers: bufferByName
			};
		}

	}

})();

/* --- --- [primitives/Sphere.js] --- --- */

/**
 *  @method createSphere
 *  @memberof SQR.Primitives
 *
 *  @description Creates a simple cube geometry, 1 quad per side, with UVs, non-indexed
 *
 *  @param {Number} radius - radius of the sphere
 *  @param {Number=} [sw=8] - width (longitude) segments. Minimum 3.
 *  @param {Number=} [sh=6] - width (latitude) segments. Minimum 3.
 *  @param {Object=} options - additional settings
 *
 *  @returns {SQR.Buffer}
 */
SQR.Primitives.createSphere = function(radius, segmentsX, segmentsY, options) {

	var m = new SQR.Mesh();

	radius = radius || 50;
	segmentsX = Math.max(3, Math.floor(segmentsX) || 8);
	segmentsY = Math.max(3, Math.floor(segmentsY) || 6);
	options = options || {};

	var phi = Math.PI * 2;
	var tht = Math.PI;

	var x, y;

	// for (y = 1; y <= segmentsY - 1; y++) {
	for (y = 0; y <= segmentsY; y++) {

		for (x = 0; x < segmentsX; x++) {

			var u = x / (segmentsX - 1);
			var v = y / segmentsY;

			var xp = -radius * Math.cos(u * phi) * Math.sin(v * tht);
			var yp =  radius * Math.cos(v * tht);
			var zp =  radius * Math.sin(u * phi) * Math.sin(v * tht);

			var i = m.V(xp, yp, zp);
			m.T(u, 1 - v);

		}
	}

	// var northPole = m.V(0, radius, 0);
	// var southPole = m.V(0, -radius, 0);	
	// m.T(1, 1);
	// m.T(0, 0);

	for (y = 0; y < segmentsY; y++) {

		var isn = y == 0;
		var iss = y == segmentsY - 1;

		for (x = 0; x < segmentsX; x++) {

			var y0 = y;
			var y1 = y + 1;

			var x0 = x;
			var x1 = (x + 1) % (segmentsX);

			var ta = y0 * segmentsX + x0;// - segmentsX;
			// if(isn) ta = northPole;

			var tb = y0 * segmentsX + x1;// - segmentsX;
			// if(isn) tb = northPole;

			var tc = y1 * segmentsX + x0;// - segmentsX;
			// if(iss) tc = southPole;

			var td = y1 * segmentsX + x1;// - segmentsX;
			// if(iss) td = southPole;

			if(isn) {
				m.F(ta, td, tc).T(ta, td, tc);
			} else if(iss) {
				m.F(ta, tb, td).T(ta, tb, td);
			} else {
				m.F(ta, tb, tc, td).T(ta, tb, tc, td);
			}

		}
	}

	m.calculateNormals(options.smooth);
	if(options.flip) m.flip();

	return m.update();
}

/* --- --- [primitives/Vertex.js] --- --- */

SQR.Vertex = function(x, y, z) {
	var v = this;
	v.position = new SQR.V3(x, y, z);
	v.normal = new SQR.V3();
	
}

SQR.Vertex.prototype.addPoly = function(p) {
	var v = this;
	v.polys = v.polys || [];
	v.polys.push(p);
}

SQR.Vertex.prototype.calculateNormal = function() {
	var v = this;
	v.normal.set();
	for(var i = 0, l = v.polys.length; i < l; i++) {
		v.normal.add(v.polys[i].normal);
	}
	v.normal.norm();
}

